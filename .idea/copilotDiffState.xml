<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/dao/WorkoutEntryDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/dao/WorkoutEntryDao.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.data.dao&#10;&#10;import androidx.room.*&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface WorkoutEntryDao {&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        SELECT we.id, we.day_id as dayId, we.exercise_id as exerciseId, we.sets, we.reps, we.isCompleted, we.totalSecondsSpent,&#10;               e.name as exerciseName, e.isCompound&#10;        FROM workout_entries we&#10;        INNER JOIN exercises e ON we.exercise_id = e.id&#10;        WHERE we.day_id = :dayId&#10;        ORDER BY we.id&#10;    &quot;&quot;&quot;)&#10;    fun getWorkoutEntriesForDay(dayId: Int): Flow&lt;List&lt;WorkoutEntryWithExercise&gt;&gt;&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        SELECT we.id, we.day_id as dayId, we.exercise_id as exerciseId, we.sets, we.reps, we.isCompleted, we.totalSecondsSpent,&#10;               e.name as exerciseName, e.isCompound&#10;        FROM workout_entries we&#10;        INNER JOIN exercises e ON we.exercise_id = e.id&#10;        WHERE we.day_id = :dayId&#10;        ORDER BY we.id&#10;    &quot;&quot;&quot;)&#10;    suspend fun getWorkoutEntriesForDaySync(dayId: Int): List&lt;WorkoutEntryWithExercise&gt;&#10;&#10;    @Query(&quot;SELECT * FROM workout_entries WHERE id = :id&quot;)&#10;    suspend fun getWorkoutEntryById(id: Int): WorkoutEntry?&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(entries: List&lt;WorkoutEntry&gt;)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insert(entry: WorkoutEntry)&#10;&#10;    @Update&#10;    suspend fun update(entry: WorkoutEntry)&#10;&#10;    @Delete&#10;    suspend fun delete(entry: WorkoutEntry)&#10;&#10;    @Query(&quot;DELETE FROM workout_entries WHERE day_id = :dayId&quot;)&#10;    suspend fun deleteByDayId(dayId: Int)&#10;&#10;    @Query(&quot;DELETE FROM workout_entries&quot;)&#10;    suspend fun deleteAll(): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM workout_entries WHERE day_id = :dayId&quot;)&#10;    suspend fun getWorkoutEntryCountForDay(dayId: Int): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM workout_entries&quot;)&#10;    suspend fun getWorkoutEntryCount(): Int&#10;&#10;    @Query(&quot;SELECT * FROM workout_entries WHERE exercise_id = :exerciseId&quot;)&#10;    suspend fun getWorkoutEntriesForExercise(exerciseId: Int): List&lt;WorkoutEntry&gt;&#10;}&#10;&#10;data class WorkoutEntryWithExercise(&#10;    val id: Int,&#10;    val dayId: Int,&#10;    val exerciseId: Int,&#10;    val sets: Int,&#10;    val reps: Int,&#10;    val isCompleted: Boolean,&#10;    val exerciseName: String,&#10;    val isCompound: Boolean,&#10;    val totalSecondsSpent: Int = 0 // Add time tracking field&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.dao&#10;&#10;import androidx.room.*&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface WorkoutEntryDao {&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        SELECT we.id, we.day_id as dayId, we.exercise_id as exerciseId, we.sets, we.reps, we.isCompleted, we.totalSecondsSpent,&#10;               e.name as exerciseName, e.isCompound, we.completedAt&#10;        FROM workout_entries we&#10;        INNER JOIN exercises e ON we.exercise_id = e.id&#10;        WHERE we.day_id = :dayId&#10;        ORDER BY we.id&#10;    &quot;&quot;&quot;)&#10;    fun getWorkoutEntriesForDay(dayId: Int): Flow&lt;List&lt;WorkoutEntryWithExercise&gt;&gt;&#10;&#10;    @Query(&quot;&quot;&quot;&#10;        SELECT we.id, we.day_id as dayId, we.exercise_id as exerciseId, we.sets, we.reps, we.isCompleted, we.totalSecondsSpent,&#10;               e.name as exerciseName, e.isCompound, we.completedAt&#10;        FROM workout_entries we&#10;        INNER JOIN exercises e ON we.exercise_id = e.id&#10;        WHERE we.day_id = :dayId&#10;        ORDER BY we.id&#10;    &quot;&quot;&quot;)&#10;    suspend fun getWorkoutEntriesForDaySync(dayId: Int): List&lt;WorkoutEntryWithExercise&gt;&#10;&#10;    @Query(&quot;SELECT * FROM workout_entries WHERE id = :id&quot;)&#10;    suspend fun getWorkoutEntryById(id: Int): WorkoutEntry?&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(entries: List&lt;WorkoutEntry&gt;)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insert(entry: WorkoutEntry)&#10;&#10;    @Update&#10;    suspend fun update(entry: WorkoutEntry)&#10;&#10;    @Delete&#10;    suspend fun delete(entry: WorkoutEntry)&#10;&#10;    @Query(&quot;DELETE FROM workout_entries WHERE day_id = :dayId&quot;)&#10;    suspend fun deleteByDayId(dayId: Int)&#10;&#10;    @Query(&quot;DELETE FROM workout_entries&quot;)&#10;    suspend fun deleteAll(): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM workout_entries WHERE day_id = :dayId&quot;)&#10;    suspend fun getWorkoutEntryCountForDay(dayId: Int): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM workout_entries&quot;)&#10;    suspend fun getWorkoutEntryCount(): Int&#10;&#10;    @Query(&quot;SELECT * FROM workout_entries WHERE exercise_id = :exerciseId ORDER BY completedAt DESC&quot;)&#10;    suspend fun getWorkoutEntriesForExercise(exerciseId: Int): List&lt;WorkoutEntry&gt;&#10;&#10;    /**&#10;     * Get completed workout entries for a specific exercise within a date range&#10;     * Used specifically for the performance screen&#10;     */&#10;    @Query(&quot;SELECT * FROM workout_entries WHERE exercise_id = :exerciseId AND isCompleted = 1 AND completedAt IS NOT NULL AND completedAt &gt;= :startTime ORDER BY completedAt DESC&quot;)&#10;    suspend fun getCompletedWorkoutEntriesForExercise(exerciseId: Int, startTime: Long): List&lt;WorkoutEntry&gt;&#10;}&#10;&#10;data class WorkoutEntryWithExercise(&#10;    val id: Int,&#10;    val dayId: Int,&#10;    val exerciseId: Int,&#10;    val sets: Int,&#10;    val reps: Int,&#10;    val isCompleted: Boolean,&#10;    val exerciseName: String,&#10;    val isCompound: Boolean,&#10;    val totalSecondsSpent: Int = 0, // Time tracking field&#10;    val completedAt: Long? = null // Adding completedAt timestamp&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/performance/PerformanceRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/performance/PerformanceRepository.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.data.performance&#10;&#10;import android.os.Build&#10;import androidx.annotation.RequiresApi&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import com.example.offlinepplworkoutapp.data.entity.Exercise&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.flow&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;&#10;/**&#10; * Repository for handling performance analytics data for exercises&#10; */&#10;class PerformanceRepository(private val database: PPLWorkoutDatabase) {&#10;&#10;    /**&#10;     * Get performance data for all exercises within the specified time period&#10;     * @param days Number of days to look back (7, 14, or 30)&#10;     * @return Flow of a list of exercise performance data&#10;     */&#10;    @RequiresApi(Build.VERSION_CODES.O)&#10;    fun getAllExercisesPerformance(days: Int): Flow&lt;List&lt;ExercisePerformance&gt;&gt; = flow {&#10;        // Get the current time minus the specified days&#10;        val startTime = LocalDate.now().minusDays(days.toLong())&#10;            .atStartOfDay(ZoneId.systemDefault())&#10;            .toInstant().toEpochMilli()&#10;&#10;        try {&#10;            // Get exercises as a List&lt;Exercise&gt; by collecting the first value from the Flow&#10;            val exercises = database.exerciseDao().getAllExercises().first()&#10;&#10;            // Build performance data for each exercise&#10;            val performanceList = exercises.map { exercise -&gt;&#10;                try {&#10;                    buildExercisePerformance(exercise, startTime)&#10;                } catch (e: Exception) {&#10;                    // If processing a specific exercise fails, return a placeholder with error state&#10;                    // This prevents one bad exercise from breaking the entire performance tab&#10;                    ExercisePerformance(&#10;                        exercise = exercise,&#10;                        progressData = emptyList(),&#10;                        maxWeight = 0f,&#10;                        maxReps = 0,&#10;                        volumeProgress = 0f,&#10;                        weightProgress = 0f,&#10;                        sessionsCount = 0,&#10;                        hasError = true&#10;                    )&#10;                }&#10;            }&#10;&#10;            emit(performanceList)&#10;        } catch (e: Exception) {&#10;            // In case of error, emit an empty list&#10;            emit(emptyList&lt;ExercisePerformance&gt;())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Build performance data for a single exercise&#10;     */&#10;    @RequiresApi(Build.VERSION_CODES.O)&#10;    private suspend fun buildExercisePerformance(&#10;        exercise: Exercise,&#10;        startTime: Long&#10;    ): ExercisePerformance {&#10;        // Find workout entries for this exercise within the time range&#10;        val workoutEntries = getWorkoutEntriesForExercise(exercise.id, startTime)&#10;&#10;        if (workoutEntries.isEmpty()) {&#10;            // No workout data found for this exercise in the given time range&#10;            return ExercisePerformance(&#10;                exercise = exercise,&#10;                progressData = emptyList(),&#10;                maxWeight = 0f,&#10;                maxReps = 0,&#10;                volumeProgress = 0f,&#10;                weightProgress = 0f,&#10;                sessionsCount = 0&#10;            )&#10;        }&#10;&#10;        // Get all set entries for these workout entries&#10;        val setEntries = getAllSetsForWorkoutEntries(workoutEntries)&#10;&#10;        // Calculate performance metrics&#10;        val progressPoints = calculateProgressPoints(setEntries)&#10;        val maxWeight = calculateMaxWeight(setEntries)&#10;        val maxReps = calculateMaxReps(setEntries)&#10;        val volumeProgress = calculateVolumeProgress(setEntries)&#10;        val weightProgress = calculateWeightProgress(setEntries)&#10;&#10;        return ExercisePerformance(&#10;            exercise = exercise,&#10;            progressData = progressPoints,&#10;            maxWeight = maxWeight,&#10;            maxReps = maxReps,&#10;            volumeProgress = volumeProgress,&#10;            weightProgress = weightProgress,&#10;            sessionsCount = workoutEntries.size&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Get workout entries for a specific exercise within a date range&#10;     */&#10;    private suspend fun getWorkoutEntriesForExercise(exerciseId: Int, startTime: Long): List&lt;WorkoutEntry&gt; {&#10;        return database.workoutEntryDao().getWorkoutEntriesForExercise(exerciseId)&#10;            .filter { it.completedAt != null &amp;&amp; it.completedAt &gt;= startTime }&#10;    }&#10;&#10;    /**&#10;     * Get all set entries for a list of workout entries&#10;     */&#10;    private suspend fun getAllSetsForWorkoutEntries(workoutEntries: List&lt;WorkoutEntry&gt;): List&lt;SetEntry&gt; {&#10;        val allSets = mutableListOf&lt;SetEntry&gt;()&#10;&#10;        workoutEntries.forEach { workoutEntry -&gt;&#10;            val sets = database.setEntryDao().getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            allSets.addAll(sets.filter { it.isCompleted })&#10;        }&#10;&#10;        return allSets&#10;    }&#10;&#10;    /**&#10;     * Calculate progress points for graphing&#10;     */&#10;    private fun calculateProgressPoints(setEntries: List&lt;SetEntry&gt;): List&lt;ProgressPoint&gt; {&#10;        // Group sets by date (day)&#10;        val groupedByDate = setEntries&#10;            .filter { it.completedAt != null &amp;&amp; it.repsPerformed &gt; 0 &amp;&amp; it.weightUsed &gt; 0 }&#10;            .groupBy {&#10;                it.completedAt!! / (24 * 60 * 60 * 1000) // Convert timestamp to day&#10;            }&#10;&#10;        // For each day, create a progress point with best performance&#10;        return groupedByDate.map { (_, sets) -&gt;&#10;            // Find the set with the highest volume (weight * reps)&#10;            val bestSet = sets.maxByOrNull { it.weightUsed * it.repsPerformed } ?: sets.first()&#10;&#10;            ProgressPoint(&#10;                date = bestSet.completedAt!!,&#10;                weight = bestSet.weightUsed,&#10;                reps = bestSet.repsPerformed,&#10;                volume = bestSet.weightUsed * bestSet.repsPerformed&#10;            )&#10;        }.sortedBy { it.date }&#10;    }&#10;&#10;    /**&#10;     * Calculate the maximum weight used for the exercise&#10;     */&#10;    private fun calculateMaxWeight(setEntries: List&lt;SetEntry&gt;): Float {&#10;        return setEntries&#10;            .filter { it.isCompleted &amp;&amp; it.repsPerformed &gt; 0 }&#10;            .maxOfOrNull { it.weightUsed } ?: 0f&#10;    }&#10;&#10;    /**&#10;     * Calculate the maximum reps performed for the exercise&#10;     */&#10;    private fun calculateMaxReps(setEntries: List&lt;SetEntry&gt;): Int {&#10;        return setEntries&#10;            .filter { it.isCompleted &amp;&amp; it.weightUsed &gt; 0 }&#10;            .maxOfOrNull { it.repsPerformed } ?: 0&#10;    }&#10;&#10;    /**&#10;     * Calculate volume progress (percentage change)&#10;     * Using improved calculation that better handles varying amounts of data&#10;     */&#10;    private fun calculateVolumeProgress(setEntries: List&lt;SetEntry&gt;): Float {&#10;        // Filter valid entries&#10;        val validEntries = setEntries&#10;            .filter { it.completedAt != null &amp;&amp; it.isCompleted &amp;&amp; it.repsPerformed &gt; 0 &amp;&amp; it.weightUsed &gt; 0 }&#10;            .sortedBy { it.completedAt }&#10;&#10;        // Need at least 2 data points for a trend&#10;        if (validEntries.size &lt; 2) return 0f&#10;&#10;        // Determine sampling approach based on data quantity&#10;        return when {&#10;            // For a small dataset (2-5 points), compare first vs last&#10;            validEntries.size &lt;= 5 -&gt; {&#10;                val firstVolume = validEntries.first().weightUsed * validEntries.first().repsPerformed&#10;                val lastVolume = validEntries.last().weightUsed * validEntries.last().repsPerformed&#10;&#10;                if (firstVolume &gt; 0) {&#10;                    ((lastVolume - firstVolume) / firstVolume * 100)&#10;                } else 0f&#10;            }&#10;&#10;            // For larger datasets, use a more robust approach with averages&#10;            else -&gt; {&#10;                // Use 30% of data points or at least 2 points for the samples&#10;                val sampleSize = (validEntries.size * 0.3).toInt().coerceAtLeast(2)&#10;&#10;                // Calculate average volume at the beginning of the period&#10;                val firstSegment = validEntries.take(sampleSize)&#10;                val firstAvgVolume = firstSegment&#10;                    .map { it.weightUsed * it.repsPerformed }&#10;                    .average()&#10;&#10;                // Calculate average volume at the end of the period&#10;                val lastSegment = validEntries.takeLast(sampleSize)&#10;                val lastAvgVolume = lastSegment&#10;                    .map { it.weightUsed * it.repsPerformed }&#10;                    .average()&#10;&#10;                // Calculate percentage change&#10;                if (firstAvgVolume &gt; 0) {&#10;                    ((lastAvgVolume - firstAvgVolume) / firstAvgVolume * 100).toFloat()&#10;                } else 0f&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate weight progress (percentage change)&#10;     * Using improved calculation that better handles varying amounts of data&#10;     */&#10;    private fun calculateWeightProgress(setEntries: List&lt;SetEntry&gt;): Float {&#10;        // Filter valid entries&#10;        val validEntries = setEntries&#10;            .filter { it.completedAt != null &amp;&amp; it.isCompleted &amp;&amp; it.repsPerformed &gt; 0 &amp;&amp; it.weightUsed &gt; 0 }&#10;            .sortedBy { it.completedAt }&#10;&#10;        // Need at least 2 data points for a trend&#10;        if (validEntries.size &lt; 2) return 0f&#10;&#10;        // Determine sampling approach based on data quantity&#10;        return when {&#10;            // For a small dataset (2-5 points), compare first vs last&#10;            validEntries.size &lt;= 5 -&gt; {&#10;                val firstWeight = validEntries.first().weightUsed&#10;                val lastWeight = validEntries.last().weightUsed&#10;&#10;                if (firstWeight &gt; 0) {&#10;                    ((lastWeight - firstWeight) / firstWeight * 100)&#10;                } else 0f&#10;            }&#10;&#10;            // For larger datasets, use a more robust approach with averages&#10;            else -&gt; {&#10;                // Use 30% of data points or at least 2 points for the samples&#10;                val sampleSize = (validEntries.size * 0.3).toInt().coerceAtLeast(2)&#10;&#10;                // Calculate average weight at the beginning of the period&#10;                val firstSegment = validEntries.take(sampleSize)&#10;                val firstAvgWeight = firstSegment&#10;                    .map { it.weightUsed }&#10;                    .average()&#10;&#10;                // Calculate average weight at the end of the period&#10;                val lastSegment = validEntries.takeLast(sampleSize)&#10;                val lastAvgWeight = lastSegment&#10;                    .map { it.weightUsed }&#10;                    .average()&#10;&#10;                // Calculate percentage change&#10;                if (firstAvgWeight &gt; 0) {&#10;                    ((lastAvgWeight - firstAvgWeight) / firstAvgWeight * 100).toFloat()&#10;                } else 0f&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.performance&#10;&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.annotation.RequiresApi&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import com.example.offlinepplworkoutapp.data.entity.Exercise&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.flow&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;/**&#10; * Repository for handling performance analytics data for exercises&#10; */&#10;class PerformanceRepository(private val database: PPLWorkoutDatabase) {&#10;&#10;    /**&#10;     * Get performance data for all exercises within the specified time period&#10;     * @param days Number of days to look back (7, 14, or 30)&#10;     * @return Flow of a list of exercise performance data&#10;     */&#10;    @RequiresApi(Build.VERSION_CODES.O)&#10;    fun getAllExercisesPerformance(days: Int): Flow&lt;List&lt;ExercisePerformance&gt;&gt; = flow {&#10;        // Calculate the date from days ago, but we want to include the entire current day&#10;        // so we use (days - 1) days ago, which effectively includes today&#10;        val startTime = LocalDate.now().minusDays((days - 1).toLong())&#10;            .atStartOfDay(ZoneId.systemDefault())&#10;            .toInstant().toEpochMilli()&#10;&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.US)&#10;        val startTimeFormatted = dateFormat.format(Date(startTime))&#10;        Log.d(&quot;PerformanceRepo&quot;, &quot; Loading performance data for the last $days days (from $startTimeFormatted)&quot;)&#10;&#10;        try {&#10;            // Get exercises as a List&lt;Exercise&gt; by collecting the first value from the Flow&#10;            val exercises = database.exerciseDao().getAllExercises().first()&#10;            Log.d(&quot;PerformanceRepo&quot;, &quot; Found ${exercises.size} exercises in database&quot;)&#10;&#10;            // Build performance data for each exercise&#10;            val performanceList = exercises.map { exercise -&gt;&#10;                try {&#10;                    Log.d(&quot;PerformanceRepo&quot;, &quot; Building performance for exercise: ${exercise.id} - ${exercise.name}&quot;)&#10;                    val performance = buildExercisePerformance(exercise, startTime)&#10;                    Log.d(&quot;PerformanceRepo&quot;, &quot;✅ Performance for ${exercise.name}: &quot; +&#10;                            &quot;MaxWeight=${performance.maxWeight}kg, &quot; +&#10;                            &quot;MaxReps=${performance.maxReps}, &quot; +&#10;                            &quot;Sessions=${performance.sessionsCount}, &quot; +&#10;                            &quot;DataPoints=${performance.progressData.size}&quot;&#10;                    )&#10;                    performance&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;PerformanceRepo&quot;, &quot;❌ Error building performance for ${exercise.name}: ${e.message}&quot;)&#10;                    // If processing a specific exercise fails, return a placeholder with error state&#10;                    // This prevents one bad exercise from breaking the entire performance tab&#10;                    ExercisePerformance(&#10;                        exercise = exercise,&#10;                        progressData = emptyList(),&#10;                        maxWeight = 0f,&#10;                        maxReps = 0,&#10;                        volumeProgress = 0f,&#10;                        weightProgress = 0f,&#10;                        sessionsCount = 0,&#10;                        hasError = true&#10;                    )&#10;                }&#10;            }&#10;&#10;            emit(performanceList)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;PerformanceRepo&quot;, &quot;�� Error loading exercise performance: ${e.message}&quot;)&#10;            // In case of error, emit an empty list&#10;            emit(emptyList&lt;ExercisePerformance&gt;())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Build performance data for a single exercise&#10;     */&#10;    @RequiresApi(Build.VERSION_CODES.O)&#10;    private suspend fun buildExercisePerformance(&#10;        exercise: Exercise,&#10;        startTime: Long&#10;    ): ExercisePerformance {&#10;        // Find workout entries for this exercise within the time range&#10;        val workoutEntries = getWorkoutEntriesForExercise(exercise.id, startTime)&#10;&#10;        if (workoutEntries.isEmpty()) {&#10;            // No workout data found for this exercise in the given time range&#10;            return ExercisePerformance(&#10;                exercise = exercise,&#10;                progressData = emptyList(),&#10;                maxWeight = 0f,&#10;                maxReps = 0,&#10;                volumeProgress = 0f,&#10;                weightProgress = 0f,&#10;                sessionsCount = 0&#10;            )&#10;        }&#10;&#10;        // Get all set entries for these workout entries&#10;        val setEntries = getAllSetsForWorkoutEntries(workoutEntries)&#10;&#10;        // Calculate performance metrics&#10;        val progressPoints = calculateProgressPoints(setEntries)&#10;        val maxWeight = calculateMaxWeight(setEntries)&#10;        val maxReps = calculateMaxReps(setEntries)&#10;        val volumeProgress = calculateVolumeProgress(setEntries)&#10;        val weightProgress = calculateWeightProgress(setEntries)&#10;&#10;        return ExercisePerformance(&#10;            exercise = exercise,&#10;            progressData = progressPoints,&#10;            maxWeight = maxWeight,&#10;            maxReps = maxReps,&#10;            volumeProgress = volumeProgress,&#10;            weightProgress = weightProgress,&#10;            sessionsCount = workoutEntries.size&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Get workout entries for a specific exercise within a date range&#10;     */&#10;    private suspend fun getWorkoutEntriesForExercise(exerciseId: Int, startTime: Long): List&lt;WorkoutEntry&gt; {&#10;        // Use the new specialized query for performance data that only gets completed workouts&#10;        val filteredEntries = database.workoutEntryDao().getCompletedWorkoutEntriesForExercise(exerciseId, startTime)&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.US)&#10;        &#10;        Log.d(&quot;PerformanceRepo&quot;, &quot; Fetching completed workout entries for exercise ID: $exerciseId from ${dateFormat.format(Date(startTime))}&quot;)&#10;        Log.d(&quot;PerformanceRepo&quot;, &quot; Found ${filteredEntries.size} completed entries&quot;)&#10;        &#10;        filteredEntries.forEach { entry -&gt;&#10;            entry.completedAt?.let { timestamp -&gt;&#10;                Log.d(&quot;PerformanceRepo&quot;, &quot; Completed workout entry: ID=${entry.id}, &quot; +&#10;                        &quot;ExerciseID=${entry.exerciseId}, &quot; +&#10;                        &quot;CompletedAt=${dateFormat.format(Date(timestamp))}&quot;)&#10;            }&#10;        }&#10;        &#10;        return filteredEntries&#10;    }&#10;&#10;    /**&#10;     * Get all set entries for a list of workout entries&#10;     */&#10;    private suspend fun getAllSetsForWorkoutEntries(workoutEntries: List&lt;WorkoutEntry&gt;): List&lt;SetEntry&gt; {&#10;        val allSets = mutableListOf&lt;SetEntry&gt;()&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.US)&#10;&#10;        workoutEntries.forEach { workoutEntry -&gt;&#10;            val sets = database.setEntryDao().getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            Log.d(&quot;PerformanceRepo&quot;, &quot; Found ${sets.size} sets for workout entry ID: ${workoutEntry.id}&quot;)&#10;&#10;            val completedSets = sets.filter { it.isCompleted }&#10;            Log.d(&quot;PerformanceRepo&quot;, &quot; Completed sets: ${completedSets.size} out of ${sets.size}&quot;)&#10;&#10;            completedSets.forEach { set -&gt;&#10;                Log.d(&quot;PerformanceRepo&quot;, &quot; Set: ID=${set.id}, &quot; +&#10;                        &quot;Weight=${set.weightUsed}kg, &quot; +&#10;                        &quot;Reps=${set.repsPerformed}, &quot; +&#10;                        &quot;CompletedAt=${set.completedAt?.let { dateFormat.format(Date(it)) } ?: &quot;null&quot;}&quot;)&#10;            }&#10;&#10;            allSets.addAll(completedSets)&#10;        }&#10;&#10;        return allSets&#10;    }&#10;&#10;    /**&#10;     * Calculate progress points for graphing&#10;     */&#10;    private fun calculateProgressPoints(setEntries: List&lt;SetEntry&gt;): List&lt;ProgressPoint&gt; {&#10;        // Group sets by date (day)&#10;        val groupedByDate = setEntries&#10;            .filter { it.completedAt != null &amp;&amp; it.repsPerformed &gt; 0 &amp;&amp; it.weightUsed &gt; 0 }&#10;            .groupBy {&#10;                it.completedAt!! / (24 * 60 * 60 * 1000) // Convert timestamp to day&#10;            }&#10;&#10;        // For each day, create a progress point with best performance&#10;        return groupedByDate.map { (_, sets) -&gt;&#10;            // Find the set with the highest volume (weight * reps)&#10;            val bestSet = sets.maxByOrNull { it.weightUsed * it.repsPerformed } ?: sets.first()&#10;&#10;            ProgressPoint(&#10;                date = bestSet.completedAt!!,&#10;                weight = bestSet.weightUsed,&#10;                reps = bestSet.repsPerformed,&#10;                volume = bestSet.weightUsed * bestSet.repsPerformed&#10;            )&#10;        }.sortedBy { it.date }&#10;    }&#10;&#10;    /**&#10;     * Calculate the maximum weight used for the exercise&#10;     */&#10;    private fun calculateMaxWeight(setEntries: List&lt;SetEntry&gt;): Float {&#10;        return setEntries&#10;            .filter { it.isCompleted &amp;&amp; it.repsPerformed &gt; 0 }&#10;            .maxOfOrNull { it.weightUsed } ?: 0f&#10;    }&#10;&#10;    /**&#10;     * Calculate the maximum reps performed for the exercise&#10;     */&#10;    private fun calculateMaxReps(setEntries: List&lt;SetEntry&gt;): Int {&#10;        return setEntries&#10;            .filter { it.isCompleted &amp;&amp; it.weightUsed &gt; 0 }&#10;            .maxOfOrNull { it.repsPerformed } ?: 0&#10;    }&#10;&#10;    /**&#10;     * Calculate volume progress (percentage change)&#10;     * Using improved calculation that better handles varying amounts of data&#10;     */&#10;    private fun calculateVolumeProgress(setEntries: List&lt;SetEntry&gt;): Float {&#10;        // Filter valid entries&#10;        val validEntries = setEntries&#10;            .filter { it.completedAt != null &amp;&amp; it.isCompleted &amp;&amp; it.repsPerformed &gt; 0 &amp;&amp; it.weightUsed &gt; 0 }&#10;            .sortedBy { it.completedAt }&#10;&#10;        // Need at least 2 data points for a trend&#10;        if (validEntries.size &lt; 2) return 0f&#10;&#10;        // Determine sampling approach based on data quantity&#10;        return when {&#10;            // For a small dataset (2-5 points), compare first vs last&#10;            validEntries.size &lt;= 5 -&gt; {&#10;                val firstVolume = validEntries.first().weightUsed * validEntries.first().repsPerformed&#10;                val lastVolume = validEntries.last().weightUsed * validEntries.last().repsPerformed&#10;&#10;                if (firstVolume &gt; 0) {&#10;                    ((lastVolume - firstVolume) / firstVolume * 100)&#10;                } else 0f&#10;            }&#10;&#10;            // For larger datasets, use a more robust approach with averages&#10;            else -&gt; {&#10;                // Use 30% of data points or at least 2 points for the samples&#10;                val sampleSize = (validEntries.size * 0.3).toInt().coerceAtLeast(2)&#10;&#10;                // Calculate average volume at the beginning of the period&#10;                val firstSegment = validEntries.take(sampleSize)&#10;                val firstAvgVolume = firstSegment&#10;                    .map { it.weightUsed * it.repsPerformed }&#10;                    .average()&#10;&#10;                // Calculate average volume at the end of the period&#10;                val lastSegment = validEntries.takeLast(sampleSize)&#10;                val lastAvgVolume = lastSegment&#10;                    .map { it.weightUsed * it.repsPerformed }&#10;                    .average()&#10;&#10;                // Calculate percentage change&#10;                if (firstAvgVolume &gt; 0) {&#10;                    ((lastAvgVolume - firstAvgVolume) / firstAvgVolume * 100).toFloat()&#10;                } else 0f&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate weight progress (percentage change)&#10;     * Using improved calculation that better handles varying amounts of data&#10;     */&#10;    private fun calculateWeightProgress(setEntries: List&lt;SetEntry&gt;): Float {&#10;        // Filter valid entries&#10;        val validEntries = setEntries&#10;            .filter { it.completedAt != null &amp;&amp; it.isCompleted &amp;&amp; it.repsPerformed &gt; 0 &amp;&amp; it.weightUsed &gt; 0 }&#10;            .sortedBy { it.completedAt }&#10;&#10;        // Need at least 2 data points for a trend&#10;        if (validEntries.size &lt; 2) return 0f&#10;&#10;        // Determine sampling approach based on data quantity&#10;        return when {&#10;            // For a small dataset (2-5 points), compare first vs last&#10;            validEntries.size &lt;= 5 -&gt; {&#10;                val firstWeight = validEntries.first().weightUsed&#10;                val lastWeight = validEntries.last().weightUsed&#10;&#10;                if (firstWeight &gt; 0) {&#10;                    ((lastWeight - firstWeight) / firstWeight * 100)&#10;                } else 0f&#10;            }&#10;&#10;            // For larger datasets, use a more robust approach with averages&#10;            else -&gt; {&#10;                // Use 30% of data points or at least 2 points for the samples&#10;                val sampleSize = (validEntries.size * 0.3).toInt().coerceAtLeast(2)&#10;&#10;                // Calculate average weight at the beginning of the period&#10;                val firstSegment = validEntries.take(sampleSize)&#10;                val firstAvgWeight = firstSegment&#10;                    .map { it.weightUsed }&#10;                    .average()&#10;&#10;                // Calculate average weight at the end of the period&#10;                val lastSegment = validEntries.takeLast(sampleSize)&#10;                val lastAvgWeight = lastSegment&#10;                    .map { it.weightUsed }&#10;                    .average()&#10;&#10;                // Calculate percentage change&#10;                if (firstAvgWeight &gt; 0) {&#10;                    ((lastAvgWeight - firstAvgWeight) / firstAvgWeight * 100).toFloat()&#10;                } else 0f&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/repository/WorkoutRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/repository/WorkoutRepository.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.data.repository&#10;&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutDayDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.SetEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutTemplateDao&#10;import com.example.offlinepplworkoutapp.data.dao.TemplateExerciseDao&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutDay&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import kotlinx.coroutines.flow.Flow&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class WorkoutRepository(&#10;    private val workoutDayDao: WorkoutDayDao,&#10;    private val workoutEntryDao: WorkoutEntryDao,&#10;    private val setEntryDao: SetEntryDao,&#10;    private val workoutTemplateDao: WorkoutTemplateDao,&#10;    private val templateExerciseDao: TemplateExerciseDao&#10;) {&#10;&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;&#10;    // ===========================================&#10;    // TEMPLATE-BASED WORKOUT CREATION (NEW)&#10;    // ===========================================&#10;&#10;    /**&#10;     * Create workout from template - Main template-based workout creation method&#10;     * This replaces the hardcoded day-based logic with flexible template system&#10;     */&#10;    suspend fun createWorkoutFromTemplate(templateId: Int, date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        println(&quot; REPO: Creating workout from template $templateId for date: $date&quot;)&#10;&#10;        // Get or create workout day&#10;        val workoutDay = getOrCreateWorkoutDayOnly(date)&#10;&#10;        // Check if this day already has exercises&#10;        val existingEntries = workoutEntryDao.getWorkoutEntriesForDaySync(workoutDay.id)&#10;        if (existingEntries.isNotEmpty()) {&#10;            println(&quot; REPO: Found existing workout day with ${existingEntries.size} exercises&quot;)&#10;            return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        }&#10;&#10;        // Get template exercises&#10;        val templateExercises = templateExerciseDao.getExercisesForTemplate(templateId)&#10;        println(&quot; REPO: Got ${templateExercises.size} exercises for template $templateId&quot;)&#10;&#10;        if (templateExercises.isNotEmpty()) {&#10;            // Create workout entries from template&#10;            val entries = templateExercises.map { templateExercise -&gt;&#10;                WorkoutEntry(&#10;                    dayId = workoutDay.id,&#10;                    exerciseId = templateExercise.exerciseId,&#10;                    sets = templateExercise.sets,&#10;                    reps = templateExercise.reps&#10;                )&#10;            }&#10;&#10;            workoutEntryDao.insertAll(entries)&#10;            println(&quot; REPO: Inserted ${entries.size} workout entries from template&quot;)&#10;&#10;            // Create sets for each workout entry&#10;            val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(workoutDay.id)&#10;            createSetsForEntries(insertedEntries)&#10;&#10;            // Update template last used date&#10;            workoutTemplateDao.updateLastUsedDate(templateId, date)&#10;        }&#10;&#10;        return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;    }&#10;&#10;    /**&#10;     * Get available templates for user selection&#10;     */&#10;    fun getAvailableTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt; {&#10;        return workoutTemplateDao.getAllActiveTemplates()&#10;    }&#10;&#10;    // ===========================================&#10;    // LEGACY DAY-BASED METHODS (PRESERVED)&#10;    // ===========================================&#10;&#10;    private suspend fun createWorkoutDayWithExercises(date: String): WorkoutDay {&#10;        // Create workout day&#10;        val workoutDay = WorkoutDay(date = date)&#10;        val dayId = workoutDayDao.insert(workoutDay).toInt()&#10;        val createdDay = workoutDay.copy(id = dayId)&#10;&#10;        // Determine workout type based on date&#10;        val workoutType = getWorkoutTypeForDate(date)&#10;        val exercises = getExercisesForWorkoutType(workoutType)&#10;&#10;        // Debug logging to see what's happening&#10;        println(&quot;DEBUG: Creating workout for date: $date, type: $workoutType, exercises count: ${exercises.size}&quot;)&#10;&#10;        // Only create entries if we have exercises for this workout type&#10;        if (exercises.isNotEmpty()) {&#10;            // Create workout entries&#10;            val entries = exercises.map { (exerciseId, sets, reps) -&gt;&#10;                WorkoutEntry(&#10;                    dayId = dayId,&#10;                    exerciseId = exerciseId,&#10;                    sets = sets,&#10;                    reps = reps&#10;                )&#10;            }&#10;&#10;            workoutEntryDao.insertAll(entries)&#10;            println(&quot;DEBUG: Inserted ${entries.size} workout entries for day $date&quot;)&#10;&#10;            //  FIX: Create sets for each workout entry immediately&#10;            // Since we just inserted the entries, we can use the entries we created&#10;            // and get their IDs after insertion&#10;            val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(dayId)&#10;            println(&quot; REPO: Retrieved ${insertedEntries.size} inserted entries to create sets&quot;)&#10;&#10;            for (entry in insertedEntries) {&#10;                println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;                // Create individual sets for each exercise&#10;                createSetsForWorkoutEntry(entry.id, entry.sets)&#10;                println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;                // Verify sets were created&#10;                val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;                println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;                createdSets.forEach { set -&gt;&#10;                    println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;                }&#10;            }&#10;&#10;            println(&quot; REPO: All sets created for ${insertedEntries.size} exercises&quot;)&#10;        } else {&#10;            println(&quot;DEBUG: No exercises found for workout type: $workoutType on date: $date&quot;)&#10;        }&#10;&#10;        return createdDay&#10;    }&#10;&#10;    private fun getWorkoutTypeForDate(date: String): WorkoutType {&#10;        val calendar = Calendar.getInstance()&#10;        calendar.time = dateFormat.parse(date) ?: Date()&#10;        val dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) // Sunday = 1, Saturday = 7&#10;&#10;        return when (dayOfWeek) {&#10;            Calendar.MONDAY -&gt; WorkoutType.PUSH_1&#10;            Calendar.TUESDAY -&gt; WorkoutType.PULL_1&#10;            Calendar.WEDNESDAY -&gt; WorkoutType.LEGS_1&#10;            Calendar.THURSDAY -&gt; WorkoutType.PUSH_2&#10;            Calendar.FRIDAY -&gt; WorkoutType.PULL_2&#10;            Calendar.SATURDAY -&gt; WorkoutType.LEGS_2&#10;            Calendar.SUNDAY -&gt; WorkoutType.REST&#10;            else -&gt; WorkoutType.REST&#10;        }&#10;    }&#10;&#10;    private fun getExercisesForWorkoutType(workoutType: WorkoutType): List&lt;Triple&lt;Int, Int, Int&gt;&gt; {&#10;        return when (workoutType) {&#10;            WorkoutType.PUSH_1 -&gt; listOf(&#10;                Triple(1, 4, 8),   // Barbell Bench Press - 4x6-8 reps&#10;                Triple(2, 3, 10),  // Standing Overhead Press - 3x8-10 reps&#10;                Triple(3, 3, 12),  // Incline Dumbbell Press - 3x8-12 reps&#10;                Triple(4, 3, 15),  // Dumbbell Lateral Raise - 3x12-15 reps&#10;                Triple(5, 3, 12)   // Cable Triceps Pushdown - 3x10-12 reps&#10;            )&#10;            WorkoutType.PULL_1 -&gt; listOf(&#10;                Triple(6, 3, 8),   // Deadlift - 3x5-8 reps&#10;                Triple(7, 3, 10),  // Pull-Ups or Lat Pulldowns - 3x8-10 reps&#10;                Triple(8, 3, 12),  // Bent-Over Barbell Row - 3x8-12 reps&#10;                Triple(9, 3, 15),  // Face Pull - 3x12-15 reps&#10;                Triple(10, 3, 12), // Barbell Biceps Curl - 3x8-12 reps&#10;                Triple(11, 2, 12)  // Hammer Curl - 2x10-12 reps&#10;            )&#10;            WorkoutType.LEGS_1 -&gt; listOf(&#10;                Triple(12, 4, 8),  // Back Squat - 4x6-8 reps&#10;                Triple(13, 3, 12), // Romanian Deadlift - 3x8-12 reps&#10;                Triple(14, 3, 12), // Leg Press - 3x10-12 reps&#10;                Triple(15, 3, 12), // Lying Leg Curl - 3x10-12 reps&#10;                Triple(16, 4, 15)  // Seated Calf Raise - 4x12-15 reps&#10;            )&#10;            WorkoutType.PUSH_2 -&gt; listOf(&#10;                Triple(17, 4, 8),  // Standing Overhead Press - 4x6-8 reps&#10;                Triple(18, 3, 12), // Incline Barbell Press - 3x8-12 reps&#10;                Triple(19, 3, 10), // Weighted Dips - 3x8-10 reps&#10;                Triple(20, 3, 15), // Cable Lateral Raise - 3x12-15 reps&#10;                Triple(21, 3, 15), // Pec Deck or Dumbbell Fly - 3x12-15 reps&#10;                Triple(22, 3, 12)  // Overhead Cable Triceps Extension - 3x10-12 reps&#10;            )&#10;            WorkoutType.PULL_2 -&gt; listOf(&#10;                Triple(23, 4, 10), // Pendlay or Bent-Over Row - 4x6-10 reps&#10;                Triple(24, 3, 12), // Weighted Pull-Ups or Wide-Grip Lat Pulldown - 3x8-12 reps&#10;                Triple(25, 3, 12), // Dumbbell Shrug - 3x10-12 reps&#10;                Triple(26, 3, 15), // Face Pull - 3x12-15 reps&#10;                Triple(27, 3, 12), // EZ-Bar Biceps Curl - 3x8-12 reps&#10;                Triple(28, 2, 12)  // Reverse Grip or Preacher Curl - 2x10-12 reps&#10;            )&#10;            WorkoutType.LEGS_2 -&gt; listOf(&#10;                Triple(29, 4, 8),  // Front Squat - 4x6-8 reps&#10;                Triple(30, 3, 10), // Bulgarian Split Squat - 3x8-10 reps (each leg)&#10;                Triple(31, 3, 12), // Barbell Hip Thrust - 3x10-12 reps&#10;                Triple(32, 3, 15), // Leg Extension - 3x12-15 reps&#10;                Triple(33, 3, 15), // Seated or Lying Leg Curl - 3x12-15 reps&#10;                Triple(34, 4, 15)  // Standing Calf Raise - 4x12-15 reps&#10;            )&#10;            WorkoutType.REST -&gt; emptyList()&#10;        }&#10;    }&#10;&#10;    suspend fun toggleExerciseCompletion(entryId: Int) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            val updatedEntry = it.copy(isCompleted = !it.isCompleted)&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun markExerciseComplete(entryId: Int, isCompleted: Boolean) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            // Set completedAt timestamp if the exercise is being marked as completed&#10;            val completedTimestamp = if (isCompleted &amp;&amp; !it.isCompleted) {&#10;                System.currentTimeMillis() // Current time in milliseconds&#10;            } else if (!isCompleted) {&#10;                null // If marking as incomplete, clear the timestamp&#10;            } else {&#10;                it.completedAt // Keep existing timestamp&#10;            }&#10;&#10;            val updatedEntry = it.copy(&#10;                isCompleted = isCompleted,&#10;                completedAt = completedTimestamp&#10;            )&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun updateExerciseDetails(entryId: Int, sets: Int, reps: Int, isCompleted: Boolean) {&#10;        println(&quot;️ REPO: Updating exercise details - entryId: $entryId, sets: $sets, reps: $reps, isCompleted: $isCompleted&quot;)&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            println(&quot;️ REPO: Found entry - id: ${it.id}, exerciseId: ${it.exerciseId}, current isCompleted: ${it.isCompleted}&quot;)&#10;&#10;            // Set completedAt timestamp if the exercise is being marked as completed&#10;            val completedTimestamp = if (isCompleted &amp;&amp; !it.isCompleted) {&#10;                System.currentTimeMillis() // Current time in milliseconds&#10;            } else {&#10;                it.completedAt // Keep existing timestamp or null&#10;            }&#10;&#10;            val updatedEntry = it.copy(&#10;                sets = sets,&#10;                reps = reps,&#10;                isCompleted = isCompleted,&#10;                completedAt = completedTimestamp&#10;            )&#10;&#10;            workoutEntryDao.update(updatedEntry)&#10;            println(&quot;️ REPO: Updated entry - id: ${updatedEntry.id}, new isCompleted: ${updatedEntry.isCompleted}, completedAt: ${updatedEntry.completedAt}&quot;)&#10;        } ?: run {&#10;            println(&quot;️ REPO ERROR: No entry found for entryId: $entryId&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun updateExerciseTime(entryId: Int, totalSecondsSpent: Int) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            val updatedEntry = it.copy(totalSecondsSpent = totalSecondsSpent)&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    // New methods for set-based operations&#10;    fun getSetsForWorkoutEntry(workoutEntryId: Int): Flow&lt;List&lt;SetEntry&gt;&gt; {&#10;        return setEntryDao.getSetsForWorkoutEntry(workoutEntryId)&#10;    }&#10;&#10;    suspend fun getSetsForWorkoutEntrySync(workoutEntryId: Int): List&lt;SetEntry&gt; {&#10;        return setEntryDao.getSetsForWorkoutEntrySync(workoutEntryId)&#10;    }&#10;&#10;    suspend fun getCompletedSetsCount(workoutEntryId: Int): Int {&#10;        return setEntryDao.getCompletedSetsCount(workoutEntryId)&#10;    }&#10;&#10;    //  NEW: Phase 2.1.1 - Methods for handling set performance data&#10;    suspend fun updateSetProgressWithPerformanceData(&#10;        setId: Int,&#10;        isCompleted: Boolean,&#10;        elapsedTimeSeconds: Int,&#10;        repsPerformed: Int,&#10;        weightUsed: Float&#10;    ) {&#10;        val completedAt = if (isCompleted) System.currentTimeMillis() else null&#10;        setEntryDao.updateSetProgressWithPerformanceData(&#10;            setId = setId,&#10;            isCompleted = isCompleted,&#10;            elapsedTimeSeconds = elapsedTimeSeconds,&#10;            completedAt = completedAt,&#10;            repsPerformed = repsPerformed,&#10;            weightUsed = weightUsed&#10;        )&#10;        println(&quot;️ REPO: Updated set $setId with performance data - reps: $repsPerformed, weight: $weightUsed&quot;)&#10;    }&#10;&#10;    //  NEW: 2.2.1 - Get set data by index for editing functionality&#10;    fun getSetByIndex(workoutEntryId: Int, setNumber: Int): Flow&lt;SetEntry?&gt; {&#10;        return setEntryDao.getSetByWorkoutEntryAndSetNumber(workoutEntryId, setNumber)&#10;    }&#10;&#10;    //  NEW: 2.2.2 - Dynamic Set Management Methods&#10;    suspend fun addSetToWorkoutEntry(workoutEntryId: Int, setNumber: Int) {&#10;        println(&quot; REPO: Adding set #$setNumber to WorkoutEntry ID=$workoutEntryId&quot;)&#10;&#10;        // Note: targetReps is just for logging - we don't store it in the SetEntry&#10;        // The target reps come from the parent WorkoutEntry's reps field&#10;        val newSet = SetEntry(&#10;            workoutEntryId = workoutEntryId,&#10;            setNumber = setNumber,&#10;            isCompleted = false,&#10;            elapsedTimeSeconds = 0,&#10;            repsPerformed = 0,  // Set to 0 as no reps have been performed yet&#10;            weightUsed = 0f&#10;        )&#10;&#10;        val setId = setEntryDao.insertSet(newSet)&#10;        println(&quot; REPO: Successfully added set with ID=$setId&quot;)&#10;    }&#10;&#10;    suspend fun removeSetFromWorkoutEntry(setId: Int) {&#10;        println(&quot; REPO: Removing set with ID=$setId&quot;)&#10;        setEntryDao.deleteSetById(setId)&#10;        println(&quot; REPO: Successfully removed set&quot;)&#10;    }&#10;&#10;    suspend fun createSetsForWorkoutEntry(workoutEntryId: Int, totalSets: Int) {&#10;        val sets = (1..totalSets).map { setNumber -&gt;&#10;            SetEntry(&#10;                workoutEntryId = workoutEntryId,&#10;                setNumber = setNumber&#10;            )&#10;        }&#10;        setEntryDao.insertAll(sets)&#10;    }&#10;&#10;    // Update exercise completion based on set completion&#10;    suspend fun updateExerciseCompletionFromSets(workoutEntryId: Int) {&#10;        val completedSets = setEntryDao.getCompletedSetsCount(workoutEntryId)&#10;        val totalSets = setEntryDao.getTotalSetsCount(workoutEntryId)&#10;&#10;        if (completedSets == totalSets &amp;&amp; totalSets &gt; 0) {&#10;            // Mark exercise as completed&#10;            val workoutEntry = workoutEntryDao.getWorkoutEntryById(workoutEntryId)&#10;            workoutEntry?.let {&#10;                workoutEntryDao.update(it.copy(isCompleted = true))&#10;            }&#10;        }&#10;    }&#10;&#10;    // New method that doesn't auto-create workout data&#10;    suspend fun getTodaysWorkoutWithoutCreating(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        val workoutDay = workoutDayDao.getWorkoutDayByDate(today)&#10;        return if (workoutDay != null) {&#10;            workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        } else {&#10;            kotlinx.coroutines.flow.flowOf(emptyList()) // Return empty list if no workout day exists&#10;        }&#10;    }&#10;&#10;    suspend fun getWorkoutForDateWithoutCreating(date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val workoutDay = workoutDayDao.getWorkoutDayByDate(date)&#10;        return if (workoutDay != null) {&#10;            workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        } else {&#10;            kotlinx.coroutines.flow.flowOf(emptyList()) // Return empty list if no workout day exists&#10;        }&#10;    }&#10;&#10;    //  NEW: Create workout for any specific date (supports debug mode)&#10;    suspend fun createWorkoutForDate(date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        println(&quot; REPO: Creating workout for date: $date&quot;)&#10;&#10;        // First, ensure exercises exist in the database&#10;        workoutEntryDao.getWorkoutEntryCount() // This will check if ANY entries exist&#10;        println(&quot; REPO: Checking if exercises are populated in database...&quot;)&#10;&#10;        // Check if workout day already exists&#10;        val existingWorkoutDay = workoutDayDao.getWorkoutDayByDate(date)&#10;&#10;        if (existingWorkoutDay != null) {&#10;            println(&quot; REPO: Found existing workout day with ID: ${existingWorkoutDay.id}&quot;)&#10;&#10;            // Check if it has exercises using count method&#10;            val existingEntriesCount = workoutEntryDao.getWorkoutEntryCountForDay(existingWorkoutDay.id)&#10;            println(&quot; REPO: Existing day has $existingEntriesCount exercises&quot;)&#10;&#10;            if (existingEntriesCount == 0) {&#10;                println(&quot; REPO: No exercises found, creating them now...&quot;)&#10;                // Day exists but has no exercises, create them&#10;                val workoutType = getWorkoutTypeForDate(date)&#10;                val exercises = getExercisesForWorkoutType(workoutType)&#10;                println(&quot; REPO: Got ${exercises.size} exercises for workout type: $workoutType&quot;)&#10;&#10;                if (exercises.isNotEmpty()) {&#10;                    try {&#10;                        val entries = exercises.map { (exerciseId, sets, reps) -&gt;&#10;                            WorkoutEntry(&#10;                                dayId = existingWorkoutDay.id,&#10;                                exerciseId = exerciseId,&#10;                                sets = sets,&#10;                                reps = reps&#10;                            )&#10;                        }&#10;                        workoutEntryDao.insertAll(entries)&#10;                        println(&quot; REPO: Inserted ${entries.size} workout entries&quot;)&#10;&#10;                        //  FIX: Create sets for each workout entry immediately&#10;                        val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(existingWorkoutDay.id)&#10;                        println(&quot; REPO: Retrieved ${insertedEntries.size} inserted entries to create sets&quot;)&#10;&#10;                        for (entry in insertedEntries) {&#10;                            println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;                            // Create individual sets for each exercise&#10;                            createSetsForWorkoutEntry(entry.id, entry.sets)&#10;                            println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;                            // Verify sets were created&#10;                            val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;                            println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;                            createdSets.forEach { set -&gt;&#10;                                println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;                            }&#10;                        }&#10;&#10;                        println(&quot; REPO: All sets created for ${insertedEntries.size} exercises&quot;)&#10;                      } catch (e: Exception) {&#10;                        println(&quot; REPO ERROR: Failed to insert workout entries - ${e.message}&quot;)&#10;                        // If foreign key constraint fails, we need to populate exercises first&#10;                        if (e.message?.contains(&quot;FOREIGN KEY constraint failed&quot;) == true) {&#10;                            println(&quot; REPO: Exercise data missing, need to populate exercises first&quot;)&#10;                            throw e // Re-throw to be caught by ViewModel&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            println(&quot; REPO: No existing workout day, creating new one...&quot;)&#10;            // Force create the workout day and exercises&#10;            val workoutDay = createWorkoutDayWithExercises(date)&#10;            println(&quot; REPO: Created new workout day with ID: ${workoutDay.id}&quot;)&#10;        }&#10;&#10;        // Get the final workout day (either existing or newly created)&#10;        val finalWorkoutDay = workoutDayDao.getWorkoutDayByDate(date)!!&#10;        println(&quot; REPO: Final workout day ID: ${finalWorkoutDay.id}&quot;)&#10;&#10;        // Return the flow of workout entries&#10;        return workoutEntryDao.getWorkoutEntriesForDay(finalWorkoutDay.id)&#10;    }&#10;&#10;    // ===========================================&#10;    // HELPER METHODS&#10;    // ===========================================&#10;&#10;    /**&#10;     * Create workout day only (without exercises) - used by template system&#10;     */&#10;    private suspend fun getOrCreateWorkoutDayOnly(date: String): WorkoutDay {&#10;        return workoutDayDao.getWorkoutDayByDate(date) ?: run {&#10;            val workoutDay = WorkoutDay(date = date)&#10;            val dayId = workoutDayDao.insert(workoutDay).toInt()&#10;            workoutDay.copy(id = dayId)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create sets for multiple workout entries - used by template system&#10;     */&#10;    private suspend fun createSetsForEntries(entries: List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;) {&#10;        for (entry in entries) {&#10;            println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;            createSetsForWorkoutEntry(entry.id, entry.sets)&#10;            println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;            // Verify sets were created&#10;            val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;            println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;            createdSets.forEach { set -&gt;&#10;                println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;            }&#10;        }&#10;        println(&quot; REPO: All sets created for ${entries.size} exercises&quot;)&#10;    }&#10;}&#10;&#10;enum class WorkoutType {&#10;    PUSH_1, PULL_1, LEGS_1, PUSH_2, PULL_2, LEGS_2, REST&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.repository&#10;&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutDayDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.SetEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutTemplateDao&#10;import com.example.offlinepplworkoutapp.data.dao.TemplateExerciseDao&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutDay&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import kotlinx.coroutines.flow.Flow&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class WorkoutRepository(&#10;    private val workoutDayDao: WorkoutDayDao,&#10;    private val workoutEntryDao: WorkoutEntryDao,&#10;    private val setEntryDao: SetEntryDao,&#10;    private val workoutTemplateDao: WorkoutTemplateDao,&#10;    private val templateExerciseDao: TemplateExerciseDao&#10;) {&#10;&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;&#10;    // ===========================================&#10;    // TEMPLATE-BASED WORKOUT CREATION (NEW)&#10;    // ===========================================&#10;&#10;    /**&#10;     * Create workout from template - Main template-based workout creation method&#10;     * This replaces the hardcoded day-based logic with flexible template system&#10;     */&#10;    suspend fun createWorkoutFromTemplate(templateId: Int, date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        println(&quot; REPO: Creating workout from template $templateId for date: $date&quot;)&#10;&#10;        // Get or create workout day&#10;        val workoutDay = getOrCreateWorkoutDayOnly(date)&#10;&#10;        // Check if this day already has exercises&#10;        val existingEntries = workoutEntryDao.getWorkoutEntriesForDaySync(workoutDay.id)&#10;        if (existingEntries.isNotEmpty()) {&#10;            println(&quot; REPO: Found existing workout day with ${existingEntries.size} exercises&quot;)&#10;            return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        }&#10;&#10;        // Get template exercises&#10;        val templateExercises = templateExerciseDao.getExercisesForTemplate(templateId)&#10;        println(&quot; REPO: Got ${templateExercises.size} exercises for template $templateId&quot;)&#10;&#10;        if (templateExercises.isNotEmpty()) {&#10;            // Create workout entries from template&#10;            val entries = templateExercises.map { templateExercise -&gt;&#10;                WorkoutEntry(&#10;                    dayId = workoutDay.id,&#10;                    exerciseId = templateExercise.exerciseId,&#10;                    sets = templateExercise.sets,&#10;                    reps = templateExercise.reps&#10;                )&#10;            }&#10;&#10;            workoutEntryDao.insertAll(entries)&#10;            println(&quot; REPO: Inserted ${entries.size} workout entries from template&quot;)&#10;&#10;            // Create sets for each workout entry&#10;            val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(workoutDay.id)&#10;            createSetsForEntries(insertedEntries)&#10;&#10;            // Update template last used date&#10;            workoutTemplateDao.updateLastUsedDate(templateId, date)&#10;        }&#10;&#10;        return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;    }&#10;&#10;    /**&#10;     * Get available templates for user selection&#10;     */&#10;    fun getAvailableTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt; {&#10;        return workoutTemplateDao.getAllActiveTemplates()&#10;    }&#10;&#10;    // ===========================================&#10;    // LEGACY DAY-BASED METHODS (PRESERVED)&#10;    // ===========================================&#10;&#10;    private suspend fun createWorkoutDayWithExercises(date: String): WorkoutDay {&#10;        // Create workout day&#10;        val workoutDay = WorkoutDay(date = date)&#10;        val dayId = workoutDayDao.insert(workoutDay).toInt()&#10;        val createdDay = workoutDay.copy(id = dayId)&#10;&#10;        // Determine workout type based on date&#10;        val workoutType = getWorkoutTypeForDate(date)&#10;        val exercises = getExercisesForWorkoutType(workoutType)&#10;&#10;        // Debug logging to see what's happening&#10;        println(&quot;DEBUG: Creating workout for date: $date, type: $workoutType, exercises count: ${exercises.size}&quot;)&#10;&#10;        // Only create entries if we have exercises for this workout type&#10;        if (exercises.isNotEmpty()) {&#10;            // Create workout entries&#10;            val entries = exercises.map { (exerciseId, sets, reps) -&gt;&#10;                WorkoutEntry(&#10;                    dayId = dayId,&#10;                    exerciseId = exerciseId,&#10;                    sets = sets,&#10;                    reps = reps&#10;                )&#10;            }&#10;&#10;            workoutEntryDao.insertAll(entries)&#10;            println(&quot;DEBUG: Inserted ${entries.size} workout entries for day $date&quot;)&#10;&#10;            //  FIX: Create sets for each workout entry immediately&#10;            // Since we just inserted the entries, we can use the entries we created&#10;            // and get their IDs after insertion&#10;            val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(dayId)&#10;            println(&quot; REPO: Retrieved ${insertedEntries.size} inserted entries to create sets&quot;)&#10;&#10;            for (entry in insertedEntries) {&#10;                println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;                // Create individual sets for each exercise&#10;                createSetsForWorkoutEntry(entry.id, entry.sets)&#10;                println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;                // Verify sets were created&#10;                val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;                println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;                createdSets.forEach { set -&gt;&#10;                    println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;                }&#10;            }&#10;&#10;            println(&quot; REPO: All sets created for ${insertedEntries.size} exercises&quot;)&#10;        } else {&#10;            println(&quot;DEBUG: No exercises found for workout type: $workoutType on date: $date&quot;)&#10;        }&#10;&#10;        return createdDay&#10;    }&#10;&#10;    private fun getWorkoutTypeForDate(date: String): WorkoutType {&#10;        val calendar = Calendar.getInstance()&#10;        calendar.time = dateFormat.parse(date) ?: Date()&#10;        val dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) // Sunday = 1, Saturday = 7&#10;&#10;        return when (dayOfWeek) {&#10;            Calendar.MONDAY -&gt; WorkoutType.PUSH_1&#10;            Calendar.TUESDAY -&gt; WorkoutType.PULL_1&#10;            Calendar.WEDNESDAY -&gt; WorkoutType.LEGS_1&#10;            Calendar.THURSDAY -&gt; WorkoutType.PUSH_2&#10;            Calendar.FRIDAY -&gt; WorkoutType.PULL_2&#10;            Calendar.SATURDAY -&gt; WorkoutType.LEGS_2&#10;            Calendar.SUNDAY -&gt; WorkoutType.REST&#10;            else -&gt; WorkoutType.REST&#10;        }&#10;    }&#10;&#10;    private fun getExercisesForWorkoutType(workoutType: WorkoutType): List&lt;Triple&lt;Int, Int, Int&gt;&gt; {&#10;        return when (workoutType) {&#10;            WorkoutType.PUSH_1 -&gt; listOf(&#10;                Triple(1, 4, 8),   // Barbell Bench Press - 4x6-8 reps&#10;                Triple(2, 3, 10),  // Standing Overhead Press - 3x8-10 reps&#10;                Triple(3, 3, 12),  // Incline Dumbbell Press - 3x8-12 reps&#10;                Triple(4, 3, 15),  // Dumbbell Lateral Raise - 3x12-15 reps&#10;                Triple(5, 3, 12)   // Cable Triceps Pushdown - 3x10-12 reps&#10;            )&#10;            WorkoutType.PULL_1 -&gt; listOf(&#10;                Triple(6, 3, 8),   // Deadlift - 3x5-8 reps&#10;                Triple(7, 3, 10),  // Pull-Ups or Lat Pulldowns - 3x8-10 reps&#10;                Triple(8, 3, 12),  // Bent-Over Barbell Row - 3x8-12 reps&#10;                Triple(9, 3, 15),  // Face Pull - 3x12-15 reps&#10;                Triple(10, 3, 12), // Barbell Biceps Curl - 3x8-12 reps&#10;                Triple(11, 2, 12)  // Hammer Curl - 2x10-12 reps&#10;            )&#10;            WorkoutType.LEGS_1 -&gt; listOf(&#10;                Triple(12, 4, 8),  // Back Squat - 4x6-8 reps&#10;                Triple(13, 3, 12), // Romanian Deadlift - 3x8-12 reps&#10;                Triple(14, 3, 12), // Leg Press - 3x10-12 reps&#10;                Triple(15, 3, 12), // Lying Leg Curl - 3x10-12 reps&#10;                Triple(16, 4, 15)  // Seated Calf Raise - 4x12-15 reps&#10;            )&#10;            WorkoutType.PUSH_2 -&gt; listOf(&#10;                Triple(17, 4, 8),  // Standing Overhead Press - 4x6-8 reps&#10;                Triple(18, 3, 12), // Incline Barbell Press - 3x8-12 reps&#10;                Triple(19, 3, 10), // Weighted Dips - 3x8-10 reps&#10;                Triple(20, 3, 15), // Cable Lateral Raise - 3x12-15 reps&#10;                Triple(21, 3, 15), // Pec Deck or Dumbbell Fly - 3x12-15 reps&#10;                Triple(22, 3, 12)  // Overhead Cable Triceps Extension - 3x10-12 reps&#10;            )&#10;            WorkoutType.PULL_2 -&gt; listOf(&#10;                Triple(23, 4, 10), // Pendlay or Bent-Over Row - 4x6-10 reps&#10;                Triple(24, 3, 12), // Weighted Pull-Ups or Wide-Grip Lat Pulldown - 3x8-12 reps&#10;                Triple(25, 3, 12), // Dumbbell Shrug - 3x10-12 reps&#10;                Triple(26, 3, 15), // Face Pull - 3x12-15 reps&#10;                Triple(27, 3, 12), // EZ-Bar Biceps Curl - 3x8-12 reps&#10;                Triple(28, 2, 12)  // Reverse Grip or Preacher Curl - 2x10-12 reps&#10;            )&#10;            WorkoutType.LEGS_2 -&gt; listOf(&#10;                Triple(29, 4, 8),  // Front Squat - 4x6-8 reps&#10;                Triple(30, 3, 10), // Bulgarian Split Squat - 3x8-10 reps (each leg)&#10;                Triple(31, 3, 12), // Barbell Hip Thrust - 3x10-12 reps&#10;                Triple(32, 3, 15), // Leg Extension - 3x12-15 reps&#10;                Triple(33, 3, 15), // Seated or Lying Leg Curl - 3x12-15 reps&#10;                Triple(34, 4, 15)  // Standing Calf Raise - 4x12-15 reps&#10;            )&#10;            WorkoutType.REST -&gt; emptyList()&#10;        }&#10;    }&#10;&#10;    suspend fun toggleExerciseCompletion(entryId: Int) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            val updatedEntry = it.copy(isCompleted = !it.isCompleted)&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun markExerciseComplete(entryId: Int, isCompleted: Boolean) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            // Set completedAt timestamp if the exercise is being marked as completed&#10;            val completedTimestamp = if (isCompleted &amp;&amp; !it.isCompleted) {&#10;                System.currentTimeMillis() // Current time in milliseconds&#10;            } else if (!isCompleted) {&#10;                null // If marking as incomplete, clear the timestamp&#10;            } else {&#10;                it.completedAt // Keep existing timestamp&#10;            }&#10;&#10;            val updatedEntry = it.copy(&#10;                isCompleted = isCompleted,&#10;                completedAt = completedTimestamp&#10;            )&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun updateExerciseDetails(entryId: Int, sets: Int, reps: Int, isCompleted: Boolean) {&#10;        println(&quot;️ REPO: Updating exercise details - entryId: $entryId, sets: $sets, reps: $reps, isCompleted: $isCompleted&quot;)&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            println(&quot;️ REPO: Found entry - id: ${it.id}, exerciseId: ${it.exerciseId}, current isCompleted: ${it.isCompleted}&quot;)&#10;&#10;            // Set completedAt timestamp if the exercise is being marked as completed&#10;            val completedTimestamp = if (isCompleted &amp;&amp; !it.isCompleted) {&#10;                System.currentTimeMillis() // Current time in milliseconds&#10;            } else {&#10;                it.completedAt // Keep existing timestamp or null&#10;            }&#10;&#10;            val updatedEntry = it.copy(&#10;                sets = sets,&#10;                reps = reps,&#10;                isCompleted = isCompleted,&#10;                completedAt = completedTimestamp&#10;            )&#10;&#10;            workoutEntryDao.update(updatedEntry)&#10;            println(&quot;️ REPO: Updated entry - id: ${updatedEntry.id}, new isCompleted: ${updatedEntry.isCompleted}, completedAt: ${updatedEntry.completedAt}&quot;)&#10;        } ?: run {&#10;            println(&quot;️ REPO ERROR: No entry found for entryId: $entryId&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun updateExerciseTime(entryId: Int, totalSecondsSpent: Int) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            // Update both totalSecondsSpent and set completedAt timestamp to current time&#10;            val currentTime = System.currentTimeMillis()&#10;            val updatedEntry = it.copy(&#10;                totalSecondsSpent = totalSecondsSpent,&#10;                completedAt = currentTime,&#10;                isCompleted = true // Also ensure isCompleted is set to true&#10;            )&#10;            workoutEntryDao.update(updatedEntry)&#10;            println(&quot; COMPLETION: WorkoutEntry ${entryId} marked as completed at ${java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(java.util.Date(currentTime))}&quot;)&#10;        }&#10;    }&#10;&#10;    // New methods for set-based operations&#10;    fun getSetsForWorkoutEntry(workoutEntryId: Int): Flow&lt;List&lt;SetEntry&gt;&gt; {&#10;        return setEntryDao.getSetsForWorkoutEntry(workoutEntryId)&#10;    }&#10;&#10;    suspend fun getSetsForWorkoutEntrySync(workoutEntryId: Int): List&lt;SetEntry&gt; {&#10;        return setEntryDao.getSetsForWorkoutEntrySync(workoutEntryId)&#10;    }&#10;&#10;    suspend fun getCompletedSetsCount(workoutEntryId: Int): Int {&#10;        return setEntryDao.getCompletedSetsCount(workoutEntryId)&#10;    }&#10;&#10;    //  NEW: Phase 2.1.1 - Methods for handling set performance data&#10;    suspend fun updateSetProgressWithPerformanceData(&#10;        setId: Int,&#10;        isCompleted: Boolean,&#10;        elapsedTimeSeconds: Int,&#10;        repsPerformed: Int,&#10;        weightUsed: Float&#10;    ) {&#10;        val completedAt = if (isCompleted) System.currentTimeMillis() else null&#10;        setEntryDao.updateSetProgressWithPerformanceData(&#10;            setId = setId,&#10;            isCompleted = isCompleted,&#10;            elapsedTimeSeconds = elapsedTimeSeconds,&#10;            completedAt = completedAt,&#10;            repsPerformed = repsPerformed,&#10;            weightUsed = weightUsed&#10;        )&#10;        println(&quot;️ REPO: Updated set $setId with performance data - reps: $repsPerformed, weight: $weightUsed&quot;)&#10;    }&#10;&#10;    //  NEW: 2.2.1 - Get set data by index for editing functionality&#10;    fun getSetByIndex(workoutEntryId: Int, setNumber: Int): Flow&lt;SetEntry?&gt; {&#10;        return setEntryDao.getSetByWorkoutEntryAndSetNumber(workoutEntryId, setNumber)&#10;    }&#10;&#10;    //  NEW: 2.2.2 - Dynamic Set Management Methods&#10;    suspend fun addSetToWorkoutEntry(workoutEntryId: Int, setNumber: Int) {&#10;        println(&quot; REPO: Adding set #$setNumber to WorkoutEntry ID=$workoutEntryId&quot;)&#10;&#10;        // Note: targetReps is just for logging - we don't store it in the SetEntry&#10;        // The target reps come from the parent WorkoutEntry's reps field&#10;        val newSet = SetEntry(&#10;            workoutEntryId = workoutEntryId,&#10;            setNumber = setNumber,&#10;            isCompleted = false,&#10;            elapsedTimeSeconds = 0,&#10;            repsPerformed = 0,  // Set to 0 as no reps have been performed yet&#10;            weightUsed = 0f&#10;        )&#10;&#10;        val setId = setEntryDao.insertSet(newSet)&#10;        println(&quot; REPO: Successfully added set with ID=$setId&quot;)&#10;    }&#10;&#10;    suspend fun removeSetFromWorkoutEntry(setId: Int) {&#10;        println(&quot; REPO: Removing set with ID=$setId&quot;)&#10;        setEntryDao.deleteSetById(setId)&#10;        println(&quot; REPO: Successfully removed set&quot;)&#10;    }&#10;&#10;    suspend fun createSetsForWorkoutEntry(workoutEntryId: Int, totalSets: Int) {&#10;        val sets = (1..totalSets).map { setNumber -&gt;&#10;            SetEntry(&#10;                workoutEntryId = workoutEntryId,&#10;                setNumber = setNumber&#10;            )&#10;        }&#10;        setEntryDao.insertAll(sets)&#10;    }&#10;&#10;    // Update exercise completion based on set completion&#10;    suspend fun updateExerciseCompletionFromSets(workoutEntryId: Int) {&#10;        val completedSets = setEntryDao.getCompletedSetsCount(workoutEntryId)&#10;        val totalSets = setEntryDao.getTotalSetsCount(workoutEntryId)&#10;&#10;        if (completedSets == totalSets &amp;&amp; totalSets &gt; 0) {&#10;            // Mark exercise as completed&#10;            val workoutEntry = workoutEntryDao.getWorkoutEntryById(workoutEntryId)&#10;            workoutEntry?.let {&#10;                workoutEntryDao.update(it.copy(isCompleted = true))&#10;            }&#10;        }&#10;    }&#10;&#10;    // New method that doesn't auto-create workout data&#10;    suspend fun getTodaysWorkoutWithoutCreating(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        val workoutDay = workoutDayDao.getWorkoutDayByDate(today)&#10;        return if (workoutDay != null) {&#10;            workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        } else {&#10;            kotlinx.coroutines.flow.flowOf(emptyList()) // Return empty list if no workout day exists&#10;        }&#10;    }&#10;&#10;    suspend fun getWorkoutForDateWithoutCreating(date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val workoutDay = workoutDayDao.getWorkoutDayByDate(date)&#10;        return if (workoutDay != null) {&#10;            workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        } else {&#10;            kotlinx.coroutines.flow.flowOf(emptyList()) // Return empty list if no workout day exists&#10;        }&#10;    }&#10;&#10;    //  NEW: Create workout for any specific date (supports debug mode)&#10;    suspend fun createWorkoutForDate(date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        println(&quot; REPO: Creating workout for date: $date&quot;)&#10;&#10;        // First, ensure exercises exist in the database&#10;        workoutEntryDao.getWorkoutEntryCount() // This will check if ANY entries exist&#10;        println(&quot; REPO: Checking if exercises are populated in database...&quot;)&#10;&#10;        // Check if workout day already exists&#10;        val existingWorkoutDay = workoutDayDao.getWorkoutDayByDate(date)&#10;&#10;        if (existingWorkoutDay != null) {&#10;            println(&quot; REPO: Found existing workout day with ID: ${existingWorkoutDay.id}&quot;)&#10;&#10;            // Check if it has exercises using count method&#10;            val existingEntriesCount = workoutEntryDao.getWorkoutEntryCountForDay(existingWorkoutDay.id)&#10;            println(&quot; REPO: Existing day has $existingEntriesCount exercises&quot;)&#10;&#10;            if (existingEntriesCount == 0) {&#10;                println(&quot; REPO: No exercises found, creating them now...&quot;)&#10;                // Day exists but has no exercises, create them&#10;                val workoutType = getWorkoutTypeForDate(date)&#10;                val exercises = getExercisesForWorkoutType(workoutType)&#10;                println(&quot; REPO: Got ${exercises.size} exercises for workout type: $workoutType&quot;)&#10;&#10;                if (exercises.isNotEmpty()) {&#10;                    try {&#10;                        val entries = exercises.map { (exerciseId, sets, reps) -&gt;&#10;                            WorkoutEntry(&#10;                                dayId = existingWorkoutDay.id,&#10;                                exerciseId = exerciseId,&#10;                                sets = sets,&#10;                                reps = reps&#10;                            )&#10;                        }&#10;                        workoutEntryDao.insertAll(entries)&#10;                        println(&quot; REPO: Inserted ${entries.size} workout entries&quot;)&#10;&#10;                        //  FIX: Create sets for each workout entry immediately&#10;                        val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(existingWorkoutDay.id)&#10;                        println(&quot; REPO: Retrieved ${insertedEntries.size} inserted entries to create sets&quot;)&#10;&#10;                        for (entry in insertedEntries) {&#10;                            println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;                            // Create individual sets for each exercise&#10;                            createSetsForWorkoutEntry(entry.id, entry.sets)&#10;                            println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;                            // Verify sets were created&#10;                            val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;                            println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;                            createdSets.forEach { set -&gt;&#10;                                println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;                            }&#10;                        }&#10;&#10;                        println(&quot; REPO: All sets created for ${insertedEntries.size} exercises&quot;)&#10;                      } catch (e: Exception) {&#10;                        println(&quot; REPO ERROR: Failed to insert workout entries - ${e.message}&quot;)&#10;                        // If foreign key constraint fails, we need to populate exercises first&#10;                        if (e.message?.contains(&quot;FOREIGN KEY constraint failed&quot;) == true) {&#10;                            println(&quot; REPO: Exercise data missing, need to populate exercises first&quot;)&#10;                            throw e // Re-throw to be caught by ViewModel&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            println(&quot; REPO: No existing workout day, creating new one...&quot;)&#10;            // Force create the workout day and exercises&#10;            val workoutDay = createWorkoutDayWithExercises(date)&#10;            println(&quot; REPO: Created new workout day with ID: ${workoutDay.id}&quot;)&#10;        }&#10;&#10;        // Get the final workout day (either existing or newly created)&#10;        val finalWorkoutDay = workoutDayDao.getWorkoutDayByDate(date)!!&#10;        println(&quot; REPO: Final workout day ID: ${finalWorkoutDay.id}&quot;)&#10;&#10;        // Return the flow of workout entries&#10;        return workoutEntryDao.getWorkoutEntriesForDay(finalWorkoutDay.id)&#10;    }&#10;&#10;    // ===========================================&#10;    // HELPER METHODS&#10;    // ===========================================&#10;&#10;    /**&#10;     * Create workout day only (without exercises) - used by template system&#10;     */&#10;    private suspend fun getOrCreateWorkoutDayOnly(date: String): WorkoutDay {&#10;        return workoutDayDao.getWorkoutDayByDate(date) ?: run {&#10;            val workoutDay = WorkoutDay(date = date)&#10;            val dayId = workoutDayDao.insert(workoutDay).toInt()&#10;            workoutDay.copy(id = dayId)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create sets for multiple workout entries - used by template system&#10;     */&#10;    private suspend fun createSetsForEntries(entries: List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;) {&#10;        for (entry in entries) {&#10;            println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;            createSetsForWorkoutEntry(entry.id, entry.sets)&#10;            println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;            // Verify sets were created&#10;            val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;            println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;            createdSets.forEach { set -&gt;&#10;                println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;            }&#10;        }&#10;        println(&quot; REPO: All sets created for ${entries.size} exercises&quot;)&#10;    }&#10;}&#10;&#10;enum class WorkoutType {&#10;    PUSH_1, PULL_1, LEGS_1, PUSH_2, PULL_2, LEGS_2, REST&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/navigation/NavigationGraph.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/navigation/NavigationGraph.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.navigation&#10;&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.screens.HistoryScreen&#10;import com.example.offlinepplworkoutapp.ui.screens.HomeScreen&#10;import com.example.offlinepplworkoutapp.ui.screens.PerformanceScreen&#10;import com.example.offlinepplworkoutapp.ui.screens.SettingsScreen&#10;&#10;sealed class Screen(val route: String) {&#10;    object Home : Screen(&quot;home&quot;)&#10;    object History : Screen(&quot;history&quot;)&#10;    object Performance : Screen(&quot;performance&quot;)&#10;    object Settings : Screen(&quot;settings&quot;)&#10;    object ExerciseDetail : Screen(&quot;exercise_detail&quot;)&#10;}&#10;&#10;@Composable&#10;fun NavigationGraph(&#10;    navController: NavHostController,&#10;    repository: WorkoutRepository,&#10;    onNavigateToExerciseDetail: () -&gt; Unit&#10;) {&#10;    // Store selected exercise at the navigation graph level&#10;    var selectedExercise by remember { mutableStateOf&lt;WorkoutEntryWithExercise?&gt;(null) }&#10;    &#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = Screen.Home.route&#10;    ) {&#10;        composable(Screen.Home.route) {&#10;            HomeScreen(&#10;                repository = repository,&#10;                onNavigateToExerciseDetail = {&#10;                    // When navigating to exercise detail, we'll handle it within the HomeScreen&#10;                    // This is because we need to maintain the exercise state there&#10;                    onNavigateToExerciseDetail()&#10;                }&#10;            )&#10;        }&#10;        &#10;        composable(Screen.History.route) {&#10;            HistoryScreen(repository = repository)&#10;        }&#10;        &#10;        composable(Screen.Performance.route) {&#10;            PerformanceScreen(repository = repository)&#10;        }&#10;        &#10;        composable(Screen.Settings.route) {&#10;            SettingsScreen()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/BottomNavigation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/BottomNavigation.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.components&#10;&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import com.example.offlinepplworkoutapp.R&#10;import com.example.offlinepplworkoutapp.navigation.Screen&#10;&#10;@Composable&#10;fun BottomNavigation(navController: NavController) {&#10;    val items = listOf(&#10;        BottomNavItem(Screen.Home.route, &quot;Home&quot;, R.drawable.ic_home),&#10;        BottomNavItem(Screen.History.route, &quot;History&quot;, R.drawable.ic_history),&#10;        BottomNavItem(Screen.Performance.route, &quot;Performance&quot;, R.drawable.ic_performance),&#10;        BottomNavItem(Screen.Settings.route, &quot;Settings&quot;, R.drawable.ic_settings)&#10;    )&#10;&#10;    NavigationBar(&#10;        containerColor = MaterialTheme.colorScheme.surface&#10;    ) {&#10;        val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;        val currentRoute = navBackStackEntry?.destination?.route&#10;        &#10;        items.forEach { item -&gt;&#10;            NavigationBarItem(&#10;                icon = { &#10;                    Icon(&#10;                        painter = painterResource(id = item.icon), &#10;                        contentDescription = item.title&#10;                    )&#10;                },&#10;                label = { &#10;                    Text(&#10;                        text = item.title,&#10;                        fontSize = 12.sp&#10;                    ) &#10;                },&#10;                selected = currentRoute == item.route,&#10;                onClick = {&#10;                    if (currentRoute != item.route) {&#10;                        navController.navigate(item.route) {&#10;                            // Pop up to the start destination of the graph to&#10;                            // avoid building up a large stack of destinations&#10;                            popUpTo(navController.graph.startDestinationId) {&#10;                                saveState = true&#10;                            }&#10;                            // Avoid multiple copies of the same destination&#10;                            launchSingleTop = true&#10;                            // Restore state when re-selecting a previously selected item&#10;                            restoreState = true&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;data class BottomNavItem(&#10;    val route: String,&#10;    val title: String,&#10;    val icon: Int&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/DebugDaySelector.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/DebugDaySelector.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.components&#10;&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import kotlinx.coroutines.launch&#10;import java.util.Calendar&#10;&#10;@Composable&#10;fun DebugDaySelector(&#10;    onDaySelected: (Int) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit,&#10;    onResetDatabase: () -&gt; Unit = {}&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&#10;                text = &quot; Debug Day Selector&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        },&#10;        text = {&#10;            LazyColumn {&#10;                item {&#10;                    Text(&#10;                        text = &quot;Select a day to test different workouts:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                }&#10;&#10;                val days = listOf(&#10;                    Calendar.MONDAY to &quot;Monday - Push Day 1 &quot;,&#10;                    Calendar.TUESDAY to &quot;Tuesday - Pull Day 1 ️&quot;,&#10;                    Calendar.WEDNESDAY to &quot;Wednesday - Legs Day 1 &quot;,&#10;                    Calendar.THURSDAY to &quot;Thursday - Push Day 2 &quot;,&#10;                    Calendar.FRIDAY to &quot;Friday - Pull Day 2 ️&quot;,&#10;                    Calendar.SATURDAY to &quot;Saturday - Legs Day 2 &quot;,&#10;                    Calendar.SUNDAY to &quot;Sunday - Rest Day ‍♂️&quot;&#10;                )&#10;&#10;                items(days) { (dayOfWeek, dayLabel) -&gt;&#10;                    OutlinedButton(&#10;                        onClick = { onDaySelected(dayOfWeek) },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 4.dp),&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            containerColor = if (dayOfWeek == Calendar.SUNDAY)&#10;                                MaterialTheme.colorScheme.secondaryContainer&#10;                            else&#10;                                MaterialTheme.colorScheme.primaryContainer&#10;                        )&#10;                    ) {&#10;                        Text(&#10;                            text = dayLabel,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            modifier = Modifier.padding(8.dp)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Debug Actions:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                println(&quot; DEBUG: Checking current database state...&quot;)&#10;                                val currentState = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                                println(&quot; CURRENT STATE: ${currentState.first} days, ${currentState.second} entries, ${currentState.third} sets&quot;)&#10;                            }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.tertiary&#10;                        )&#10;                    ) {&#10;                        Text(&quot; Check DB State&quot;)&#10;                    }&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                println(&quot; DEBUG: Force reset database...&quot;)&#10;                                PPLWorkoutDatabase.forceResetDatabase(context)&#10;                                kotlinx.coroutines.delay(200)&#10;                                val afterState = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                                println(&quot; AFTER FORCE RESET: ${afterState.first} days, ${afterState.second} entries, ${afterState.third} sets&quot;)&#10;                                onResetDatabase()&#10;                            }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.error&#10;                        )&#10;                    ) {&#10;                        Text(&quot; Reset Database&quot;)&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/ScrollbarExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/ScrollbarExtensions.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/performance/PerformanceChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/performance/PerformanceChart.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.components.performance&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.offlinepplworkoutapp.data.performance.ProgressPoint&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;/**&#10; * A performance chart component that visualizes workout progression over time&#10; */&#10;@Composable&#10;fun PerformanceChart(&#10;    progressPoints: List&lt;ProgressPoint&gt;,&#10;    modifier: Modifier = Modifier,&#10;    chartType: ChartType = ChartType.WEIGHT&#10;) {&#10;    // If there's no data, show a message&#10;    if (progressPoints.isEmpty()) {&#10;        Box(&#10;            modifier = modifier&#10;                .fillMaxWidth()&#10;                .height(200.dp),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;No data available for selected time period&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;        return&#10;    }&#10;&#10;    // Track animation progress&#10;    var animationPlayed by remember { mutableStateOf(false) }&#10;    val animationProgress = animateFloatAsState(&#10;        targetValue = if (animationPlayed) 1f else 0f,&#10;        animationSpec = tween(1000),&#10;        label = &quot;chart animation&quot;&#10;    )&#10;&#10;    // Start animation when component is first displayed&#10;    LaunchedEffect(Unit) {&#10;        animationPlayed = true&#10;    }&#10;&#10;    // Format the dates for display&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;MMM d&quot;, Locale.getDefault()) }&#10;&#10;    // Choose the data to display based on chart type&#10;    val dataPoints = when (chartType) {&#10;        ChartType.WEIGHT -&gt; progressPoints.map { it.weight }&#10;        ChartType.REPS -&gt; progressPoints.map { it.reps.toFloat() }&#10;        ChartType.VOLUME -&gt; progressPoints.map { it.volume }&#10;    }&#10;&#10;    // Find min and max values for scaling&#10;    val maxValue = dataPoints.maxOrNull() ?: 1f&#10;    val minValue = dataPoints.minOrNull() ?: 0f&#10;    val range = (maxValue - minValue).coerceAtLeast(1f)&#10;&#10;    // Get colors outside of Canvas since MaterialTheme.colorScheme can only be used in @Composable context&#10;    val primaryColor = MaterialTheme.colorScheme.primary&#10;    val outlineVariantColor = MaterialTheme.colorScheme.outlineVariant&#10;&#10;    // Main chart layout&#10;    Column(modifier = modifier.fillMaxWidth()) {&#10;        // Chart title based on type&#10;        Text(&#10;            text = when (chartType) {&#10;                ChartType.WEIGHT -&gt; &quot;Weight Progression&quot;&#10;                ChartType.REPS -&gt; &quot;Repetition Progression&quot;&#10;                ChartType.VOLUME -&gt; &quot;Volume Progression&quot;&#10;            },&#10;            style = MaterialTheme.typography.titleSmall,&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        // The actual chart visualization&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(200.dp)&#10;                .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f))&#10;                .padding(8.dp)&#10;        ) {&#10;            // Render the chart&#10;            Canvas(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                val width = size.width&#10;                val height = size.height&#10;                val usableHeight = height * 0.9f&#10;                val bottomPadding = height * 0.1f&#10;&#10;                // Draw horizontal grid lines&#10;                val strokePath = PathEffect.dashPathEffect(floatArrayOf(10f, 10f), 0f)&#10;&#10;                // Draw 5 horizontal grid lines&#10;                for (i in 0..4) {&#10;                    val y = height - bottomPadding - (i * usableHeight / 4)&#10;                    drawLine(&#10;                        color = outlineVariantColor, // Use the color from outside&#10;                        start = Offset(0f, y),&#10;                        end = Offset(width, y),&#10;                        strokeWidth = 1f,&#10;                        pathEffect = strokePath&#10;                    )&#10;                }&#10;&#10;                // Only draw the graph if we have at least 2 points&#10;                if (progressPoints.size &gt;= 2) {&#10;                    // Calculate x and y positions for each point&#10;                    val points = progressPoints.mapIndexed { index, point -&gt;&#10;                        val x = width * index / (progressPoints.size - 1)&#10;                        val normalizedValue = (dataPoints[index] - minValue) / range&#10;                        val y = height - bottomPadding - (normalizedValue * usableHeight) * animationProgress.value&#10;                        Offset(x, y)&#10;                    }&#10;&#10;                    // Draw connecting lines between points&#10;                    for (i in 0 until points.size - 1) {&#10;                        drawLine(&#10;                            color = primaryColor, // Use the color from outside&#10;                            start = points[i],&#10;                            end = points[i + 1],&#10;                            strokeWidth = 3f,&#10;                            cap = StrokeCap.Round&#10;                        )&#10;                    }&#10;&#10;                    // Draw points&#10;                    points.forEach { point -&gt;&#10;                        drawCircle(&#10;                            color = primaryColor, // Use the color from outside&#10;                            radius = 5f,&#10;                            center = point&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Draw the date labels at the bottom&#10;            if (progressPoints.size &gt;= 2) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .align(Alignment.BottomStart),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    // Show first date&#10;                    Text(&#10;                        text = dateFormatter.format(Date(progressPoints.first().date)),&#10;                        fontSize = 10.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;&#10;                    // Show last date&#10;                    Text(&#10;                        text = dateFormatter.format(Date(progressPoints.last().date)),&#10;                        fontSize = 10.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Types of charts that can be displayed&#10; */&#10;enum class ChartType {&#10;    WEIGHT, REPS, VOLUME&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.components.performance&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.offlinepplworkoutapp.data.performance.ProgressPoint&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;/**&#10; * A performance chart component that visualizes workout progression over time&#10; */&#10;@Composable&#10;fun PerformanceChart(&#10;    progressPoints: List&lt;ProgressPoint&gt;,&#10;    modifier: Modifier = Modifier,&#10;    chartType: ChartType = ChartType.WEIGHT&#10;) {&#10;    // If there's no data, show a message&#10;    if (progressPoints.isEmpty()) {&#10;        Box(&#10;            modifier = modifier&#10;                .fillMaxWidth()&#10;                .height(200.dp),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;No data available for selected time period&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;        return&#10;    }&#10;&#10;    // Track animation progress&#10;    var animationPlayed by remember { mutableStateOf(false) }&#10;    val animationProgress = animateFloatAsState(&#10;        targetValue = if (animationPlayed) 1f else 0f,&#10;        animationSpec = tween(1000),&#10;        label = &quot;chart animation&quot;&#10;    )&#10;&#10;    // Start animation when component is first displayed&#10;    LaunchedEffect(Unit) {&#10;        animationPlayed = true&#10;    }&#10;&#10;    // Format the dates for display&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;MMM d&quot;, Locale.getDefault()) }&#10;&#10;    // Choose the data to display based on chart type&#10;    val dataPoints = when (chartType) {&#10;        ChartType.WEIGHT -&gt; progressPoints.map { it.weight }&#10;        ChartType.REPS -&gt; progressPoints.map { it.reps.toFloat() }&#10;        ChartType.VOLUME -&gt; progressPoints.map { it.volume }&#10;    }&#10;&#10;    // Find min and max values for scaling&#10;    val maxValue = dataPoints.maxOrNull() ?: 1f&#10;    val minValue = dataPoints.minOrNull() ?: 0f&#10;    val range = (maxValue - minValue).coerceAtLeast(1f)&#10;&#10;    // Get colors outside of Canvas since MaterialTheme.colorScheme can only be used in @Composable context&#10;    val primaryColor = MaterialTheme.colorScheme.primary&#10;    val outlineVariantColor = MaterialTheme.colorScheme.outlineVariant&#10;    val secondaryColor = MaterialTheme.colorScheme.secondary&#10;&#10;    // Main chart layout&#10;    Column(modifier = modifier.fillMaxWidth()) {&#10;        // Chart title based on type&#10;        Text(&#10;            text = when (chartType) {&#10;                ChartType.WEIGHT -&gt; &quot;Weight Progression&quot;&#10;                ChartType.REPS -&gt; &quot;Repetition Progression&quot;&#10;                ChartType.VOLUME -&gt; &quot;Volume Progression&quot;&#10;            },&#10;            style = MaterialTheme.typography.titleSmall,&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        // The actual chart visualization&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(200.dp)&#10;                .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f))&#10;                .padding(8.dp)&#10;        ) {&#10;            // Show current value when only one data point is available&#10;            if (progressPoints.size == 1) {&#10;                Column(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.Center,&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    val currentValue = when (chartType) {&#10;                        ChartType.WEIGHT -&gt; &quot;${progressPoints[0].weight}kg&quot;&#10;                        ChartType.REPS -&gt; &quot;${progressPoints[0].reps} reps&quot;&#10;                        ChartType.VOLUME -&gt; &quot;${progressPoints[0].volume.toInt()} volume&quot;&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Current ${chartType.name.lowercase().capitalize()}&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                    Text(&#10;                        text = currentValue,&#10;                        style = MaterialTheme.typography.headlineMedium,&#10;                        color = primaryColor&#10;                    )&#10;                    Text(&#10;                        text = &quot;Need more workouts for progression data&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(top = 8.dp)&#10;                    )&#10;                }&#10;            } else {&#10;                // Render the chart for multiple data points&#10;                Canvas(&#10;                    modifier = Modifier.fillMaxSize()&#10;                ) {&#10;                    val width = size.width&#10;                    val height = size.height&#10;                    val usableHeight = height * 0.9f&#10;                    val bottomPadding = height * 0.1f&#10;&#10;                    // Draw horizontal grid lines&#10;                    val strokePath = PathEffect.dashPathEffect(floatArrayOf(10f, 10f), 0f)&#10;&#10;                    // Draw 5 horizontal grid lines&#10;                    for (i in 0..4) {&#10;                        val y = height - bottomPadding - (i * usableHeight / 4)&#10;                        drawLine(&#10;                            color = outlineVariantColor,&#10;                            start = Offset(0f, y),&#10;                            end = Offset(width, y),&#10;                            strokeWidth = 1f,&#10;                            pathEffect = strokePath&#10;                        )&#10;                    }&#10;&#10;                    // Calculate x and y positions for each point&#10;                    val points = progressPoints.mapIndexed { index, point -&gt;&#10;                        val x = width * index / (progressPoints.size - 1)&#10;                        val normalizedValue = (dataPoints[index] - minValue) / range&#10;                        val y = height - bottomPadding - (normalizedValue * usableHeight) * animationProgress.value&#10;                        Offset(x, y)&#10;                    }&#10;&#10;                    // Draw connecting lines between points&#10;                    for (i in 0 until points.size - 1) {&#10;                        drawLine(&#10;                            color = primaryColor,&#10;                            start = points[i],&#10;                            end = points[i + 1],&#10;                            strokeWidth = 3f,&#10;                            cap = StrokeCap.Round&#10;                        )&#10;                    }&#10;&#10;                    // Draw points&#10;                    points.forEach { point -&gt;&#10;                        drawCircle(&#10;                            color = primaryColor,&#10;                            radius = 5f,&#10;                            center = point&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Draw the date labels at the bottom&#10;            if (progressPoints.size &gt;= 2) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .align(Alignment.BottomStart),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    // Show first date&#10;                    Text(&#10;                        text = dateFormatter.format(Date(progressPoints.first().date)),&#10;                        fontSize = 10.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;&#10;                    // Show last date&#10;                    Text(&#10;                        text = dateFormatter.format(Date(progressPoints.last().date)),&#10;                        fontSize = 10.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            } else if (progressPoints.size == 1) {&#10;                // Show a single date at the bottom&#10;                Text(&#10;                    text = dateFormatter.format(Date(progressPoints.first().date)),&#10;                    fontSize = 10.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(bottom = 4.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Types of charts that can be displayed&#10; */&#10;enum class ChartType {&#10;    WEIGHT, REPS, VOLUME&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/MainScreenContent.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/MainScreenContent.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import com.example.offlinepplworkoutapp.R&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.components.DebugDaySelector&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModel&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;&#10;@Composable&#10;fun MainScreenContent(&#10;    viewModel: DailyWorkoutViewModel,&#10;    showDebugMenu: Boolean,&#10;    showResetConfirmation: Boolean,&#10;    showTemplateSelection: Boolean,&#10;    onShowDebugMenu: (Boolean) -&gt; Unit,&#10;    onShowResetConfirmation: (Boolean) -&gt; Unit,&#10;    onShowTemplateSelection: (Boolean) -&gt; Unit,&#10;    onNavigateToExerciseDetail: (WorkoutEntryWithExercise) -&gt; Unit,&#10;    repository: WorkoutRepository&#10;) {&#10;    val workoutEntries by viewModel.todaysWorkout.collectAsState(initial = emptyList())&#10;    val currentDate by viewModel.currentDate.collectAsState(initial = &quot;&quot;)&#10;    // Use a getter function for the workout type&#10;    val workoutType = viewModel.getWorkoutTypeName()&#10;    val isLoading by viewModel.isLoading.collectAsState(initial = false)&#10;    // Check if it's a rest day by comparing workout type&#10;    val isRestDay = workoutType == &quot;Rest Day&quot;&#10;    val coroutineScope = rememberCoroutineScope()&#10;    var selectedExercise by remember { mutableStateOf&lt;WorkoutEntryWithExercise?&gt;(null) }&#10;&#10;    LaunchedEffect(selectedExercise) {&#10;        if (selectedExercise != null) {&#10;            onNavigateToExerciseDetail(selectedExercise!!)&#10;        }&#10;    }&#10;&#10;    if (showDebugMenu) {&#10;        DebugDaySelector(&#10;            onDaySelected = { day -&gt;&#10;                viewModel.setDebugDate(day.toString())&#10;                onShowDebugMenu(false)&#10;            },&#10;            onDismiss = { onShowDebugMenu(false) },&#10;            onResetDatabase = {&#10;                onShowResetConfirmation(true)&#10;                onShowDebugMenu(false)&#10;            }&#10;        )&#10;    }&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Top bar with date and workout type&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.primaryContainer)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = currentDate,&#10;                    style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold),&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = workoutType,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;&#10;                // Show a &quot;Create Template&quot; button if no workout is available&#10;                if (workoutEntries.isEmpty() &amp;&amp; !isLoading &amp;&amp; !isRestDay) {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Button(&#10;                        onClick = { onShowTemplateSelection(true) }&#10;                    ) {&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Start&quot;&#10;                            )&#10;                            Text(&#10;                                text = &quot;Select Workout Template&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Content section with workout exercises or rest day message&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(8.dp),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            when {&#10;                isLoading -&gt; {&#10;                    CircularProgressIndicator()&#10;                }&#10;                isRestDay -&gt; {&#10;                    // Show rest day image and message&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.rest_day),&#10;                            contentDescription = &quot;Rest day&quot;,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentScale = ContentScale.Crop,&#10;                            alpha = 0.3f&#10;                        )&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .padding(16.dp)&#10;                                .align(Alignment.Center),&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)&#10;                            )&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier&#10;                                    .padding(24.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;REST DAY&quot;,&#10;                                    style = MaterialTheme.typography.headlineLarge.copy(&#10;                                        fontWeight = FontWeight.Bold&#10;                                    ),&#10;                                    color = MaterialTheme.colorScheme.primary&#10;                                )&#10;                                Spacer(modifier = Modifier.height(16.dp))&#10;                                Text(&#10;                                    text = &quot;Take time to recover and prepare for your next workout.&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge,&#10;                                    textAlign = TextAlign.Center&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                workoutEntries.isEmpty() -&gt; {&#10;                    // Show message when no workout is available (but it's not a rest day)&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        modifier = Modifier.padding(16.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;No workout available for today.&quot;,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Button(&#10;                            onClick = { onShowTemplateSelection(true) }&#10;                        ) {&#10;                            Text(text = &quot;Select a Workout Template&quot;)&#10;                        }&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    // Show workout exercises&#10;                    LazyColumn {&#10;                        items(workoutEntries) { entry -&gt;&#10;                            val secondsSpent = entry.totalSecondsSpent ?: 0&#10;                            val timeDisplay = when {&#10;                                secondsSpent &lt; 60 -&gt; &quot;${secondsSpent}s&quot;&#10;                                else -&gt; {&#10;                                    val minutes = secondsSpent / 60&#10;                                    val remainingSeconds = secondsSpent % 60&#10;                                    if (remainingSeconds == 0) &quot;${minutes}m&quot; else &quot;${minutes}m ${remainingSeconds}s&quot;&#10;                                }&#10;                            }&#10;&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(vertical = 4.dp)&#10;                                    .clickable {&#10;                                        selectedExercise = entry&#10;                                    },&#10;                                colors = CardDefaults.cardColors(&#10;                                    containerColor = if (entry.isCompleted)&#10;                                        MaterialTheme.colorScheme.secondaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.surface&#10;                                )&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(16.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Column(modifier = Modifier.weight(1f)) {&#10;                                        Text(&#10;                                            text = entry.exerciseName,&#10;                                            style = MaterialTheme.typography.titleMedium,&#10;                                            color = if (entry.isCompleted)&#10;                                                MaterialTheme.colorScheme.onSecondaryContainer&#10;                                            else&#10;                                                MaterialTheme.colorScheme.onSurface&#10;                                        )&#10;                                        Text(&#10;                                            text = &quot;${entry.sets} sets × ${entry.reps} reps&quot;,&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            color = if (entry.isCompleted)&#10;                                                MaterialTheme.colorScheme.onSecondaryContainer&#10;                                            else&#10;                                                MaterialTheme.colorScheme.onSurfaceVariant&#10;                                        )&#10;&#10;                                        // Display time spent&#10;                                        if (entry.totalSecondsSpent &gt; 0) {&#10;                                            Text(&#10;                                                text = &quot;Time: $timeDisplay&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                color = if (entry.isCompleted)&#10;                                                    MaterialTheme.colorScheme.onSecondaryContainer&#10;                                                else&#10;                                                    MaterialTheme.colorScheme.onSurfaceVariant&#10;                                            )&#10;                                        }&#10;                                    }&#10;&#10;                                    if (entry.isCompleted) {&#10;                                        Text(&#10;                                            text = &quot;✓&quot;,&#10;                                            style = MaterialTheme.typography.titleLarge,&#10;                                            color = MaterialTheme.colorScheme.primary&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/PerformanceScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/PerformanceScreen.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;&#10;/**&#10; * Performance screen placeholder - to be implemented in future releases&#10; */&#10;@Composable&#10;fun PerformanceScreen() {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Performance tracking\nComing soon&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(16.dp)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/PlaceholderScreens.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/PlaceholderScreens.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;&#10;@Composable&#10;fun HistoryScreen(repository: WorkoutRepository) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize().padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Workout History\n\nComing Soon&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PerformanceScreen(repository: WorkoutRepository) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize().padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Performance Analytics\n\nComing Soon&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SettingsScreen() {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize().padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Settings\n\nComing Soon&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/SettingsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/SettingsScreen.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;&#10;/**&#10; * Settings screen placeholder - to be implemented in future releases&#10; */&#10;@Composable&#10;fun SettingsScreen() {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Settings\nComing soon&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(16.dp)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/history/components/HistoryDateSelector.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/history/components/HistoryDateSelector.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.screens.history.components&#10;&#10;class HistoryDateSelector {&#10;}" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens.history.components&#10;&#10;class HistoryDateSelector {&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/history/components/HistoryExerciseCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/history/components/HistoryExerciseCard.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.screens.history.components&#10;&#10;class HistoryExerciseCard {&#10;}" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens.history.components&#10;&#10;class HistoryExerciseCard {&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/history/components/WorkoutSummaryCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/history/components/WorkoutSummaryCard.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.screens.history.components&#10;&#10;class WorkoutSummaryCard {&#10;}" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens.history.components&#10;&#10;class WorkoutSummaryCard {&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/performance/PerformanceScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/performance/PerformanceScreen.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.screens.performance&#10;&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.annotation.RequiresApi&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.expandVertically&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.shrinkVertically&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.interaction.collectIsPressedAsState&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.grid.items&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.ArrowRight&#10;import androidx.compose.material.icons.automirrored.filled.TrendingUp&#10;import androidx.compose.material.icons.filled.ArrowDropDown&#10;import androidx.compose.material.icons.filled.FitnessCenter&#10;import androidx.compose.material.icons.filled.Numbers&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.ElevatedCard&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.LinearProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.surfaceColorAtElevation&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.rotate&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import com.example.offlinepplworkoutapp.data.performance.ExercisePerformance&#10;import com.example.offlinepplworkoutapp.ui.components.performance.ChartType&#10;import com.example.offlinepplworkoutapp.ui.components.performance.PerformanceChart&#10;import com.example.offlinepplworkoutapp.ui.components.performance.PerformanceTabRow&#10;import kotlin.math.absoluteValue&#10;&#10;/**&#10; * Main composable for the Performance tab screen&#10; */&#10;@RequiresApi(Build.VERSION_CODES.O)&#10;@Composable&#10;fun PerformanceScreen(database: PPLWorkoutDatabase) {&#10;    // Create ViewModel through factory&#10;    val viewModel: PerformanceViewModel = viewModel(&#10;        factory = PerformanceViewModel.Factory(database)&#10;    )&#10;&#10;    // Collect UI state from ViewModel&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Main screen content&#10;    Surface(&#10;        modifier = Modifier.fillMaxSize(),&#10;        color = MaterialTheme.colorScheme.background&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            // Header with title, subtitle, and period selector&#10;            PerformanceHeader(&#10;                selectedDays = uiState.selectedTimePeriod,&#10;                onDaysSelected = { days -&gt; viewModel.loadPerformanceData(days) },&#10;                selectedMuscle = uiState.selectedMuscle,&#10;                onBackPressed = { viewModel.clearSelectedMuscle() }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Show loading indicator or content&#10;            if (uiState.isLoading) {&#10;                LoadingShimmerEffect()&#10;            } else {&#10;                // If no muscle is selected, show muscle groups&#10;                if (uiState.selectedMuscle == null) {&#10;                    MuscleGroupGrid(&#10;                        exercisePerformances = uiState.exercisePerformances,&#10;                        onMuscleSelected = { muscle -&gt; viewModel.selectMuscle(muscle) }&#10;                    )&#10;                } else {&#10;                    // Show exercises for the selected muscle&#10;                    val filteredExercises = uiState.exercisePerformances.filter {&#10;                        it.exercise.primaryMuscle == uiState.selectedMuscle&#10;                    }&#10;&#10;                    ExercisesList(&#10;                        exercisePerformances = filteredExercises,&#10;                        expandedExercises = uiState.expandedExercises,&#10;                        onToggleExpanded = { exerciseId -&gt; viewModel.toggleExerciseExpanded(exerciseId) }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Header with title, subtitle, period selector, and optional back button&#10; */&#10;@Composable&#10;fun PerformanceHeader(&#10;    selectedDays: Int,&#10;    onDaysSelected: (Int) -&gt; Unit,&#10;    selectedMuscle: String?,&#10;    onBackPressed: () -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier.padding(top = 16.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Title row with optional back button&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Show back button if a muscle is selected&#10;                if (selectedMuscle != null) {&#10;                    IconButton(&#10;                        onClick = onBackPressed,&#10;                        modifier = Modifier.size(40.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back to muscle groups&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                }&#10;&#10;                Text(&#10;                    text = selectedMuscle ?: &quot;Performance&quot;,&#10;                    style = MaterialTheme.typography.headlineLarge,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onBackground&#10;                )&#10;            }&#10;&#10;            // Period selector with pill shape&#10;            PeriodSelector(&#10;                selectedDays = selectedDays,&#10;                onDaysSelected = onDaysSelected&#10;            )&#10;        }&#10;&#10;        // Only show subtitle on the main performance screen&#10;        if (selectedMuscle == null) {&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = &quot;Your progress overview&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Pill-shaped period selector with dropdown&#10; */&#10;@Composable&#10;fun PeriodSelector(&#10;    selectedDays: Int,&#10;    onDaysSelected: (Int) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;    val timeOptions = listOf(7, 14, 30)&#10;&#10;    Box {&#10;        // Pill-shaped button&#10;        Card(&#10;            modifier = Modifier&#10;                .clip(RoundedCornerShape(50))&#10;                .clickable { expanded = true },&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surfaceColorAtElevation(2.dp)&#10;            )&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;${selectedDays}d&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Spacer(modifier = Modifier.width(2.dp))&#10;                Icon(&#10;                    imageVector = Icons.Filled.ArrowDropDown,&#10;                    contentDescription = &quot;Select time period&quot;,&#10;                    modifier = Modifier.size(20.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Dropdown menu&#10;        DropdownMenu(&#10;            expanded = expanded,&#10;            onDismissRequest = { expanded = false }&#10;        ) {&#10;            timeOptions.forEach { days -&gt;&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;${days}d&quot;) },&#10;                    onClick = {&#10;                        onDaysSelected(days)&#10;                        expanded = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Loading shimmer effect for a more polished UX&#10; */&#10;@Composable&#10;fun LoadingShimmerEffect() {&#10;    // Create infinite transition for shimmer effect&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;shimmer&quot;)&#10;    val alpha by infiniteTransition.animateFloat(&#10;        initialValue = 0.2f,&#10;        targetValue = 0.9f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 1000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Reverse&#10;        ),&#10;        label = &quot;shimmer_alpha&quot;&#10;    )&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;            // Shimmer grid placeholder&#10;            LazyVerticalGrid(&#10;                columns = GridCells.Fixed(2),&#10;                contentPadding = PaddingValues(vertical = 16.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp),&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                items(6) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(120.dp)&#10;                            .clip(MaterialTheme.shapes.medium)&#10;                            .background(&#10;                                MaterialTheme.colorScheme.surfaceVariant&#10;                                    .copy(alpha = alpha)&#10;                            )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;            CircularProgressIndicator(color = MaterialTheme.colorScheme.primary)&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;Loading your performance data...&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Grid of muscle group cards in a 2-column layout&#10; */&#10;@Composable&#10;fun MuscleGroupGrid(&#10;    exercisePerformances: List&lt;ExercisePerformance&gt;,&#10;    onMuscleSelected: (String) -&gt; Unit&#10;) {&#10;    // Group exercises by primary muscle&#10;    val muscleGroups = exercisePerformances&#10;        .map { it.exercise.primaryMuscle }&#10;        .filter { it.isNotBlank() }&#10;        .distinct()&#10;        .sorted()&#10;&#10;    if (muscleGroups.isEmpty()) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                Icon(&#10;                    imageVector = Icons.Default.FitnessCenter,&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .size(64.dp)&#10;                        .padding(bottom = 16.dp),&#10;                    tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.7f)&#10;                )&#10;                Text(&#10;                    text = &quot;No exercise data available&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = &quot;Complete workouts to see your performance&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;    } else {&#10;        LazyVerticalGrid(&#10;            columns = GridCells.Fixed(2),&#10;            contentPadding = PaddingValues(bottom = 24.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp),  // Reduced spacing&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)     // Reduced spacing&#10;        ) {&#10;            items(muscleGroups) { muscle -&gt;&#10;                val exercisesForMuscle = exercisePerformances.filter {&#10;                    it.exercise.primaryMuscle == muscle&#10;                }&#10;&#10;                // Use interactionSource to track pressed state&#10;                val interactionSource = remember { MutableInteractionSource() }&#10;                val isPressed by interactionSource.collectIsPressedAsState()&#10;&#10;                // Muscle group card with press animation - reduced size&#10;                ElevatedCard(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .aspectRatio(2f)  // Changed from 1f to 1.5f to make card shorter&#10;                        .graphicsLayer {&#10;                            // Scale down slightly when pressed&#10;                            val scale = if (isPressed) 0.96f else 1f&#10;                            scaleX = scale&#10;                            scaleY = scale&#10;                        }&#10;                        .clickable(&#10;                            interactionSource = interactionSource,&#10;                            indication = null // Remove ripple effect as we have our own animation&#10;                        ) { onMuscleSelected(muscle) },&#10;                    shape = MaterialTheme.shapes.medium,&#10;                    elevation = CardDefaults.elevatedCardElevation(&#10;                        defaultElevation = 2.dp  // Reduced from 4dp to 2dp&#10;                    ),&#10;                    colors = CardDefaults.elevatedCardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                    )&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Brush.radialGradient(&#10;                                    colors = listOf(&#10;                                        MaterialTheme.colorScheme.surfaceVariant,&#10;                                        MaterialTheme.colorScheme.primary.copy(alpha = 0.15f)&#10;                                    ),&#10;                                    radius = 500f&#10;                                )&#10;                            )&#10;                            .padding(12.dp)  // Reduced padding from 16dp to 12dp&#10;                    ) {&#10;                        // Muscle icon at the top - reduced size&#10;                        getMuscleIcon(muscle)?.let { icon -&gt;&#10;                            Icon(&#10;                                imageVector = icon,&#10;                                contentDescription = null,&#10;                                modifier = Modifier&#10;                                    .size(28.dp)  // Reduced from 40dp to 28dp&#10;                                    .align(Alignment.TopStart),&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        }&#10;&#10;                        // Text info at the bottom&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .align(Alignment.BottomStart)&#10;                                .fillMaxWidth()&#10;                        ) {&#10;                            Text(&#10;                                text = muscle,&#10;                                style = MaterialTheme.typography.bodyLarge,  // Changed from titleMedium to bodyLarge&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;&#10;                            Text(&#10;                                text = &quot;${exercisesForMuscle.size} ${if (exercisesForMuscle.size == 1) &quot;exercise&quot; else &quot;exercises&quot;}&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;&#10;                        // Arrow indicator - reduced size&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowRight,&#10;                            contentDescription = &quot;View exercises&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary,&#10;                            modifier = Modifier&#10;                                .align(Alignment.BottomEnd)&#10;                                .size(16.dp)  // Reduced from 20dp to 16dp&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Function to get the appropriate icon for each muscle group&#10; */&#10;@Composable&#10;fun getMuscleIcon(muscleName: String): ImageVector? {&#10;    return when (muscleName.lowercase()) {&#10;        &quot;chest&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;back&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;shoulders&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;biceps&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;triceps&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;legs&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;glutes&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;hamstrings&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;quadriceps&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;calves&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;abs&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;forearms&quot; -&gt; Icons.Default.FitnessCenter&#10;        else -&gt; Icons.Default.FitnessCenter&#10;    }&#10;}&#10;&#10;/**&#10; * List of exercises for a selected muscle group&#10; */&#10;@Composable&#10;fun ExercisesList(&#10;    exercisePerformances: List&lt;ExercisePerformance&gt;,&#10;    expandedExercises: Set&lt;Int&gt;,&#10;    onToggleExpanded: (Int) -&gt; Unit&#10;) {&#10;    if (exercisePerformances.isEmpty()) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;No exercises found for this muscle group&quot;,&#10;                style = MaterialTheme.typography.bodyLarge&#10;            )&#10;        }&#10;    } else {&#10;        LazyColumn(&#10;            modifier = Modifier.fillMaxSize(),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp),&#10;            contentPadding = PaddingValues(bottom = 24.dp)&#10;        ) {&#10;            items(exercisePerformances) { performance -&gt;&#10;                ExercisePerformanceCard(&#10;                    performance = performance,&#10;                    isExpanded = expandedExercises.contains(performance.exercise.id),&#10;                    onToggleExpanded = { onToggleExpanded(performance.exercise.id) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Card displaying exercise performance data&#10; */&#10;@Composable&#10;fun ExercisePerformanceCard(&#10;    performance: ExercisePerformance,&#10;    isExpanded: Boolean,&#10;    onToggleExpanded: () -&gt; Unit&#10;) {&#10;    val expandTransition = remember { Animatable(0f) }&#10;    val exerciseId = performance.exercise.id&#10;    val exerciseName = performance.exercise.name&#10;&#10;    // Log when the card is rendered&#10;    Log.d(&quot;PerformanceScreen&quot;, &quot;Rendering ExercisePerformanceCard: ID=${exerciseId}, Name=${exerciseName}, Expanded=${isExpanded}&quot;)&#10;&#10;    // Log performance data&#10;    Log.d(&quot;PerformanceScreen&quot;, &quot;Performance data for ${exerciseName}: &quot; +&#10;            &quot;MaxWeight=${performance.maxWeight}kg, &quot; +&#10;            &quot;MaxReps=${performance.maxReps}, &quot; +&#10;            &quot;VolumeProg=${performance.volumeProgress}%, &quot; +&#10;            &quot;WeightProg=${performance.weightProgress}%, &quot; +&#10;            &quot;Sessions=${performance.sessionsCount}, &quot; +&#10;            &quot;DataPoints=${performance.progressData.size}&quot;&#10;    )&#10;&#10;    // Animate the expansion/collapse&#10;    LaunchedEffect(isExpanded) {&#10;        Log.d(&quot;PerformanceScreen&quot;, &quot;Animating card expansion: ${exerciseName} to ${if (isExpanded) &quot;expanded&quot; else &quot;collapsed&quot;}&quot;)&#10;        expandTransition.animateTo(&#10;            targetValue = if (isExpanded) 1f else 0f,&#10;            animationSpec = tween(300)&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .animateContentSize(&#10;                animationSpec = spring(&#10;                    dampingRatio = Spring.DampingRatioMediumBouncy,&#10;                    stiffness = Spring.StiffnessLow&#10;                )&#10;            ),&#10;        shape = MaterialTheme.shapes.medium,&#10;        elevation = CardDefaults.cardElevation(&#10;            defaultElevation = 2.dp&#10;        )&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            // Exercise header (always visible)&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .clickable { onToggleExpanded() },&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = performance.exercise.name,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Icon(&#10;                    imageVector = if (isExpanded) Icons.Filled.ArrowDropDown else Icons.AutoMirrored.Filled.ArrowRight,&#10;                    contentDescription = if (isExpanded) &quot;Collapse&quot; else &quot;Expand&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.rotate(expandTransition.value * 180f)&#10;                )&#10;            }&#10;&#10;            // Performance details (only visible when expanded)&#10;            AnimatedVisibility(&#10;                visible = isExpanded,&#10;                enter = fadeIn() + expandVertically(),&#10;                exit = fadeOut() + shrinkVertically()&#10;            ) {&#10;                Column(modifier = Modifier.padding(top = 16.dp)) {&#10;                    // Performance visualization with tabs&#10;                    var selectedTabIndex by remember { mutableStateOf(0) }&#10;&#10;                    PerformanceTabRow(&#10;                        selectedTabIndex = selectedTabIndex,&#10;                        onTabSelected = { selectedTabIndex = it }&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    // Show the appropriate chart based on the selected tab&#10;                    PerformanceChart(&#10;                        progressPoints = performance.progressData,&#10;                        chartType = when (selectedTabIndex) {&#10;                            0 -&gt; ChartType.WEIGHT&#10;                            1 -&gt; ChartType.REPS&#10;                            else -&gt; ChartType.VOLUME&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(200.dp)&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    // Progress summary&#10;                    ProgressSummaryCard(performance = performance)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Card displaying a summary of progress metrics&#10; */&#10;@Composable&#10;fun ProgressSummaryCard(performance: ExercisePerformance) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        shape = MaterialTheme.shapes.medium,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.7f)&#10;        )&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Progress Summary&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceAround&#10;            ) {&#10;                MetricItem(&#10;                    label = &quot;Max Weight&quot;,&#10;                    value = &quot;${performance.maxWeight} kg&quot;,&#10;                    icon = Icons.Default.FitnessCenter&#10;                )&#10;                MetricItem(&#10;                    label = &quot;Max Reps&quot;,&#10;                    value = &quot;${performance.maxReps}&quot;,&#10;                    icon = Icons.Default.Numbers&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceAround&#10;            ) {&#10;                val volumeProgress = performance.volumeProgress&#10;                val weightProgress = performance.weightProgress&#10;&#10;                // Calculate rep progress - similar to how weight progress is calculated&#10;                // Can be 0 if there's only one data point&#10;                val repProgress = if (performance.progressData.size &gt;= 2) {&#10;                    val firstReps = performance.progressData.first().reps&#10;                    val lastReps = performance.progressData.last().reps&#10;                    if (firstReps &gt; 0) {&#10;                        ((lastReps - firstReps).toFloat() / firstReps * 100f)&#10;                    } else 0f&#10;                } else 0f&#10;&#10;                ProgressMetricItem(&#10;                    label = &quot;Rep Progress&quot;,&#10;                    value = &quot;${String.format(java.util.Locale.US, &quot;%.1f&quot;, repProgress)}%&quot;,&#10;                    progress = repProgress / 100f,&#10;                    icon = Icons.AutoMirrored.Filled.TrendingUp&#10;                )&#10;&#10;                ProgressMetricItem(&#10;                    label = &quot;Weight Progress&quot;,&#10;                    value = &quot;${String.format(java.util.Locale.US, &quot;%.1f&quot;, weightProgress)}%&quot;,&#10;                    progress = weightProgress / 100f,&#10;                    icon = Icons.AutoMirrored.Filled.TrendingUp&#10;                )&#10;&#10;                ProgressMetricItem(&#10;                    label = &quot;Volume Progress&quot;,&#10;                    value = &quot;${String.format(java.util.Locale.US, &quot;%.1f&quot;, volumeProgress)}%&quot;,&#10;                    progress = volumeProgress / 100f,&#10;                    icon = Icons.AutoMirrored.Filled.TrendingUp&#10;                )&#10;            }&#10;&#10;            if (performance.sessionsCount &gt; 0) {&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = &quot;Based on ${performance.sessionsCount} training sessions&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Single metric item display with icon&#10; */&#10;@Composable&#10;fun MetricItem(label: String, value: String, icon: ImageVector) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.padding(horizontal = 8.dp)&#10;    ) {&#10;        Icon(&#10;            imageVector = icon,&#10;            contentDescription = null,&#10;            tint = MaterialTheme.colorScheme.primary,&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;        Text(&#10;            text = value,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onSurface&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Progress metric item with progress indicator&#10; */&#10;@Composable&#10;fun ProgressMetricItem(label: String, value: String, progress: Float, icon: ImageVector) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.padding(horizontal = 8.dp)&#10;    ) {&#10;        val progressColor = when {&#10;            progress &gt; 0 -&gt; MaterialTheme.colorScheme.primary&#10;            progress &lt; 0 -&gt; Color.Red&#10;            else -&gt; MaterialTheme.colorScheme.onSurfaceVariant&#10;        }&#10;&#10;        Icon(&#10;            imageVector = icon,&#10;            contentDescription = null,&#10;            tint = progressColor,&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;&#10;        Text(&#10;            text = value,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = progressColor&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(2.dp))&#10;&#10;        // Small progress indicator&#10;        LinearProgressIndicator(&#10;            progress = { progress.absoluteValue.coerceIn(0f, 1f) },&#10;            color = progressColor,&#10;            trackColor = MaterialTheme.colorScheme.surfaceVariant,&#10;            modifier = Modifier&#10;                .width(60.dp)&#10;                .height(3.dp)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens.performance&#10;&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.annotation.RequiresApi&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.expandVertically&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.shrinkVertically&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.interaction.collectIsPressedAsState&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.grid.items&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.ArrowRight&#10;import androidx.compose.material.icons.automirrored.filled.TrendingUp&#10;import androidx.compose.material.icons.filled.ArrowDropDown&#10;import androidx.compose.material.icons.filled.FitnessCenter&#10;import androidx.compose.material.icons.filled.Numbers&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.ElevatedCard&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.LinearProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.surfaceColorAtElevation&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.rotate&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import com.example.offlinepplworkoutapp.data.performance.ExercisePerformance&#10;import com.example.offlinepplworkoutapp.ui.components.performance.ChartType&#10;import com.example.offlinepplworkoutapp.ui.components.performance.PerformanceChart&#10;import com.example.offlinepplworkoutapp.ui.components.performance.PerformanceTabRow&#10;import kotlin.math.absoluteValue&#10;&#10;/**&#10; * Main composable for the Performance tab screen&#10; */&#10;@RequiresApi(Build.VERSION_CODES.O)&#10;@Composable&#10;fun PerformanceScreen(database: PPLWorkoutDatabase) {&#10;    // Create ViewModel through factory&#10;    val viewModel: PerformanceViewModel = viewModel(&#10;        factory = PerformanceViewModel.Factory(database)&#10;    )&#10;&#10;    // Collect UI state from ViewModel&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Main screen content&#10;    Surface(&#10;        modifier = Modifier.fillMaxSize(),&#10;        color = MaterialTheme.colorScheme.background&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            // Header with title, subtitle, and period selector&#10;            PerformanceHeader(&#10;                selectedDays = uiState.selectedTimePeriod,&#10;                onDaysSelected = { days -&gt; viewModel.loadPerformanceData(days) },&#10;                selectedMuscle = uiState.selectedMuscle,&#10;                onBackPressed = { viewModel.clearSelectedMuscle() }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Show loading indicator or content&#10;            if (uiState.isLoading) {&#10;                LoadingShimmerEffect()&#10;            } else {&#10;                // If no muscle is selected, show muscle groups&#10;                if (uiState.selectedMuscle == null) {&#10;                    MuscleGroupGrid(&#10;                        exercisePerformances = uiState.exercisePerformances,&#10;                        onMuscleSelected = { muscle -&gt; viewModel.selectMuscle(muscle) }&#10;                    )&#10;                } else {&#10;                    // Show exercises for the selected muscle&#10;                    val filteredExercises = uiState.exercisePerformances.filter {&#10;                        it.exercise.primaryMuscle == uiState.selectedMuscle&#10;                    }&#10;&#10;                    ExercisesList(&#10;                        exercisePerformances = filteredExercises,&#10;                        expandedExercises = uiState.expandedExercises,&#10;                        onToggleExpanded = { exerciseId -&gt; viewModel.toggleExerciseExpanded(exerciseId) }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Header with title, subtitle, period selector, and optional back button&#10; */&#10;@Composable&#10;fun PerformanceHeader(&#10;    selectedDays: Int,&#10;    onDaysSelected: (Int) -&gt; Unit,&#10;    selectedMuscle: String?,&#10;    onBackPressed: () -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier.padding(top = 16.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Title row with optional back button&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Show back button if a muscle is selected&#10;                if (selectedMuscle != null) {&#10;                    IconButton(&#10;                        onClick = onBackPressed,&#10;                        modifier = Modifier.size(40.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back to muscle groups&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                }&#10;&#10;                Text(&#10;                    text = selectedMuscle ?: &quot;Performance&quot;,&#10;                    style = MaterialTheme.typography.headlineLarge,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onBackground&#10;                )&#10;            }&#10;&#10;            // Period selector with pill shape&#10;            PeriodSelector(&#10;                selectedDays = selectedDays,&#10;                onDaysSelected = onDaysSelected&#10;            )&#10;        }&#10;&#10;        // Only show subtitle on the main performance screen&#10;        if (selectedMuscle == null) {&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = &quot;Your progress overview&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Pill-shaped period selector with dropdown&#10; */&#10;@Composable&#10;fun PeriodSelector(&#10;    selectedDays: Int,&#10;    onDaysSelected: (Int) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;    val timeOptions = listOf(7, 14, 30)&#10;&#10;    Box {&#10;        // Pill-shaped button&#10;        Card(&#10;            modifier = Modifier&#10;                .clip(RoundedCornerShape(50))&#10;                .clickable { expanded = true },&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surfaceColorAtElevation(2.dp)&#10;            )&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;${selectedDays}d&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Spacer(modifier = Modifier.width(2.dp))&#10;                Icon(&#10;                    imageVector = Icons.Filled.ArrowDropDown,&#10;                    contentDescription = &quot;Select time period&quot;,&#10;                    modifier = Modifier.size(20.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Dropdown menu&#10;        DropdownMenu(&#10;            expanded = expanded,&#10;            onDismissRequest = { expanded = false }&#10;        ) {&#10;            timeOptions.forEach { days -&gt;&#10;                DropdownMenuItem(&#10;                    text = { Text(&quot;${days}d&quot;) },&#10;                    onClick = {&#10;                        onDaysSelected(days)&#10;                        expanded = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Loading shimmer effect for a more polished UX&#10; */&#10;@Composable&#10;fun LoadingShimmerEffect() {&#10;    // Create infinite transition for shimmer effect&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;shimmer&quot;)&#10;    val alpha by infiniteTransition.animateFloat(&#10;        initialValue = 0.2f,&#10;        targetValue = 0.9f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 1000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Reverse&#10;        ),&#10;        label = &quot;shimmer_alpha&quot;&#10;    )&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;            // Shimmer grid placeholder&#10;            LazyVerticalGrid(&#10;                columns = GridCells.Fixed(2),&#10;                contentPadding = PaddingValues(vertical = 16.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp),&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                items(6) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(120.dp)&#10;                            .clip(MaterialTheme.shapes.medium)&#10;                            .background(&#10;                                MaterialTheme.colorScheme.surfaceVariant&#10;                                    .copy(alpha = alpha)&#10;                            )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;            CircularProgressIndicator(color = MaterialTheme.colorScheme.primary)&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;Loading your performance data...&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Grid of muscle group cards in a 2-column layout&#10; */&#10;@Composable&#10;fun MuscleGroupGrid(&#10;    exercisePerformances: List&lt;ExercisePerformance&gt;,&#10;    onMuscleSelected: (String) -&gt; Unit&#10;) {&#10;    // Group exercises by primary muscle&#10;    val muscleGroups = exercisePerformances&#10;        .map { it.exercise.primaryMuscle }&#10;        .filter { it.isNotBlank() }&#10;        .distinct()&#10;        .sorted()&#10;&#10;    if (muscleGroups.isEmpty()) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                Icon(&#10;                    imageVector = Icons.Default.FitnessCenter,&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .size(64.dp)&#10;                        .padding(bottom = 16.dp),&#10;                    tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.7f)&#10;                )&#10;                Text(&#10;                    text = &quot;No exercise data available&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = &quot;Complete workouts to see your performance&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;    } else {&#10;        LazyVerticalGrid(&#10;            columns = GridCells.Fixed(2),&#10;            contentPadding = PaddingValues(bottom = 24.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp),  // Reduced spacing&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)     // Reduced spacing&#10;        ) {&#10;            items(muscleGroups) { muscle -&gt;&#10;                val exercisesForMuscle = exercisePerformances.filter {&#10;                    it.exercise.primaryMuscle == muscle&#10;                }&#10;&#10;                // Use interactionSource to track pressed state&#10;                val interactionSource = remember { MutableInteractionSource() }&#10;                val isPressed by interactionSource.collectIsPressedAsState()&#10;&#10;                // Muscle group card with press animation - reduced size&#10;                ElevatedCard(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .aspectRatio(2f)  // Changed from 1f to 1.5f to make card shorter&#10;                        .graphicsLayer {&#10;                            // Scale down slightly when pressed&#10;                            val scale = if (isPressed) 0.96f else 1f&#10;                            scaleX = scale&#10;                            scaleY = scale&#10;                        }&#10;                        .clickable(&#10;                            interactionSource = interactionSource,&#10;                            indication = null // Remove ripple effect as we have our own animation&#10;                        ) { onMuscleSelected(muscle) },&#10;                    shape = MaterialTheme.shapes.medium,&#10;                    elevation = CardDefaults.elevatedCardElevation(&#10;                        defaultElevation = 2.dp  // Reduced from 4dp to 2dp&#10;                    ),&#10;                    colors = CardDefaults.elevatedCardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                    )&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Brush.radialGradient(&#10;                                    colors = listOf(&#10;                                        MaterialTheme.colorScheme.surfaceVariant,&#10;                                        MaterialTheme.colorScheme.primary.copy(alpha = 0.15f)&#10;                                    ),&#10;                                    radius = 500f&#10;                                )&#10;                            )&#10;                            .padding(12.dp)  // Reduced padding from 16dp to 12dp&#10;                    ) {&#10;                        // Muscle icon at the top - reduced size&#10;                        getMuscleIcon(muscle)?.let { icon -&gt;&#10;                            Icon(&#10;                                imageVector = icon,&#10;                                contentDescription = null,&#10;                                modifier = Modifier&#10;                                    .size(28.dp)  // Reduced from 40dp to 28dp&#10;                                    .align(Alignment.TopStart),&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        }&#10;&#10;                        // Text info at the bottom&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .align(Alignment.BottomStart)&#10;                                .fillMaxWidth()&#10;                        ) {&#10;                            Text(&#10;                                text = muscle,&#10;                                style = MaterialTheme.typography.bodyLarge,  // Changed from titleMedium to bodyLarge&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;&#10;                            Text(&#10;                                text = &quot;${exercisesForMuscle.size} ${if (exercisesForMuscle.size == 1) &quot;exercise&quot; else &quot;exercises&quot;}&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;&#10;                        // Arrow indicator - reduced size&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowRight,&#10;                            contentDescription = &quot;View exercises&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary,&#10;                            modifier = Modifier&#10;                                .align(Alignment.BottomEnd)&#10;                                .size(16.dp)  // Reduced from 20dp to 16dp&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Function to get the appropriate icon for each muscle group&#10; */&#10;@Composable&#10;fun getMuscleIcon(muscleName: String): ImageVector? {&#10;    return when (muscleName.lowercase()) {&#10;        &quot;chest&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;back&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;shoulders&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;biceps&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;triceps&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;legs&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;glutes&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;hamstrings&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;quadriceps&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;calves&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;abs&quot; -&gt; Icons.Default.FitnessCenter&#10;        &quot;forearms&quot; -&gt; Icons.Default.FitnessCenter&#10;        else -&gt; Icons.Default.FitnessCenter&#10;    }&#10;}&#10;&#10;/**&#10; * List of exercises for a selected muscle group&#10; */&#10;@Composable&#10;fun ExercisesList(&#10;    exercisePerformances: List&lt;ExercisePerformance&gt;,&#10;    expandedExercises: Set&lt;Int&gt;,&#10;    onToggleExpanded: (Int) -&gt; Unit&#10;) {&#10;    if (exercisePerformances.isEmpty()) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;No exercises found for this muscle group&quot;,&#10;                style = MaterialTheme.typography.bodyLarge&#10;            )&#10;        }&#10;    } else {&#10;        LazyColumn(&#10;            modifier = Modifier.fillMaxSize(),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp),&#10;            contentPadding = PaddingValues(bottom = 24.dp)&#10;        ) {&#10;            items(exercisePerformances) { performance -&gt;&#10;                ExercisePerformanceCard(&#10;                    performance = performance,&#10;                    isExpanded = expandedExercises.contains(performance.exercise.id),&#10;                    onToggleExpanded = { onToggleExpanded(performance.exercise.id) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Card displaying exercise performance data&#10; */&#10;@Composable&#10;fun ExercisePerformanceCard(&#10;    performance: ExercisePerformance,&#10;    isExpanded: Boolean,&#10;    onToggleExpanded: () -&gt; Unit&#10;) {&#10;    val expandTransition = remember { Animatable(0f) }&#10;    val exerciseId = performance.exercise.id&#10;    val exerciseName = performance.exercise.name&#10;&#10;    // Log when the card is rendered&#10;    Log.d(&quot;PerformanceScreen&quot;, &quot;Rendering ExercisePerformanceCard: ID=${exerciseId}, Name=${exerciseName}, Expanded=${isExpanded}&quot;)&#10;&#10;    // Log performance data&#10;    Log.d(&quot;PerformanceScreen&quot;, &quot;Performance data for ${exerciseName}: &quot; +&#10;            &quot;MaxWeight=${performance.maxWeight}kg, &quot; +&#10;            &quot;MaxReps=${performance.maxReps}, &quot; +&#10;            &quot;VolumeProg=${performance.volumeProgress}%, &quot; +&#10;            &quot;WeightProg=${performance.weightProgress}%, &quot; +&#10;            &quot;Sessions=${performance.sessionsCount}, &quot; +&#10;            &quot;DataPoints=${performance.progressData.size}&quot;&#10;    )&#10;&#10;    // Animate the expansion/collapse&#10;    LaunchedEffect(isExpanded) {&#10;        Log.d(&quot;PerformanceScreen&quot;, &quot;Animating card expansion: ${exerciseName} to ${if (isExpanded) &quot;expanded&quot; else &quot;collapsed&quot;}&quot;)&#10;        expandTransition.animateTo(&#10;            targetValue = if (isExpanded) 1f else 0f,&#10;            animationSpec = tween(300)&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .animateContentSize(&#10;                animationSpec = spring(&#10;                    dampingRatio = Spring.DampingRatioMediumBouncy,&#10;                    stiffness = Spring.StiffnessLow&#10;                )&#10;            ),&#10;        shape = MaterialTheme.shapes.medium,&#10;        elevation = CardDefaults.cardElevation(&#10;            defaultElevation = 2.dp&#10;        )&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            // Exercise header (always visible)&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .clickable { onToggleExpanded() },&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = performance.exercise.name,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Icon(&#10;                    imageVector = if (isExpanded) Icons.Filled.ArrowDropDown else Icons.AutoMirrored.Filled.ArrowRight,&#10;                    contentDescription = if (isExpanded) &quot;Collapse&quot; else &quot;Expand&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.rotate(expandTransition.value * 180f)&#10;                )&#10;            }&#10;&#10;            // Performance details (only visible when expanded)&#10;            AnimatedVisibility(&#10;                visible = isExpanded,&#10;                enter = fadeIn() + expandVertically(),&#10;                exit = fadeOut() + shrinkVertically()&#10;            ) {&#10;                Column(modifier = Modifier.padding(top = 16.dp)) {&#10;                    // Performance visualization with tabs&#10;                    var selectedTabIndex by remember { mutableStateOf(0) }&#10;&#10;                    PerformanceTabRow(&#10;                        selectedTabIndex = selectedTabIndex,&#10;                        onTabSelected = { selectedTabIndex = it }&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    // Show the appropriate chart based on the selected tab&#10;                    PerformanceChart(&#10;                        progressPoints = performance.progressData,&#10;                        chartType = when (selectedTabIndex) {&#10;                            0 -&gt; ChartType.WEIGHT&#10;                            1 -&gt; ChartType.REPS&#10;                            else -&gt; ChartType.VOLUME&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(200.dp)&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    // Progress summary&#10;                    ProgressSummaryCard(performance = performance)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Card displaying a summary of progress metrics&#10; */&#10;@Composable&#10;fun ProgressSummaryCard(performance: ExercisePerformance) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        shape = MaterialTheme.shapes.medium,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.7f)&#10;        )&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Progress Summary&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceAround&#10;            ) {&#10;                MetricItem(&#10;                    label = &quot;Max Weight&quot;,&#10;                    value = &quot;${performance.maxWeight} kg&quot;,&#10;                    icon = Icons.Default.FitnessCenter&#10;                )&#10;                MetricItem(&#10;                    label = &quot;Max Reps&quot;,&#10;                    value = &quot;${performance.maxReps}&quot;,&#10;                    icon = Icons.Default.Numbers&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceAround&#10;            ) {&#10;                val volumeProgress = performance.volumeProgress&#10;                val weightProgress = performance.weightProgress&#10;&#10;                // Calculate rep progress - similar to how weight progress is calculated&#10;                // Can be 0 if there's only one data point&#10;                val repProgress = if (performance.progressData.size &gt;= 2) {&#10;                    val firstReps = performance.progressData.first().reps&#10;                    val lastReps = performance.progressData.last().reps&#10;                    if (firstReps &gt; 0) {&#10;                        ((lastReps - firstReps).toFloat() / firstReps * 100f)&#10;                    } else 0f&#10;                } else 0f&#10;&#10;                ProgressMetricItem(&#10;                    label = &quot;Rep Progress&quot;,&#10;                    value = &quot;${String.format(java.util.Locale.US, &quot;%.1f&quot;, repProgress)}%&quot;,&#10;                    progress = repProgress / 100f,&#10;                    icon = Icons.AutoMirrored.Filled.TrendingUp&#10;                )&#10;&#10;                ProgressMetricItem(&#10;                    label = &quot;Weight Progress&quot;,&#10;                    value = &quot;${String.format(java.util.Locale.US, &quot;%.1f&quot;, weightProgress)}%&quot;,&#10;                    progress = weightProgress / 100f,&#10;                    icon = Icons.AutoMirrored.Filled.TrendingUp&#10;                )&#10;&#10;                ProgressMetricItem(&#10;                    label = &quot;Volume Progress&quot;,&#10;                    value = &quot;${String.format(java.util.Locale.US, &quot;%.1f&quot;, volumeProgress)}%&quot;,&#10;                    progress = volumeProgress / 100f,&#10;                    icon = Icons.AutoMirrored.Filled.TrendingUp&#10;                )&#10;            }&#10;&#10;            if (performance.sessionsCount &gt; 0) {&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = &quot;Based on ${performance.sessionsCount} training sessions&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Single metric item display with icon&#10; */&#10;@Composable&#10;fun MetricItem(label: String, value: String, icon: ImageVector) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.padding(horizontal = 8.dp)&#10;    ) {&#10;        Icon(&#10;            imageVector = icon,&#10;            contentDescription = null,&#10;            tint = MaterialTheme.colorScheme.primary,&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;        Text(&#10;            text = value,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onSurface&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Progress metric item with progress indicator&#10; */&#10;@Composable&#10;fun ProgressMetricItem(label: String, value: String, progress: Float, icon: ImageVector) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.padding(horizontal = 8.dp)&#10;    ) {&#10;        val progressColor = when {&#10;            progress &gt; 0 -&gt; MaterialTheme.colorScheme.primary&#10;            progress &lt; 0 -&gt; Color.Red&#10;            else -&gt; MaterialTheme.colorScheme.onSurfaceVariant&#10;        }&#10;&#10;        Icon(&#10;            imageVector = icon,&#10;            contentDescription = null,&#10;            tint = progressColor,&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;&#10;        Text(&#10;            text = if (progress == 0f &amp;&amp; value == &quot;0.0%&quot;) &quot;--&quot; else value,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = progressColor&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(2.dp))&#10;&#10;        // Small progress indicator - only show if there's actual progress&#10;        if (progress != 0f || value != &quot;0.0%&quot;) {&#10;            LinearProgressIndicator(&#10;                progress = { progress.absoluteValue.coerceIn(0f, 1f) },&#10;                color = progressColor,&#10;                trackColor = MaterialTheme.colorScheme.surfaceVariant,&#10;                modifier = Modifier&#10;                    .width(60.dp)&#10;                    .height(3.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_history.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_history.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M13,3c-4.97,0 -9,4.03 -9,9L1,12l3.89,3.89 0.07,0.14L9,12L6,12c0,-3.87 3.13,-7 7,-7s7,3.13 7,7 -3.13,7 -7,7c-1.93,0 -3.68,-0.79 -4.94,-2.06l-1.42,1.42C8.27,19.99 10.51,21 13,21c4.97,0 9,-4.03 9,-9s-4.03,-9 -9,-9zM12,8v5l4.28,2.54 0.72,-1.21 -3.5,-2.08L13.5,8L12,8z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_home.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_home.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M10,20v-6h4v6h5v-8h3L12,3 2,12h3v8z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_performance.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_performance.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M19,3L5,3c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2L21,5c0,-1.1 -0.9,-2 -2,-2zM9,17L7,17v-7h2v7zM13,17h-2L11,7h2v10zM17,17h-2v-4h2v4z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_settings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_settings.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M19.14,12.94c0.04,-0.3 0.06,-0.61 0.06,-0.94c0,-0.32 -0.02,-0.64 -0.07,-0.94l2.03,-1.58c0.18,-0.14 0.23,-0.41 0.12,-0.61l-1.92,-3.32c-0.12,-0.22 -0.37,-0.29 -0.59,-0.22l-2.39,0.96c-0.5,-0.38 -1.03,-0.7 -1.62,-0.94L14.4,2.81c-0.04,-0.24 -0.24,-0.41 -0.48,-0.41h-3.84c-0.24,0 -0.43,0.17 -0.47,0.41L9.25,5.35C8.66,5.59 8.12,5.92 7.63,6.29L5.24,5.33c-0.22,-0.08 -0.47,0 -0.59,0.22L2.74,8.87C2.62,9.08 2.66,9.34 2.86,9.48l2.03,1.58C4.84,11.36 4.8,11.69 4.8,12s0.02,0.64 0.07,0.94l-2.03,1.58c-0.18,0.14 -0.23,0.41 -0.12,0.61l1.92,3.32c0.12,0.22 0.37,0.29 0.59,0.22l2.39,-0.96c0.5,0.38 1.03,0.7 1.62,0.94l0.36,2.54c0.05,0.24 0.24,0.41 0.48,0.41h3.84c0.24,0 0.44,-0.17 0.47,-0.41l0.36,-2.54c0.59,-0.24 1.13,-0.56 1.62,-0.94l2.39,0.96c0.22,0.08 0.47,0 0.59,-0.22l1.92,-3.32c0.12,-0.22 0.07,-0.47 -0.12,-0.61L19.14,12.94zM12,15.6c-1.98,0 -3.6,-1.62 -3.6,-3.6s1.62,-3.6 3.6,-3.6s3.6,1.62 3.6,3.6S13.98,15.6 12,15.6z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>