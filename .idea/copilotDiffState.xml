<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/MIGRATION_ROADMAP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MIGRATION_ROADMAP.md" />
              <option name="originalContent" value="# ️ PPL Workout App - Migration Roadmap&#10;&#10;## Overview&#10;This document outlines the migration path from the current simplified architecture to the advanced, production-ready architecture shown in the database and workflow diagrams.&#10;&#10;## Current State Analysis ✅&#10;&#10;### Database Schema (Working) - Version 7&#10;- [x] **exercises** table: Enhanced with rich metadata (primaryMuscle, secondaryMuscles, equipment, difficulty, instructions, tips, category) ✅&#10;- [x] **workout_days** table: Stores daily workout sessions ✅&#10;- [x] **workout_entries** table: Links exercises to workout days ✅&#10;- [x] **set_entries** table: Individual set tracking with timing ✅&#10;- [x] **workout_templates** table: Template definitions for reusable workouts ✅&#10;- [x] **template_exercises** table: Junction table linking templates to exercises ✅&#10;&#10;### Features Working ✅&#10;- [x] PPL workout creation based on day of week&#10;- [x] **Template-based workout creation system** ✅&#10;- [x] Exercise detail screens with set progression&#10;- [x] Individual set timing and completion tracking&#10;- [x] Cross-exercise contamination fixed (sets isolated per exercise)&#10;- [x] Database reset functionality for development&#10;- [x] Timer functionality with start/stop per set&#10;- [x] Enhanced exercise library with rich metadata (34+ exercises)&#10;- [x] Automatic template population on database creation&#10;- [x] Template selection and creation methods&#10;&#10;### Current Architecture Status&#10;- **Exercise Library**: Rich metadata with 34+ exercises in `ExerciseData.getPPLExercises()` ✅&#10;- **Template System**: Complete entities, DAOs, and repository methods ✅&#10;- **Workout Logic**: **Both day-based AND template-based systems working** ✅&#10;- **Database Version**: 7 (with complete template system migration)&#10;- **UI Layer**: Daily workout screens with template integration ✅&#10;&#10;---&#10;&#10;## Phase 1: Enhanced Exercise Library &amp; Templates ✅ **COMPLETED**&#10;&#10;### 1.1 Enhance Exercise Entity ✅ **COMPLETED**&#10;- [x] **1.1.1** Expanded Exercise entity with additional fields ✅&#10;- [x] **1.1.2** Created database migration (Version 5 → 6) ✅&#10;- [x] **1.1.3** Updated exercise data with rich metadata ✅&#10;&#10;### 1.2 Create Workout Templates System ✅ **COMPLETED**&#10;- [x] **1.2.1** Created WorkoutTemplate entity ✅&#10;- [x] **1.2.2** Created TemplateExercise junction entity ✅&#10;- [x] **1.2.3** Created corresponding DAOs (WorkoutTemplateDao, TemplateExerciseDao) ✅&#10;- [x] **1.2.4** Updated database schema (Version 6 → 7) ✅&#10;- [x] **1.2.5** Created PPL template data with 6 predefined templates ✅&#10;&#10;### 1.3 Implement Template-Based Workout Creation ✅ **COMPLETED**&#10;**Goal**: Replace current day-based workout creation with template selection&#10;&#10;#### Tasks:&#10;- [x] **1.3.1** Update Repository to use templates ✅ **COMPLETED**&#10;  ```kotlin&#10;  suspend fun createWorkoutFromTemplate(templateId: Int, date: String): List&lt;WorkoutEntry&gt;&#10;  suspend fun createTodaysWorkoutFromTemplate(): Flow&lt;List&lt;WorkoutEntryWithExercise&gt;&gt;&#10;  fun getAvailableTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;  fun getTemplatesByCategory(category: String): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;  ```&#10;&#10;- [x] **1.3.2** Populate templates in database on first run ✅ **COMPLETED**&#10;  - Created PPLTemplateData.kt with 6 predefined PPL workout templates&#10;  - Added template-exercise relationships with proper sets, reps, and rest periods&#10;  - Includes helper functions for day-based compatibility&#10;  - Auto-population on database creation&#10;&#10;- [x] **1.3.3** Update ViewModel to use template-based creation ✅ **COMPLETED**&#10;  - Added `createWorkoutFromTemplate(templateId: Int, date: String)` method&#10;  - Integrated template selection logic&#10;  - Maintains backward compatibility with day-based creation&#10;&#10;- [x] **1.3.4** Migrate from day-based to template-based workout creation ✅ **COMPLETED**&#10;  - Both systems working in parallel&#10;  - Template-based system handles PPL schedule automatically&#10;  - Legacy day-based methods preserved for compatibility&#10;&#10;- [x] **1.3.5** Update UI to show template selection ✅ **COMPLETED**&#10;  - Created comprehensive TemplateSelectionScreen with Material 3 design&#10;  - Added template cards with category colors (Push/Pull/Legs)&#10;  - Integrated difficulty indicators (Beginner/Intermediate/Advanced)&#10;  - Updated StartWorkoutScreen with dual options:&#10;    - &quot;Start Today's Workout&quot; (automatic template selection)&#10;    - &quot;Choose Different Workout&quot; (manual template selection)&#10;  - Implemented seamless navigation between screens&#10;  - Template metadata display (duration, exercise count, last used date)&#10;  - Added &quot;Change Template&quot; button to exercise list screen for easy access&#10;&#10;---&#10;&#10;##  **HOTFIX SECTION - Critical Usability Issues**&#10;&#10;Before proceeding to Phase 2, we need to address critical usability issues identified during Phase 1 testing:&#10;&#10;### HF.1 Exercise Detail Screen UX Issues ✅ **COMPLETED**&#10;- [x] **HF.1.1** Remove confusing &quot;Mark as Done&quot; button - simplify to Start/Stop workflow ✅&#10;- [x] **HF.1.2** Implement proper Start → Stop → Complete workflow for sets ✅&#10;  - User clicks &quot;Start&quot; → Timer begins, button becomes &quot;Complete Set&quot;&#10;  - User clicks &quot;Complete Set&quot; → Timer stops, set marked as completed automatically&#10;  - No separate &quot;Mark as Done&quot; button needed&#10;&#10;### HF.2 WorkoutTimer Implementation Issues ✅ **COMPLETED**  &#10;- [x] **HF.2.1** Fix timer display format to proper HH:MM:SS format ✅&#10;- [x] **HF.2.2** Fix timer counting logic (was accelerating: 1s→3s→6s→10s) ✅&#10;- [x] **HF.2.3** Ensure proper second-by-second counting (00:00:01, 00:00:02, etc.) ✅&#10;- [x] **HF.2.4** Test timer accuracy and visual updates ✅&#10;- [x] **HF.2.5** Fix ExerciseDetailScreen timer display (was showing 42:13:20 instead of 02:32) ✅&#10;- [x] **HF.2.6** Fix total exercise time display (was showing 24:10:00 instead of 00:22) ✅&#10;- [x] **HF.2.7** Fix total time live updates (should only update when sets complete, not during timer) ✅&#10;- [x] **HF.2.8** Fix timer double-counting issue (30 seconds saved as 60 seconds in database) ✅&#10;&#10;**Timer Fix Details:**&#10;- Fixed timer acceleration: Removed double-addition in ViewModel (`timer.elapsedTime + calculated_time`)&#10;- Fixed unit conversion: Added milliseconds to seconds conversion in UI (`totalExerciseTime / 1000`)&#10;- Fixed total time behavior: Total now only includes completed sets, not running timers&#10;- Fixed double-counting: Removed duplicate elapsed time calculation in `stopSetTimer()`&#10;- Timer now works like proper stopwatch: 1s → 2s → 3s → 4s (linear counting)&#10;- Total time displays correctly: 22 seconds = `00:22`, not `06:06:40`&#10;- Live timer and stored database values now match exactly&#10;&#10;### HF.3 Set Progression Flow ✅ **COMPLETED**&#10;- [x] **HF.3.1** Simplify set completion to single Start/Stop action ✅&#10;- [x] **HF.3.2** Remove redundant UI elements that confuse the workflow ✅&#10;- [x] **HF.3.3** Ensure clean progression: Start Set → Complete Set → Next Set ✅&#10;&#10;**Priority**: These hotfixes must be completed before Phase 2 to ensure good user experience foundation.&#10;&#10;---&#10;&#10;## Phase 2: Enhanced User Interface &amp; User Experience  **IN PROGRESS**&#10;&#10;### 2.1 Template Selection UI ✅ **COMPLETED**&#10;- [x] **2.1.1** Create template selection screen ✅ **COMPLETED**&#10;- [x] **2.1.2** Add template preview with exercise list ✅ **COMPLETED**  &#10;- [x] **2.1.3** Allow manual template override for any day ✅ **COMPLETED**&#10;- [x] **2.1.4** Show template categories (Push/Pull/Legs) ✅ **COMPLETED**&#10;- [x] **2.1.5** Display template metadata (duration, difficulty, last used) ✅ **COMPLETED**&#10;&#10;### 2.2 Enhanced Exercise Experience ⭐ **NEXT PRIORITY**&#10;- [ ] **2.2.1** Add exercise instruction screens&#10;- [ ] **2.2.2** Include exercise tips and form cues&#10;- [ ] **2.2.3** Show primary/secondary muscle groups&#10;- [ ] **2.2.4** Equipment requirements display&#10;- [ ] **2.2.5** Exercise difficulty indicators&#10;&#10;### 2.3 Workout Flow Improvements&#10;- [ ] **2.3.1** Rest timer between sets&#10;- [ ] **2.3.2** Workout session summary&#10;- [ ] **2.3.3** Progress celebration animations&#10;- [ ] **2.3.4** Quick workout restart option&#10;&#10;---&#10;&#10;## Phase 3: Progress Tracking &amp; Analytics &#10;&#10;### 3.1 Progress Tracking&#10;- [ ] Create PersonalRecord entity for 1RM tracking&#10;- [ ] Implement weight progression suggestions&#10;- [ ] Add exercise history graphs&#10;- [ ] Weekly/monthly progress reports&#10;&#10;### 3.2 Custom Workouts&#10;- [ ] Allow users to create custom templates&#10;- [ ] Exercise substitution system&#10;- [ ] Workout sharing functionality&#10;- [ ] Template import/export&#10;&#10;### 3.3 Analytics &amp; Insights&#10;- [ ] Training volume analytics&#10;- [ ] Muscle group balance analysis&#10;- [ ] Workout consistency tracking&#10;- [ ] Performance trend analysis&#10;&#10;---&#10;&#10;## Phase 4: Production Ready &#10;&#10;### 4.1 Performance Optimization&#10;- [ ] Database indexing optimization&#10;- [ ] LazyColumn performance improvements&#10;- [ ] Background data sync&#10;- [ ] Memory usage optimization&#10;&#10;### 4.2 User Experience Polish&#10;- [ ] Onboarding flow&#10;- [ ] Exercise video/animation support&#10;- [ ] Dark mode theme improvements&#10;- [ ] Accessibility improvements&#10;&#10;### 4.3 Data Management&#10;- [ ] Export/import functionality&#10;- [ ] Cloud backup integration&#10;- [ ] Data migration between devices&#10;- [ ] Offline-first architecture&#10;&#10;---&#10;&#10;## Development Notes &#10;&#10;### Recently Fixed Issues ✅&#10;- Cross-exercise set contamination (sets now properly isolated per exercise)&#10;- Timer functionality working correctly per set&#10;- Database foreign key constraints resolved&#10;- Set progression logic working properly&#10;- Exercise detail screen navigation fixed&#10;&#10;### Current Technical Debt&#10;- Both day-based and template-based systems running in parallel&#10;- Manual template selection UI not implemented&#10;- Some hardcoded workout logic still present&#10;&#10;### Next Immediate Tasks&#10;1. **Template Selection UI** - Allow users to manually choose templates&#10;2. **Exercise Enhancement** - Show rich metadata in UI&#10;3. **Workout Flow Polish** - Improve user experience during workouts&#10;&#10;### Architecture Status&#10;- ✅ **Database Layer**: Complete with template system&#10;- ✅ **Repository Layer**: Full template support implemented  &#10;- ✅ **ViewModel Layer**: Template integration complete&#10;-  **UI Layer**: Basic template support, selection UI pending&#10;-  **User Experience**: Core functionality working, polish needed&#10;" />
              <option name="updatedContent" value="# ️ PPL Workout App - Migration Roadmap&#10;&#10;## Overview&#10;This document outlines the migration path from the current simplified architecture to the advanced, production-ready architecture shown in the database and workflow diagrams.&#10;&#10;## Current State Analysis ✅&#10;&#10;### Database Schema (Working) - Version 7&#10;- [x] **exercises** table: Enhanced with rich metadata (primaryMuscle, secondaryMuscles, equipment, difficulty, instructions, tips, category) ✅&#10;- [x] **workout_days** table: Stores daily workout sessions ✅&#10;- [x] **workout_entries** table: Links exercises to workout days ✅&#10;- [x] **set_entries** table: Individual set tracking with timing ✅&#10;- [x] **workout_templates** table: Template definitions for reusable workouts ✅&#10;- [x] **template_exercises** table: Junction table linking templates to exercises ✅&#10;&#10;### Features Working ✅&#10;- [x] PPL workout creation based on day of week&#10;- [x] **Template-based workout creation system** ✅&#10;- [x] Exercise detail screens with set progression&#10;- [x] Individual set timing and completion tracking&#10;- [x] Cross-exercise contamination fixed (sets isolated per exercise)&#10;- [x] Database reset functionality for development&#10;- [x] Timer functionality with start/stop per set&#10;- [x] Enhanced exercise library with rich metadata (34+ exercises)&#10;- [x] Automatic template population on database creation&#10;- [x] Template selection and creation methods&#10;&#10;### Current Architecture Status&#10;- **Exercise Library**: Rich metadata with 34+ exercises in `ExerciseData.getPPLExercises()` ✅&#10;- **Template System**: Complete entities, DAOs, and repository methods ✅&#10;- **Workout Logic**: **Both day-based AND template-based systems working** ✅&#10;- **Database Version**: 7 (with complete template system migration)&#10;- **UI Layer**: Daily workout screens with template integration ✅&#10;&#10;---&#10;&#10;## Phase 1: Enhanced Exercise Library &amp; Templates ✅ **COMPLETED**&#10;&#10;### 1.1 Enhance Exercise Entity ✅ **COMPLETED**&#10;- [x] **1.1.1** Expanded Exercise entity with additional fields ✅&#10;- [x] **1.1.2** Created database migration (Version 5 → 6) ✅&#10;- [x] **1.1.3** Updated exercise data with rich metadata ✅&#10;&#10;### 1.2 Create Workout Templates System ✅ **COMPLETED**&#10;- [x] **1.2.1** Created WorkoutTemplate entity ✅&#10;- [x] **1.2.2** Created TemplateExercise junction entity ✅&#10;- [x] **1.2.3** Created corresponding DAOs (WorkoutTemplateDao, TemplateExerciseDao) ✅&#10;- [x] **1.2.4** Updated database schema (Version 6 → 7) ✅&#10;- [x] **1.2.5** Created PPL template data with 6 predefined templates ✅&#10;&#10;### 1.3 Implement Template-Based Workout Creation ✅ **COMPLETED**&#10;**Goal**: Replace current day-based workout creation with template selection&#10;&#10;#### Tasks:&#10;- [x] **1.3.1** Update Repository to use templates ✅ **COMPLETED**&#10;  ```kotlin&#10;  suspend fun createWorkoutFromTemplate(templateId: Int, date: String): List&lt;WorkoutEntry&gt;&#10;  suspend fun createTodaysWorkoutFromTemplate(): Flow&lt;List&lt;WorkoutEntryWithExercise&gt;&gt;&#10;  fun getAvailableTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;  fun getTemplatesByCategory(category: String): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;  ```&#10;&#10;- [x] **1.3.2** Populate templates in database on first run ✅ **COMPLETED**&#10;  - Created PPLTemplateData.kt with 6 predefined PPL workout templates&#10;  - Added template-exercise relationships with proper sets, reps, and rest periods&#10;  - Includes helper functions for day-based compatibility&#10;  - Auto-population on database creation&#10;&#10;- [x] **1.3.3** Update ViewModel to use template-based creation ✅ **COMPLETED**&#10;  - Added `createWorkoutFromTemplate(templateId: Int, date: String)` method&#10;  - Integrated template selection logic&#10;  - Maintains backward compatibility with day-based creation&#10;&#10;- [x] **1.3.4** Migrate from day-based to template-based workout creation ✅ **COMPLETED**&#10;  - Both systems working in parallel&#10;  - Template-based system handles PPL schedule automatically&#10;  - Legacy day-based methods preserved for compatibility&#10;&#10;- [x] **1.3.5** Update UI to show template selection ✅ **COMPLETED**&#10;  - Created comprehensive TemplateSelectionScreen with Material 3 design&#10;  - Added template cards with category colors (Push/Pull/Legs)&#10;  - Integrated difficulty indicators (Beginner/Intermediate/Advanced)&#10;  - Updated StartWorkoutScreen with dual options:&#10;    - &quot;Start Today's Workout&quot; (automatic template selection)&#10;    - &quot;Choose Different Workout&quot; (manual template selection)&#10;  - Implemented seamless navigation between screens&#10;  - Template metadata display (duration, exercise count, last used date)&#10;  - Added &quot;Change Template&quot; button to exercise list screen for easy access&#10;&#10;### 1.4 Rest Timer Between Sets  **NEXT PRIORITY**&#10;**Goal**: Add automatic rest timer functionality to improve workout flow and timing accuracy&#10;&#10;#### Tasks:&#10;- [ ] **1.4.1** Add rest timer UI component to ExerciseDetailScreen&#10;  - Position timer at top of screen with &quot;Rest&quot; label&#10;  - Use same visual design as set timers for consistency&#10;  - Show countdown format (e.g., &quot;Rest: 02:30&quot; counting down)&#10;&#10;- [ ] **1.4.2** Implement rest timer logic in ExerciseDetailViewModel&#10;  - Start rest timer automatically when user completes a set&#10;  - Stop rest timer when user starts next set&#10;  - Add rest time to total exercise time calculation&#10;  - Reset rest timer to 0 when next set begins&#10;&#10;- [ ] **1.4.3** Update total time calculation to include rest periods&#10;  - Total time = completed set times + rest period times&#10;  - Ensure rest time is added to database for accurate tracking&#10;  - Update UI display to reflect total workout time including rest&#10;&#10;- [ ] **1.4.4** Add rest timer configuration&#10;  - Default rest periods based on exercise type (e.g., 90s for compounds, 60s for accessories)&#10;  - Allow manual rest timer adjustment (optional future enhancement)&#10;  - Rest timer visual feedback (color changes, progress indicators)&#10;&#10;- [ ] **1.4.5** Enhance workout flow with rest timer&#10;  - Visual indication when rest period is complete&#10;  - Optional notification/vibration when rest is over&#10;  - Smooth transition from rest timer to next set timer&#10;&#10;**User Flow Enhancement**:&#10;1. User completes Set 1 → Rest timer starts automatically (e.g., 90 seconds)&#10;2. Rest timer counts up: &quot;Rest: 00:30&quot;, &quot;Rest: 01:00&quot;, &quot;Rest: 01:30&quot;...&#10;3. User starts Set 2 → Rest timer stops, rest time added to total time, timer resets to 0&#10;4. Process repeats for each set completion&#10;&#10;**Benefits**:&#10;- Accurate total workout time tracking (including rest periods)&#10;- Better workout pacing and consistency&#10;- Professional gym timer experience&#10;- Improved workout data for analytics&#10;&#10;---&#10;&#10;##  **HOTFIX SECTION - Critical Usability Issues**&#10;&#10;Before proceeding to Phase 2, we need to address critical usability issues identified during Phase 1 testing:&#10;&#10;### HF.1 Exercise Detail Screen UX Issues ✅ **COMPLETED**&#10;- [x] **HF.1.1** Remove confusing &quot;Mark as Done&quot; button - simplify to Start/Stop workflow ✅&#10;- [x] **HF.1.2** Implement proper Start → Stop → Complete workflow for sets ✅&#10;  - User clicks &quot;Start&quot; → Timer begins, button becomes &quot;Complete Set&quot;&#10;  - User clicks &quot;Complete Set&quot; → Timer stops, set marked as completed automatically&#10;  - No separate &quot;Mark as Done&quot; button needed&#10;&#10;### HF.2 WorkoutTimer Implementation Issues ✅ **COMPLETED**  &#10;- [x] **HF.2.1** Fix timer display format to proper HH:MM:SS format ✅&#10;- [x] **HF.2.2** Fix timer counting logic (was accelerating: 1s→3s→6s→10s) ✅&#10;- [x] **HF.2.3** Ensure proper second-by-second counting (00:00:01, 00:00:02, etc.) ✅&#10;- [x] **HF.2.4** Test timer accuracy and visual updates ✅&#10;- [x] **HF.2.5** Fix ExerciseDetailScreen timer display (was showing 42:13:20 instead of 02:32) ✅&#10;- [x] **HF.2.6** Fix total exercise time display (was showing 24:10:00 instead of 00:22) ✅&#10;- [x] **HF.2.7** Fix total time live updates (should only update when sets complete, not during timer) ✅&#10;- [x] **HF.2.8** Fix timer double-counting issue (30 seconds saved as 60 seconds in database) ✅&#10;&#10;**Timer Fix Details:**&#10;- Fixed timer acceleration: Removed double-addition in ViewModel (`timer.elapsedTime + calculated_time`)&#10;- Fixed unit conversion: Added milliseconds to seconds conversion in UI (`totalExerciseTime / 1000`)&#10;- Fixed total time behavior: Total now only includes completed sets, not running timers&#10;- Fixed double-counting: Removed duplicate elapsed time calculation in `stopSetTimer()`&#10;- Timer now works like proper stopwatch: 1s → 2s → 3s → 4s (linear counting)&#10;- Total time displays correctly: 22 seconds = `00:22`, not `06:06:40`&#10;- Live timer and stored database values now match exactly&#10;&#10;### HF.3 Set Progression Flow ✅ **COMPLETED**&#10;- [x] **HF.3.1** Simplify set completion to single Start/Stop action ✅&#10;- [x] **HF.3.2** Remove redundant UI elements that confuse the workflow ✅&#10;- [x] **HF.3.3** Ensure clean progression: Start Set → Complete Set → Next Set ✅&#10;&#10;**Priority**: These hotfixes must be completed before Phase 2 to ensure good user experience foundation.&#10;&#10;---&#10;&#10;## Phase 2: Enhanced User Interface &amp; User Experience  **IN PROGRESS**&#10;&#10;### 2.1 Template Selection UI ✅ **COMPLETED**&#10;- [x] **2.1.1** Create template selection screen ✅ **COMPLETED**&#10;- [x] **2.1.2** Add template preview with exercise list ✅ **COMPLETED**  &#10;- [x] **2.1.3** Allow manual template override for any day ✅ **COMPLETED**&#10;- [x] **2.1.4** Show template categories (Push/Pull/Legs) ✅ **COMPLETED**&#10;- [x] **2.1.5** Display template metadata (duration, difficulty, last used) ✅ **COMPLETED**&#10;&#10;### 2.2 Enhanced Exercise Experience ⭐ **NEXT PRIORITY**&#10;- [ ] **2.2.1** Add exercise instruction screens&#10;- [ ] **2.2.2** Include exercise tips and form cues&#10;- [ ] **2.2.3** Show primary/secondary muscle groups&#10;- [ ] **2.2.4** Equipment requirements display&#10;- [ ] **2.2.5** Exercise difficulty indicators&#10;&#10;### 2.3 Workout Flow Improvements&#10;- [ ] **2.3.1** Rest timer between sets&#10;- [ ] **2.3.2** Workout session summary&#10;- [ ] **2.3.3** Progress celebration animations&#10;- [ ] **2.3.4** Quick workout restart option&#10;&#10;---&#10;&#10;## Phase 3: Progress Tracking &amp; Analytics &#10;&#10;### 3.1 Progress Tracking&#10;- [ ] Create PersonalRecord entity for 1RM tracking&#10;- [ ] Implement weight progression suggestions&#10;- [ ] Add exercise history graphs&#10;- [ ] Weekly/monthly progress reports&#10;&#10;### 3.2 Custom Workouts&#10;- [ ] Allow users to create custom templates&#10;- [ ] Exercise substitution system&#10;- [ ] Workout sharing functionality&#10;- [ ] Template import/export&#10;&#10;### 3.3 Analytics &amp; Insights&#10;- [ ] Training volume analytics&#10;- [ ] Muscle group balance analysis&#10;- [ ] Workout consistency tracking&#10;- [ ] Performance trend analysis&#10;&#10;---&#10;&#10;## Phase 4: Production Ready &#10;&#10;### 4.1 Performance Optimization&#10;- [ ] Database indexing optimization&#10;- [ ] LazyColumn performance improvements&#10;- [ ] Background data sync&#10;- [ ] Memory usage optimization&#10;&#10;### 4.2 User Experience Polish&#10;- [ ] Onboarding flow&#10;- [ ] Exercise video/animation support&#10;- [ ] Dark mode theme improvements&#10;- [ ] Accessibility improvements&#10;&#10;### 4.3 Data Management&#10;- [ ] Export/import functionality&#10;- [ ] Cloud backup integration&#10;- [ ] Data migration between devices&#10;- [ ] Offline-first architecture&#10;&#10;---&#10;&#10;## Development Notes &#10;&#10;### Recently Fixed Issues ✅&#10;- Cross-exercise set contamination (sets now properly isolated per exercise)&#10;- Timer functionality working correctly per set&#10;- Database foreign key constraints resolved&#10;- Set progression logic working properly&#10;- Exercise detail screen navigation fixed&#10;&#10;### Current Technical Debt&#10;- Both day-based and template-based systems running in parallel&#10;- Manual template selection UI not implemented&#10;- Some hardcoded workout logic still present&#10;&#10;### Next Immediate Tasks&#10;1. **Template Selection UI** - Allow users to manually choose templates&#10;2. **Exercise Enhancement** - Show rich metadata in UI&#10;3. **Workout Flow Polish** - Improve user experience during workouts&#10;&#10;### Architecture Status&#10;- ✅ **Database Layer**: Complete with template system&#10;- ✅ **Repository Layer**: Full template support implemented  &#10;- ✅ **ViewModel Layer**: Template integration complete&#10;-  **UI Layer**: Basic template support, selection UI pending&#10;-  **User Experience**: Core functionality working, polish needed" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/dao/WorkoutTemplateDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/dao/WorkoutTemplateDao.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.dao&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.Query&#10;import androidx.room.Update&#10;import androidx.room.Delete&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; * Data Access Object for WorkoutTemplate operations&#10; */&#10;@Dao&#10;interface WorkoutTemplateDao {&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE isActive = 1 ORDER BY category, name&quot;)&#10;    fun getAllActiveTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE category = :category AND isActive = 1 ORDER BY name&quot;)&#10;    fun getTemplatesByCategory(category: String): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE id = :templateId&quot;)&#10;    suspend fun getTemplateById(templateId: Int): WorkoutTemplate?&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE category = :category AND difficulty = :difficulty AND isActive = 1&quot;)&#10;    suspend fun getTemplatesByCategoryAndDifficulty(category: String, difficulty: String): List&lt;WorkoutTemplate&gt;&#10;&#10;    @Insert&#10;    suspend fun insertTemplate(template: WorkoutTemplate): Long&#10;&#10;    @Insert&#10;    suspend fun insertTemplates(templates: List&lt;WorkoutTemplate&gt;)&#10;&#10;    @Update&#10;    suspend fun updateTemplate(template: WorkoutTemplate)&#10;&#10;    @Delete&#10;    suspend fun deleteTemplate(template: WorkoutTemplate)&#10;&#10;    @Query(&quot;DELETE FROM workout_templates&quot;)&#10;    suspend fun deleteAll(): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM workout_templates&quot;)&#10;    suspend fun getTemplateCount(): Int&#10;&#10;    @Query(&quot;UPDATE workout_templates SET lastUsedDate = :date WHERE id = :templateId&quot;)&#10;    suspend fun updateLastUsedDate(templateId: Int, date: String)&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE isCustom = 1 AND isActive = 1 ORDER BY name&quot;)&#10;    fun getCustomTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE isCustom = 0 AND isActive = 1 ORDER BY category, name&quot;)&#10;    fun getPredefinedTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/ExerciseDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/ExerciseDetailScreen.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.animation.*&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.delay&#10;import com.example.offlinepplworkoutapp.ui.theme.*&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModelFactory&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ExerciseDetailScreen(&#10;    workoutEntry: WorkoutEntryWithExercise,&#10;    repository: WorkoutRepository,&#10;    onBackClick: () -&gt; Unit,&#10;    onSaveChanges: (sets: Int, reps: Int, isCompleted: Boolean) -&gt; Unit&#10;) {&#10;    //  FIX: Add unique key to force new ViewModel creation for each exercise&#10;    val viewModel: ExerciseDetailViewModel = viewModel(&#10;        key = &quot;exercise_${workoutEntry.id}&quot;, // Unique key for each exercise&#10;        factory = ExerciseDetailViewModelFactory(workoutEntry, repository)&#10;    )&#10;&#10;    println(&quot; UI: Created ExerciseDetailViewModel for ${workoutEntry.exerciseName} (ID: ${workoutEntry.id})&quot;)&#10;&#10;    val setTimers by viewModel.setTimers.collectAsState()&#10;    val currentRunningSet by viewModel.currentRunningSet.collectAsState()&#10;    val totalExerciseTime by viewModel.totalExerciseTime.collectAsState()&#10;    val completedSets by viewModel.completedSets.collectAsState()&#10;    val isExerciseCompleted by viewModel.isExerciseCompleted.collectAsState()&#10;&#10;    val originalCompletionStatus = remember { workoutEntry.isCompleted }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = workoutEntry.exerciseName,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontSize = 22.sp,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = PrimaryCoral&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Sets: $completedSets/${workoutEntry.sets} • Total: ${formatTime(totalExerciseTime / 1000)}&quot;.also {&#10;                                println(&quot; UI DEBUG: Displaying total time - Raw: ${totalExerciseTime}ms, Converted: ${totalExerciseTime / 1000}s, Formatted: ${formatTime(totalExerciseTime / 1000)}&quot;)&#10;                            },&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontSize = 14.sp,&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = {&#10;                        val shouldMarkCompleted = isExerciseCompleted &amp;&amp; completedSets == workoutEntry.sets&#10;                        if (shouldMarkCompleted != originalCompletionStatus) {&#10;                            onSaveChanges(workoutEntry.sets, workoutEntry.reps, shouldMarkCompleted)&#10;                        }&#10;                        onBackClick()&#10;                    }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = PrimaryCoral&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = CardBackground&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(BackgroundLight)&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Exercise completion status with animation&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isExerciseCompleted,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    CompletionCard()&#10;                }&#10;            }&#10;&#10;            // Set cards with improved design&#10;            itemsIndexed(setTimers) { index, setTimer -&gt;&#10;                val activeSetIndex by viewModel.activeSetIndex.collectAsState()&#10;                ModernSetTimerCard(&#10;                    setNumber = index + 1,&#10;                    totalSets = workoutEntry.sets,&#10;                    targetReps = workoutEntry.reps,&#10;                    setTimer = setTimer.elapsedTime / 1000, //  FIXED: Convert milliseconds to seconds&#10;                    isCurrentSet = currentRunningSet == index,&#10;                    isCompleted = setTimer.isCompleted,&#10;                    isActive = index == activeSetIndex,&#10;                    isLocked = index &gt; activeSetIndex &amp;&amp; !setTimer.isCompleted,&#10;                    onStartTimer = { viewModel.startSetTimer(index) },&#10;                    onStopTimer = { viewModel.stopSetTimer(index) },&#10;                    onCompleteSet = { viewModel.completeSet(index) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CompletionCard() {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(8.dp, RoundedCornerShape(20.dp))&#10;            .clip(RoundedCornerShape(20.dp))&#10;            .background(&#10;                brush = Brush.horizontalGradient(&#10;                    colors = listOf(SuccessGreen, TealSecondary)&#10;                )&#10;            ),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Check,&#10;                contentDescription = &quot;Completed&quot;,&#10;                tint = TextOnPrimary,&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Text(&#10;                text = &quot;Exercise Completed! &quot;,&#10;                style = MaterialTheme.typography.titleLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextOnPrimary&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ModernSetTimerCard(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    targetReps: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean = false,&#10;    isActive: Boolean = false,&#10;    isLocked: Boolean = false,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onCompleteSet: () -&gt; Unit&#10;) {&#10;    // Animation for card state changes&#10;    val animatedElevation by animateDpAsState(&#10;        targetValue = when {&#10;            isCurrentSet -&gt; 12.dp&#10;            isActive -&gt; 6.dp&#10;            else -&gt; 2.dp&#10;        },&#10;        animationSpec = tween(300)&#10;    )&#10;&#10;    // Card colors based on state&#10;    val cardColors = when {&#10;        isCompleted -&gt; CardDefaults.cardColors(&#10;            containerColor = SuccessGreen.copy(alpha = 0.1f)&#10;        )&#10;        isCurrentSet -&gt; CardDefaults.cardColors(&#10;            containerColor = Color.Transparent&#10;        )&#10;        isActive -&gt; CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        )&#10;        isLocked -&gt; CardDefaults.cardColors(&#10;            containerColor = TextSecondary.copy(alpha = 0.05f)&#10;        )&#10;        else -&gt; CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(animatedElevation, RoundedCornerShape(16.dp))&#10;            .then(&#10;                if (isCurrentSet) {&#10;                    Modifier&#10;                        .border(&#10;                            width = 3.dp,&#10;                            brush = Brush.horizontalGradient(&#10;                                colors = listOf(ProgressStart, ProgressEnd)&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                        .background(&#10;                            brush = Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    ProgressStart.copy(alpha = 0.1f),&#10;                                    ProgressEnd.copy(alpha = 0.05f)&#10;                                )&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                } else {&#10;                    Modifier&#10;                }&#10;            ),&#10;        colors = cardColors,&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            // Set Header with improved typography&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Set status icon&#10;                    when {&#10;                        isCompleted -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isCurrentSet -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Active&quot;,&#10;                                tint = PrimaryCoral,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isLocked -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Lock,&#10;                                contentDescription = &quot;Locked&quot;,&#10;                                tint = TextSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        else -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.DateRange,&#10;                                contentDescription = &quot;Ready&quot;,&#10;                                tint = TealSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Set $setNumber of $totalSets&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontSize = 16.sp,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = when {&#10;                                isLocked -&gt; TextSecondary.copy(alpha = 0.6f)&#10;                                else -&gt; TextPrimary&#10;                            }&#10;                        )&#10;                    )&#10;                }&#10;&#10;                // Timer display with improved styling&#10;                TimerDisplay(&#10;                    time = setTimer,&#10;                    isActive = isCurrentSet,&#10;                    isCompleted = isCompleted&#10;                )&#10;            }&#10;&#10;            // Target reps info&#10;            Text(&#10;                text = &quot;Target: $targetReps reps&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    color = TextSecondary,&#10;                    fontSize = 14.sp&#10;                )&#10;            )&#10;&#10;            // Action buttons with modern design&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                when {&#10;                    isCompleted -&gt; {&#10;                        // Completed state - show success message&#10;                        Row(&#10;                            modifier = Modifier.weight(1f),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&#10;                                text = &quot;Set Completed&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    color = SuccessGreen,&#10;                                    fontWeight = FontWeight.Medium&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    isLocked -&gt; {&#10;                        // Locked state&#10;                        Text(&#10;                            text = &quot;Complete previous sets first&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                color = TextSecondary,&#10;                                fontStyle = androidx.compose.ui.text.font.FontStyle.Italic&#10;                            ),&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    }&#10;                    isCurrentSet -&gt; {&#10;                        //  FIXED: Simplified workflow - only Stop button that auto-completes the set&#10;                        Button(&#10;                            onClick = {&#10;                                onStopTimer() // Stop timer and auto-complete the set&#10;                                onCompleteSet() // Automatically mark as completed&#10;                            },&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = SuccessGreen&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Stop and Complete&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Complete Set&quot;)&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // Ready to start&#10;                        Button(&#10;                            onClick = onStartTimer,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = PrimaryCoral&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp),&#10;                            enabled = !isLocked&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Start&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Start Set&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimerDisplay(&#10;    time: Long,&#10;    isActive: Boolean,&#10;    isCompleted: Boolean&#10;) {&#10;    val textColor = when {&#10;        isCompleted -&gt; SuccessGreen&#10;        isActive -&gt; PrimaryCoral&#10;        else -&gt; TextSecondary&#10;    }&#10;&#10;    //  PROPER STOPWATCH: Start from stored time and count up properly&#10;    var displayTime by remember(time) { mutableStateOf(time) }&#10;&#10;    // Track when timer starts to calculate elapsed time properly&#10;    val startTimeRef = remember { mutableStateOf(0L) }&#10;&#10;    LaunchedEffect(isActive) {&#10;        if (isActive) {&#10;            // Record the actual start time when timer becomes active&#10;            startTimeRef.value = System.currentTimeMillis()&#10;&#10;            while (isActive) {&#10;                // Calculate elapsed seconds since timer started&#10;                val elapsedMs = System.currentTimeMillis() - startTimeRef.value&#10;                val elapsedSeconds = elapsedMs / 1000&#10;&#10;                // Display = stored time + elapsed time&#10;                displayTime = time + elapsedSeconds&#10;&#10;                delay(1000) // Update every second&#10;            }&#10;        } else {&#10;            // When not active, show the stored time from database&#10;            displayTime = time&#10;        }&#10;    }&#10;&#10;    Text(&#10;        text = formatTime(displayTime),&#10;        style = MaterialTheme.typography.titleLarge.copy(&#10;            fontSize = if (isActive) 20.sp else 18.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = textColor&#10;        )&#10;    )&#10;}&#10;&#10;private fun formatTime(timeInSeconds: Long): String {&#10;    val hours = timeInSeconds / 3600&#10;    val minutes = (timeInSeconds % 3600) / 60&#10;    val seconds = timeInSeconds % 60&#10;&#10;    return if (hours &gt; 0) {&#10;        String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds)&#10;    } else {&#10;        String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.animation.*&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.delay&#10;import com.example.offlinepplworkoutapp.ui.theme.*&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModelFactory&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ExerciseDetailScreen(&#10;    workoutEntry: WorkoutEntryWithExercise,&#10;    repository: WorkoutRepository,&#10;    onBackClick: () -&gt; Unit,&#10;    onSaveChanges: (sets: Int, reps: Int, isCompleted: Boolean) -&gt; Unit&#10;) {&#10;    //  FIX: Add unique key to force new ViewModel creation for each exercise&#10;    val viewModel: ExerciseDetailViewModel = viewModel(&#10;        key = &quot;exercise_${workoutEntry.id}&quot;, // Unique key for each exercise&#10;        factory = ExerciseDetailViewModelFactory(workoutEntry, repository)&#10;    )&#10;&#10;    println(&quot; UI: Created ExerciseDetailViewModel for ${workoutEntry.exerciseName} (ID: ${workoutEntry.id})&quot;)&#10;&#10;    val setTimers by viewModel.setTimers.collectAsState()&#10;    val currentRunningSet by viewModel.currentRunningSet.collectAsState()&#10;    val totalExerciseTime by viewModel.totalExerciseTime.collectAsState()&#10;    val completedSets by viewModel.completedSets.collectAsState()&#10;    val isExerciseCompleted by viewModel.isExerciseCompleted.collectAsState()&#10;&#10;    //  NEW: Rest timer state&#10;    val restTimer by viewModel.restTimer.collectAsState()&#10;    val isRestActive by viewModel.isRestActive.collectAsState()&#10;&#10;    val originalCompletionStatus = remember { workoutEntry.isCompleted }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = workoutEntry.exerciseName,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontSize = 22.sp,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = PrimaryCoral&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Sets: $completedSets/${workoutEntry.sets} • Total: ${formatTime(totalExerciseTime / 1000)}&quot;.also {&#10;                                println(&quot; UI DEBUG: Displaying total time - Raw: ${totalExerciseTime}ms, Converted: ${totalExerciseTime / 1000}s, Formatted: ${formatTime(totalExerciseTime / 1000)}&quot;)&#10;                            },&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontSize = 14.sp,&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = {&#10;                        val shouldMarkCompleted = isExerciseCompleted &amp;&amp; completedSets == workoutEntry.sets&#10;                        if (shouldMarkCompleted != originalCompletionStatus) {&#10;                            onSaveChanges(workoutEntry.sets, workoutEntry.reps, shouldMarkCompleted)&#10;                        }&#10;                        onBackClick()&#10;                    }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = PrimaryCoral&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = CardBackground&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(BackgroundLight)&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            //  NEW: Rest timer display at top of screen&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isRestActive,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    RestTimerCard(&#10;                        restTime = restTimer / 1000, // Convert milliseconds to seconds&#10;                        isActive = isRestActive&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Exercise completion status with animation&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isExerciseCompleted,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    CompletionCard()&#10;                }&#10;            }&#10;&#10;            // Set cards with improved design&#10;            itemsIndexed(setTimers) { index, setTimer -&gt;&#10;                val activeSetIndex by viewModel.activeSetIndex.collectAsState()&#10;                ModernSetTimerCard(&#10;                    setNumber = index + 1,&#10;                    totalSets = workoutEntry.sets,&#10;                    targetReps = workoutEntry.reps,&#10;                    setTimer = setTimer.elapsedTime / 1000, //  FIXED: Convert milliseconds to seconds&#10;                    isCurrentSet = currentRunningSet == index,&#10;                    isCompleted = setTimer.isCompleted,&#10;                    isActive = index == activeSetIndex,&#10;                    isLocked = index &gt; activeSetIndex &amp;&amp; !setTimer.isCompleted,&#10;                    onStartTimer = { viewModel.startSetTimer(index) },&#10;                    onStopTimer = { viewModel.stopSetTimer(index) },&#10;                    onCompleteSet = { viewModel.completeSet(index) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CompletionCard() {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(8.dp, RoundedCornerShape(20.dp))&#10;            .clip(RoundedCornerShape(20.dp))&#10;            .background(&#10;                brush = Brush.horizontalGradient(&#10;                    colors = listOf(SuccessGreen, TealSecondary)&#10;                )&#10;            ),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Check,&#10;                contentDescription = &quot;Completed&quot;,&#10;                tint = TextOnPrimary,&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Text(&#10;                text = &quot;Exercise Completed! &quot;,&#10;                style = MaterialTheme.typography.titleLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextOnPrimary&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ModernSetTimerCard(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    targetReps: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean = false,&#10;    isActive: Boolean = false,&#10;    isLocked: Boolean = false,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onCompleteSet: () -&gt; Unit&#10;) {&#10;    // Animation for card state changes&#10;    val animatedElevation by animateDpAsState(&#10;        targetValue = when {&#10;            isCurrentSet -&gt; 12.dp&#10;            isActive -&gt; 6.dp&#10;            else -&gt; 2.dp&#10;        },&#10;        animationSpec = tween(300)&#10;    )&#10;&#10;    // Card colors based on state&#10;    val cardColors = when {&#10;        isCompleted -&gt; CardDefaults.cardColors(&#10;            containerColor = SuccessGreen.copy(alpha = 0.1f)&#10;        )&#10;        isCurrentSet -&gt; CardDefaults.cardColors(&#10;            containerColor = Color.Transparent&#10;        )&#10;        isActive -&gt; CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        )&#10;        isLocked -&gt; CardDefaults.cardColors(&#10;            containerColor = TextSecondary.copy(alpha = 0.05f)&#10;        )&#10;        else -&gt; CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(animatedElevation, RoundedCornerShape(16.dp))&#10;            .then(&#10;                if (isCurrentSet) {&#10;                    Modifier&#10;                        .border(&#10;                            width = 3.dp,&#10;                            brush = Brush.horizontalGradient(&#10;                                colors = listOf(ProgressStart, ProgressEnd)&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                        .background(&#10;                            brush = Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    ProgressStart.copy(alpha = 0.1f),&#10;                                    ProgressEnd.copy(alpha = 0.05f)&#10;                                )&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                } else {&#10;                    Modifier&#10;                }&#10;            ),&#10;        colors = cardColors,&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            // Set Header with improved typography&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Set status icon&#10;                    when {&#10;                        isCompleted -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isCurrentSet -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Active&quot;,&#10;                                tint = PrimaryCoral,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isLocked -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Lock,&#10;                                contentDescription = &quot;Locked&quot;,&#10;                                tint = TextSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        else -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.DateRange,&#10;                                contentDescription = &quot;Ready&quot;,&#10;                                tint = TealSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Set $setNumber of $totalSets&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontSize = 16.sp,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = when {&#10;                                isLocked -&gt; TextSecondary.copy(alpha = 0.6f)&#10;                                else -&gt; TextPrimary&#10;                            }&#10;                        )&#10;                    )&#10;                }&#10;&#10;                // Timer display with improved styling&#10;                TimerDisplay(&#10;                    time = setTimer,&#10;                    isActive = isCurrentSet,&#10;                    isCompleted = isCompleted&#10;                )&#10;            }&#10;&#10;            // Target reps info&#10;            Text(&#10;                text = &quot;Target: $targetReps reps&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    color = TextSecondary,&#10;                    fontSize = 14.sp&#10;                )&#10;            )&#10;&#10;            // Action buttons with modern design&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                when {&#10;                    isCompleted -&gt; {&#10;                        // Completed state - show success message&#10;                        Row(&#10;                            modifier = Modifier.weight(1f),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&#10;                                text = &quot;Set Completed&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    color = SuccessGreen,&#10;                                    fontWeight = FontWeight.Medium&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    isLocked -&gt; {&#10;                        // Locked state&#10;                        Text(&#10;                            text = &quot;Complete previous sets first&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                color = TextSecondary,&#10;                                fontStyle = androidx.compose.ui.text.font.FontStyle.Italic&#10;                            ),&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    }&#10;                    isCurrentSet -&gt; {&#10;                        //  FIXED: Simplified workflow - only Stop button that auto-completes the set&#10;                        Button(&#10;                            onClick = {&#10;                                onStopTimer() // Stop timer and auto-complete the set&#10;                                onCompleteSet() // Automatically mark as completed&#10;                            },&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = SuccessGreen&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Stop and Complete&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Complete Set&quot;)&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // Ready to start&#10;                        Button(&#10;                            onClick = onStartTimer,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = PrimaryCoral&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp),&#10;                            enabled = !isLocked&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Start&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Start Set&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimerDisplay(&#10;    time: Long,&#10;    isActive: Boolean,&#10;    isCompleted: Boolean&#10;) {&#10;    val textColor = when {&#10;        isCompleted -&gt; SuccessGreen&#10;        isActive -&gt; PrimaryCoral&#10;        else -&gt; TextSecondary&#10;    }&#10;&#10;    //  PROPER STOPWATCH: Start from stored time and count up properly&#10;    var displayTime by remember(time) { mutableStateOf(time) }&#10;&#10;    // Track when timer starts to calculate elapsed time properly&#10;    val startTimeRef = remember { mutableStateOf(0L) }&#10;&#10;    LaunchedEffect(isActive) {&#10;        if (isActive) {&#10;            // Record the actual start time when timer becomes active&#10;            startTimeRef.value = System.currentTimeMillis()&#10;&#10;            while (isActive) {&#10;                // Calculate elapsed seconds since timer started&#10;                val elapsedMs = System.currentTimeMillis() - startTimeRef.value&#10;                val elapsedSeconds = elapsedMs / 1000&#10;&#10;                // Display = stored time + elapsed time&#10;                displayTime = time + elapsedSeconds&#10;&#10;                delay(1000) // Update every second&#10;            }&#10;        } else {&#10;            // When not active, show the stored time from database&#10;            displayTime = time&#10;        }&#10;    }&#10;&#10;    Text(&#10;        text = formatTime(displayTime),&#10;        style = MaterialTheme.typography.titleLarge.copy(&#10;            fontSize = if (isActive) 20.sp else 18.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = textColor&#10;        )&#10;    )&#10;}&#10;&#10;private fun formatTime(timeInSeconds: Long): String {&#10;    val hours = timeInSeconds / 3600&#10;    val minutes = (timeInSeconds % 3600) / 60&#10;    val seconds = timeInSeconds % 60&#10;&#10;    return if (hours &gt; 0) {&#10;        String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds)&#10;    } else {&#10;        String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;}&#10;&#10;//  NEW: Rest Timer Card Component&#10;@Composable&#10;fun RestTimerCard(&#10;    restTime: Long,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(6.dp, RoundedCornerShape(16.dp)),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                // Rest icon - using a pause/timer-like icon&#10;                Icon(&#10;                    imageVector = Icons.Default.PlayArrow, // We'll use this as a rest indicator&#10;                    contentDescription = &quot;Rest&quot;,&#10;                    tint = AmberAccent,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                Text(&#10;                    text = &quot;Rest Timer&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = TextPrimary&#10;                    )&#10;                )&#10;            }&#10;&#10;            // Rest time display with prominent styling&#10;            Text(&#10;                text = formatTime(restTime),&#10;                style = MaterialTheme.typography.headlineMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = AmberAccent,&#10;                    fontSize = 24.sp&#10;                )&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/TemplateSelectionScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/TemplateSelectionScreen.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModelFactory&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TemplateSelectionScreen(&#10;    repository: WorkoutRepository,&#10;    selectedDate: String,&#10;    onTemplateSelected: (WorkoutTemplate) -&gt; Unit,&#10;    onBackClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val viewModel: DailyWorkoutViewModel = viewModel(&#10;        factory = DailyWorkoutViewModelFactory(repository)&#10;    )&#10;&#10;    val availableTemplates by viewModel.availableTemplates.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;&#10;    // Load templates when screen opens&#10;    LaunchedEffect(Unit) {&#10;        // Load templates using the public method - since loadAvailableTemplates() is private,&#10;        // the templates should already be loaded in the ViewModel init&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Choose Your Workout&quot;,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface,&#10;                    titleContentColor = MaterialTheme.colorScheme.onSurface&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Date display&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = &quot;Workout for $selectedDate&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp)&#10;                )&#10;            }&#10;&#10;            if (isLoading) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            } else if (availableTemplates.isEmpty()) {&#10;                EmptyTemplateState()&#10;            } else {&#10;                LazyColumn(&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    item {&#10;                        Text(&#10;                            text = &quot;Available Workout Templates&quot;,&#10;                            style = MaterialTheme.typography.titleLarge,&#10;                            fontWeight = FontWeight.Bold,&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;&#10;                    items(availableTemplates) { template -&gt;&#10;                        TemplateCard(&#10;                            template = template,&#10;                            onClick = { onTemplateSelected(template) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TemplateCard(&#10;    template: WorkoutTemplate,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() },&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Template header&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = template.name,&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;&#10;                    Text(&#10;                        text = template.category,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        color = getCategoryColor(template.category),&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;&#10;                // Difficulty indicator&#10;                DifficultyChip(difficulty = template.difficulty)&#10;            }&#10;&#10;            // Template description&#10;            if (template.description.isNotBlank()) {&#10;                Text(&#10;                    text = template.description,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;&#10;            // Template metadata&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(top = 12.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                // Estimated duration (using a default value since estimatedDurationMinutes doesn't exist)&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Duration&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;45-60 min&quot;, // Default estimated duration&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(start = 4.dp)&#10;                    )&#10;                }&#10;&#10;                // Exercise count&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Star,&#10;                        contentDescription = &quot;Exercises&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;6 exercises&quot;, // Default exercise count&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(start = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Last used info&#10;            if (template.lastUsedDate != null) {&#10;                Text(&#10;                    text = &quot;Last used: ${template.lastUsedDate}&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DifficultyChip(&#10;    difficulty: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val (color, text) = when (difficulty.lowercase()) {&#10;        &quot;beginner&quot; -&gt; Pair(Color(0xFF4CAF50), &quot;Beginner&quot;)&#10;        &quot;intermediate&quot; -&gt; Pair(Color(0xFFFF9800), &quot;Intermediate&quot;)&#10;        &quot;advanced&quot; -&gt; Pair(Color(0xFFF44336), &quot;Advanced&quot;)&#10;        else -&gt; Pair(MaterialTheme.colorScheme.primary, difficulty)&#10;    }&#10;&#10;    Surface(&#10;        modifier = modifier,&#10;        color = color.copy(alpha = 0.1f),&#10;        shape = MaterialTheme.shapes.small&#10;    ) {&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Star,&#10;                contentDescription = &quot;Difficulty&quot;,&#10;                tint = color,&#10;                modifier = Modifier.size(12.dp)&#10;            )&#10;            Text(&#10;                text = text,&#10;                style = MaterialTheme.typography.labelSmall,&#10;                color = color,&#10;                fontWeight = FontWeight.Medium,&#10;                modifier = Modifier.padding(start = 4.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmptyTemplateState() {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Star,&#10;            contentDescription = &quot;No Templates&quot;,&#10;            tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.size(64.dp)&#10;        )&#10;&#10;        Text(&#10;            text = &quot;No Templates Available&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.padding(top = 16.dp)&#10;        )&#10;&#10;        Text(&#10;            text = &quot;Templates are being loaded. Please wait...&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(vertical = 8.dp, horizontal = 32.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun getCategoryColor(category: String): Color {&#10;    return when (category.lowercase()) {&#10;        &quot;push&quot; -&gt; Color(0xFFE57373) // Light red&#10;        &quot;pull&quot; -&gt; Color(0xFF64B5F6) // Light blue&#10;        &quot;legs&quot; -&gt; Color(0xFF81C784) // Light green&#10;        else -&gt; MaterialTheme.colorScheme.primary&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/viewmodel/ExerciseDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/viewmodel/ExerciseDetailViewModel.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class SetTimer(&#10;    val setNumber: Int,&#10;    val elapsedTime: Long = 0L,&#10;    val isRunning: Boolean = false,&#10;    val isCompleted: Boolean = false,&#10;    val startTime: Long = 0L&#10;)&#10;&#10;class ExerciseDetailViewModel(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModel() {&#10;&#10;    // Load actual sets from database instead of creating in memory&#10;    private val _setTimers = MutableStateFlow&lt;List&lt;SetTimer&gt;&gt;(emptyList())&#10;    val setTimers: StateFlow&lt;List&lt;SetTimer&gt;&gt; = _setTimers.asStateFlow()&#10;&#10;    private val _currentRunningSet = MutableStateFlow&lt;Int?&gt;(null)&#10;    val currentRunningSet: StateFlow&lt;Int?&gt; = _currentRunningSet.asStateFlow()&#10;&#10;    private val _activeSetIndex = MutableStateFlow&lt;Int&gt;(0)&#10;    val activeSetIndex: StateFlow&lt;Int&gt; = _activeSetIndex.asStateFlow()&#10;&#10;    private val _totalExerciseTime = MutableStateFlow(0L)&#10;    val totalExerciseTime: StateFlow&lt;Long&gt; = _totalExerciseTime.asStateFlow()&#10;&#10;    private val _completedSets = MutableStateFlow(0)&#10;    val completedSets: StateFlow&lt;Int&gt; = _completedSets.asStateFlow()&#10;&#10;    private val _isExerciseCompleted = MutableStateFlow(false)&#10;    val isExerciseCompleted: StateFlow&lt;Boolean&gt; = _isExerciseCompleted.asStateFlow()&#10;&#10;    //  NEW: Rest timer functionality&#10;    private val _restTimer = MutableStateFlow(0L)&#10;    val restTimer: StateFlow&lt;Long&gt; = _restTimer.asStateFlow()&#10;&#10;    private val _isRestActive = MutableStateFlow(false)&#10;    val isRestActive: StateFlow&lt;Boolean&gt; = _isRestActive.asStateFlow()&#10;&#10;    private val _totalRestTime = MutableStateFlow(0L)&#10;    val totalRestTime: StateFlow&lt;Long&gt; = _totalRestTime.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var restTimerJob: Job? = null&#10;    private var currentSetId: Int? = null&#10;&#10;    init {&#10;        loadSetsFromDatabase()&#10;    }&#10;&#10;    private fun loadSetsFromDatabase() {&#10;        viewModelScope.launch {&#10;            println(&quot; DETAIL VM: Loading sets for workout entry ID: ${workoutEntry.id}&quot;)&#10;            println(&quot; DETAIL VM: Exercise: '${workoutEntry.exerciseName}' (Exercise ID: ${workoutEntry.exerciseId})&quot;)&#10;&#10;            // First, ensure sets exist in database&#10;            val existingSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            println(&quot; DETAIL VM: Found ${existingSets.size} existing sets in database&quot;)&#10;&#10;            if (existingSets.isEmpty()) {&#10;                println(&quot; DETAIL VM: No sets found, creating ${workoutEntry.sets} sets&quot;)&#10;                // Create sets in database if they don't exist&#10;                repository.createSetsForWorkoutEntry(workoutEntry.id, workoutEntry.sets)&#10;                println(&quot; DETAIL VM: Sets created, reloading...&quot;)&#10;            } else {&#10;                println(&quot; DETAIL VM: Sets already exist:&quot;)&#10;                existingSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;            }&#10;&#10;            // Now load sets from database and observe changes&#10;            repository.getSetsForWorkoutEntry(workoutEntry.id).collect { dbSets -&gt;&#10;                println(&quot; DETAIL VM: Received ${dbSets.size} sets from Flow for WorkoutEntry ID: ${workoutEntry.id}&quot;)&#10;                dbSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Flow Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;&#10;                val setTimers = dbSets.map { setEntry -&gt;&#10;                    SetTimer(&#10;                        setNumber = setEntry.setNumber,&#10;                        elapsedTime = (setEntry.elapsedTimeSeconds * 1000).toLong(),&#10;                        isRunning = false, // Never restore running state from DB&#10;                        isCompleted = setEntry.isCompleted,&#10;                        startTime = 0L&#10;                    )&#10;                }&#10;&#10;                println(&quot; DETAIL VM: Created ${setTimers.size} SetTimer objects for '${workoutEntry.exerciseName}'&quot;)&#10;                _setTimers.value = setTimers&#10;                _completedSets.value = dbSets.count { it.isCompleted }&#10;                _isExerciseCompleted.value = dbSets.all { it.isCompleted } &amp;&amp; dbSets.isNotEmpty()&#10;&#10;                //  FIX: Set the active set index to the first incomplete set&#10;                val firstIncompleteSetIndex = setTimers.indexOfFirst { !it.isCompleted }&#10;                _activeSetIndex.value = if (firstIncompleteSetIndex != -1) firstIncompleteSetIndex else 0&#10;                println(&quot; DETAIL VM: Set active set index to: ${_activeSetIndex.value}&quot;)&#10;&#10;                updateTotalExerciseTime()&#10;&#10;                println(&quot; DETAIL VM: State updated for '${workoutEntry.exerciseName}' - completedSets: ${_completedSets.value}, isCompleted: ${_isExerciseCompleted.value}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startSetTimer(setIndex: Int) {&#10;        println(&quot; REST DEBUG: startSetTimer called for set ${setIndex + 1}&quot;)&#10;&#10;        // Stop any currently running timer&#10;        stopAllTimers()&#10;&#10;        //  NEW: Stop rest timer when starting a new set&#10;        println(&quot; REST DEBUG: Stopping rest timer before starting new set&quot;)&#10;        stopRestTimer()&#10;&#10;        // Start timer for this set&#10;        val currentTime = System.currentTimeMillis()&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        updatedTimers[setIndex] = updatedTimers[setIndex].copy(&#10;            isRunning = true,&#10;            startTime = currentTime&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = setIndex&#10;&#10;        println(&quot; REST DEBUG: Set ${setIndex + 1} timer started at $currentTime&quot;)&#10;&#10;        // Store the database set ID for persistence&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            currentSetId = dbSets.getOrNull(setIndex)?.id&#10;        }&#10;&#10;        // Start the timer coroutine&#10;        timerJob = viewModelScope.launch {&#10;            while (_setTimers.value.getOrNull(setIndex)?.isRunning == true) {&#10;                delay(1000) // Update every second&#10;                updateTimerForSet(setIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopSetTimer(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        if (timer.isRunning) {&#10;            //  FIXED: Use current elapsed time directly, don't double-count&#10;            val finalElapsedTime = System.currentTimeMillis() - timer.startTime&#10;&#10;            println(&quot; STOP TIMER DEBUG: Set ${setIndex + 1}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: timer.elapsedTime = ${timer.elapsedTime}ms&quot;)&#10;            println(&quot; STOP TIMER DEBUG: startTime = ${timer.startTime}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: currentTime = ${System.currentTimeMillis()}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: calculated elapsed = ${finalElapsedTime}ms (${finalElapsedTime / 1000}s)&quot;)&#10;&#10;            updatedTimers[setIndex] = timer.copy(&#10;                isRunning = false,&#10;                elapsedTime = finalElapsedTime,&#10;                isCompleted = true  // Mark as completed when stopping&#10;            )&#10;            _setTimers.value = updatedTimers&#10;            _currentRunningSet.value = null&#10;            timerJob?.cancel()&#10;&#10;            //  NEW: Start rest timer when set is completed&#10;            startRestTimer()&#10;&#10;            // Persist timer to database&#10;            currentSetId?.let { setId -&gt;&#10;                viewModelScope.launch {&#10;                    repository.updateSetProgress(&#10;                        setId = setId,&#10;                        isCompleted = true,  // Mark as completed in the database&#10;                        elapsedTimeSeconds = (finalElapsedTime / 1000).toInt()&#10;                    )&#10;&#10;                    // Update exercise completion status&#10;                    repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;&#10;                    // Update local completed sets count&#10;                    val completedCount = _setTimers.value.count { it.isCompleted }&#10;                    _completedSets.value = completedCount&#10;&#10;                    // Check if all sets are completed&#10;                    if (completedCount == workoutEntry.sets) {&#10;                        _isExerciseCompleted.value = true&#10;                        // Stop rest timer if all sets are completed&#10;                        stopRestTimer()&#10;                    } else {&#10;                        // Advance to next set - find the first incomplete set&#10;                        val nextIncompleteSetIndex = _setTimers.value.indexOfFirst { !it.isCompleted }&#10;                        if (nextIncompleteSetIndex != -1) {&#10;                            _activeSetIndex.value = nextIncompleteSetIndex&#10;                            println(&quot; DETAIL VM: Advanced to next set index: $nextIncompleteSetIndex&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            updateTotalExerciseTime()&#10;        }&#10;    }&#10;&#10;    fun completeSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        updatedTimers[setIndex] = timer.copy(&#10;            isCompleted = true,&#10;            isRunning = false&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;        timerJob?.cancel()&#10;&#10;        // Persist completion to database&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            val setEntry = dbSets.getOrNull(setIndex)&#10;&#10;            setEntry?.let {&#10;                repository.updateSetProgress(&#10;                    setId = it.id,&#10;                    isCompleted = true,&#10;                    elapsedTimeSeconds = (timer.elapsedTime / 1000).toInt()&#10;                )&#10;&#10;                // Check if all sets are completed and update exercise&#10;                repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;            }&#10;        }&#10;&#10;        // Update local state&#10;        val completedCount = updatedTimers.count { it.isCompleted }&#10;        _completedSets.value = completedCount&#10;&#10;        // Check if all sets are completed&#10;        if (completedCount == workoutEntry.sets) {&#10;            _isExerciseCompleted.value = true&#10;        }&#10;&#10;        updateTotalExerciseTime()&#10;    }&#10;&#10;    //  NEW: Rest timer functionality&#10;    private fun startRestTimer() {&#10;        println(&quot; REST DEBUG: startRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        // Don't start a new rest timer if one is already active&#10;        if (_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer already active, skipping start&quot;)&#10;            return&#10;        }&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to true&quot;)&#10;        _isRestActive.value = true&#10;        val restStartTime = System.currentTimeMillis()&#10;        println(&quot; REST DEBUG: Rest timer start time: $restStartTime&quot;)&#10;&#10;        // Start the rest timer job&#10;        restTimerJob = viewModelScope.launch {&#10;            var elapsedRestTime = 0L&#10;            println(&quot; REST DEBUG: Rest timer coroutine started&quot;)&#10;&#10;            while (_isRestActive.value) {&#10;                delay(1000) // Update every second&#10;                elapsedRestTime += 1000&#10;                _restTimer.value = elapsedRestTime&#10;&#10;                println(&quot;⏱️ REST TIMER: ${elapsedRestTime / 1000}s (Live) - _restTimer.value = ${_restTimer.value}&quot;)&#10;            }&#10;            println(&quot; REST DEBUG: Rest timer coroutine ended&quot;)&#10;        }&#10;&#10;        println(&quot; REST TIMER STARTED - Job created: ${restTimerJob != null}&quot;)&#10;    }&#10;&#10;    private fun stopRestTimer() {&#10;        println(&quot; REST DEBUG: stopRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        if (!_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer not active, nothing to stop&quot;)&#10;            return&#10;        }&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to false&quot;)&#10;        _isRestActive.value = false&#10;&#10;        println(&quot; REST DEBUG: Cancelling rest timer job&quot;)&#10;        restTimerJob?.cancel()&#10;        restTimerJob = null&#10;&#10;        // Reset rest timer value&#10;        val previousValue = _restTimer.value&#10;        _restTimer.value = 0L&#10;        println(&quot; REST DEBUG: Reset _restTimer from ${previousValue}ms to ${_restTimer.value}ms&quot;)&#10;&#10;        println(&quot;⏹️ REST TIMER STOPPED&quot;)&#10;    }&#10;&#10;    private fun stopAllTimers() {&#10;        timerJob?.cancel()&#10;        val updatedTimers = _setTimers.value.map { timer -&gt;&#10;            timer.copy(isRunning = false)&#10;        }&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;    }&#10;&#10;    private fun updateTimerForSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers[setIndex]&#10;&#10;        if (timer.isRunning) {&#10;            val currentTime = System.currentTimeMillis()&#10;            //  FIXED: Don't add previous elapsedTime - just calculate from start&#10;            val elapsed = currentTime - timer.startTime&#10;            updatedTimers[setIndex] = timer.copy(elapsedTime = elapsed)&#10;            _setTimers.value = updatedTimers&#10;&#10;            //  REMOVED: Don't update total time during live timer updates&#10;            // updateTotalExerciseTime() // This was causing live updates in top bar&#10;&#10;            //  ADDED: Force UI recomposition for live stopwatch display&#10;            println(&quot;⏱️ TIMER: Set ${setIndex + 1} - ${elapsed / 1000}s (Live)&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateTotalExerciseTime() {&#10;        //  FIXED: Only count completed sets for total time, not running timers&#10;        val completedSets = _setTimers.value.filter { it.isCompleted }&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Calculating total exercise time...&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Found ${completedSets.size} completed sets:&quot;)&#10;&#10;        completedSets.forEachIndexed { index, set -&gt;&#10;            println(&quot; TOTAL TIME DEBUG: Set ${index + 1}: ${set.elapsedTime}ms (${set.elapsedTime / 1000}s)&quot;)&#10;        }&#10;&#10;        val totalTime = completedSets.sumOf { it.elapsedTime }&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Sum of all completed sets: ${totalTime}ms (${totalTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Setting _totalExerciseTime to: ${totalTime}&quot;)&#10;&#10;        _totalExerciseTime.value = totalTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: _totalExerciseTime.value is now: ${_totalExerciseTime.value}&quot;)&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        restTimerJob?.cancel() //  NEW: Clean up rest timer job&#10;    }&#10;}&#10;&#10;class ExerciseDetailViewModelFactory(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ExerciseDetailViewModel::class.java)) {&#10;            return ExerciseDetailViewModel(workoutEntry, repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class SetTimer(&#10;    val setNumber: Int,&#10;    val elapsedTime: Long = 0L,&#10;    val isRunning: Boolean = false,&#10;    val isCompleted: Boolean = false,&#10;    val startTime: Long = 0L&#10;)&#10;&#10;class ExerciseDetailViewModel(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModel() {&#10;&#10;    // Load actual sets from database instead of creating in memory&#10;    private val _setTimers = MutableStateFlow&lt;List&lt;SetTimer&gt;&gt;(emptyList())&#10;    val setTimers: StateFlow&lt;List&lt;SetTimer&gt;&gt; = _setTimers.asStateFlow()&#10;&#10;    private val _currentRunningSet = MutableStateFlow&lt;Int?&gt;(null)&#10;    val currentRunningSet: StateFlow&lt;Int?&gt; = _currentRunningSet.asStateFlow()&#10;&#10;    private val _activeSetIndex = MutableStateFlow&lt;Int&gt;(0)&#10;    val activeSetIndex: StateFlow&lt;Int&gt; = _activeSetIndex.asStateFlow()&#10;&#10;    private val _totalExerciseTime = MutableStateFlow(0L)&#10;    val totalExerciseTime: StateFlow&lt;Long&gt; = _totalExerciseTime.asStateFlow()&#10;&#10;    private val _completedSets = MutableStateFlow(0)&#10;    val completedSets: StateFlow&lt;Int&gt; = _completedSets.asStateFlow()&#10;&#10;    private val _isExerciseCompleted = MutableStateFlow(false)&#10;    val isExerciseCompleted: StateFlow&lt;Boolean&gt; = _isExerciseCompleted.asStateFlow()&#10;&#10;    //  NEW: Rest timer functionality&#10;    private val _restTimer = MutableStateFlow(0L)&#10;    val restTimer: StateFlow&lt;Long&gt; = _restTimer.asStateFlow()&#10;&#10;    private val _isRestActive = MutableStateFlow(false)&#10;    val isRestActive: StateFlow&lt;Boolean&gt; = _isRestActive.asStateFlow()&#10;&#10;    private val _totalRestTime = MutableStateFlow(0L)&#10;    val totalRestTime: StateFlow&lt;Long&gt; = _totalRestTime.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var restTimerJob: Job? = null&#10;    private var currentSetId: Int? = null&#10;&#10;    init {&#10;        loadSetsFromDatabase()&#10;    }&#10;&#10;    private fun loadSetsFromDatabase() {&#10;        viewModelScope.launch {&#10;            println(&quot; DETAIL VM: Loading sets for workout entry ID: ${workoutEntry.id}&quot;)&#10;            println(&quot; DETAIL VM: Exercise: '${workoutEntry.exerciseName}' (Exercise ID: ${workoutEntry.exerciseId})&quot;)&#10;&#10;            // First, ensure sets exist in database&#10;            val existingSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            println(&quot; DETAIL VM: Found ${existingSets.size} existing sets in database&quot;)&#10;&#10;            if (existingSets.isEmpty()) {&#10;                println(&quot; DETAIL VM: No sets found, creating ${workoutEntry.sets} sets&quot;)&#10;                // Create sets in database if they don't exist&#10;                repository.createSetsForWorkoutEntry(workoutEntry.id, workoutEntry.sets)&#10;                println(&quot; DETAIL VM: Sets created, reloading...&quot;)&#10;            } else {&#10;                println(&quot; DETAIL VM: Sets already exist:&quot;)&#10;                existingSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;            }&#10;&#10;            // Now load sets from database and observe changes&#10;            repository.getSetsForWorkoutEntry(workoutEntry.id).collect { dbSets -&gt;&#10;                println(&quot; DETAIL VM: Received ${dbSets.size} sets from Flow for WorkoutEntry ID: ${workoutEntry.id}&quot;)&#10;                dbSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Flow Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;&#10;                val setTimers = dbSets.map { setEntry -&gt;&#10;                    SetTimer(&#10;                        setNumber = setEntry.setNumber,&#10;                        elapsedTime = (setEntry.elapsedTimeSeconds * 1000).toLong(),&#10;                        isRunning = false, // Never restore running state from DB&#10;                        isCompleted = setEntry.isCompleted,&#10;                        startTime = 0L&#10;                    )&#10;                }&#10;&#10;                println(&quot; DETAIL VM: Created ${setTimers.size} SetTimer objects for '${workoutEntry.exerciseName}'&quot;)&#10;                _setTimers.value = setTimers&#10;                _completedSets.value = dbSets.count { it.isCompleted }&#10;                _isExerciseCompleted.value = dbSets.all { it.isCompleted } &amp;&amp; dbSets.isNotEmpty()&#10;&#10;                //  FIX: Set the active set index to the first incomplete set&#10;                val firstIncompleteSetIndex = setTimers.indexOfFirst { !it.isCompleted }&#10;                _activeSetIndex.value = if (firstIncompleteSetIndex != -1) firstIncompleteSetIndex else 0&#10;                println(&quot; DETAIL VM: Set active set index to: ${_activeSetIndex.value}&quot;)&#10;&#10;                updateTotalExerciseTime()&#10;&#10;                println(&quot; DETAIL VM: State updated for '${workoutEntry.exerciseName}' - completedSets: ${_completedSets.value}, isCompleted: ${_isExerciseCompleted.value}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startSetTimer(setIndex: Int) {&#10;        println(&quot; REST DEBUG: startSetTimer called for set ${setIndex + 1}&quot;)&#10;&#10;        // Stop any currently running timer&#10;        stopAllTimers()&#10;&#10;        //  NEW: Stop rest timer when starting a new set&#10;        println(&quot; REST DEBUG: Stopping rest timer before starting new set&quot;)&#10;        stopRestTimer()&#10;&#10;        // Start timer for this set&#10;        val currentTime = System.currentTimeMillis()&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        updatedTimers[setIndex] = updatedTimers[setIndex].copy(&#10;            isRunning = true,&#10;            startTime = currentTime&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = setIndex&#10;&#10;        println(&quot; REST DEBUG: Set ${setIndex + 1} timer started at $currentTime&quot;)&#10;&#10;        // Store the database set ID for persistence&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            currentSetId = dbSets.getOrNull(setIndex)?.id&#10;        }&#10;&#10;        // Start the timer coroutine&#10;        timerJob = viewModelScope.launch {&#10;            while (_setTimers.value.getOrNull(setIndex)?.isRunning == true) {&#10;                delay(1000) // Update every second&#10;                updateTimerForSet(setIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopSetTimer(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        if (timer.isRunning) {&#10;            //  FIXED: Use current elapsed time directly, don't double-count&#10;            val finalElapsedTime = System.currentTimeMillis() - timer.startTime&#10;&#10;            println(&quot; STOP TIMER DEBUG: Set ${setIndex + 1}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: timer.elapsedTime = ${timer.elapsedTime}ms&quot;)&#10;            println(&quot; STOP TIMER DEBUG: startTime = ${timer.startTime}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: currentTime = ${System.currentTimeMillis()}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: calculated elapsed = ${finalElapsedTime}ms (${finalElapsedTime / 1000}s)&quot;)&#10;&#10;            updatedTimers[setIndex] = timer.copy(&#10;                isRunning = false,&#10;                elapsedTime = finalElapsedTime,&#10;                isCompleted = true  // Mark as completed when stopping&#10;            )&#10;            _setTimers.value = updatedTimers&#10;            _currentRunningSet.value = null&#10;            timerJob?.cancel()&#10;&#10;            //  NEW: Start rest timer when set is completed&#10;            startRestTimer()&#10;&#10;            // Persist timer to database&#10;            currentSetId?.let { setId -&gt;&#10;                viewModelScope.launch {&#10;                    repository.updateSetProgress(&#10;                        setId = setId,&#10;                        isCompleted = true,  // Mark as completed in the database&#10;                        elapsedTimeSeconds = (finalElapsedTime / 1000).toInt()&#10;                    )&#10;&#10;                    // Update exercise completion status&#10;                    repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;&#10;                    // Update local completed sets count&#10;                    val completedCount = _setTimers.value.count { it.isCompleted }&#10;                    _completedSets.value = completedCount&#10;&#10;                    // Check if all sets are completed&#10;                    if (completedCount == workoutEntry.sets) {&#10;                        _isExerciseCompleted.value = true&#10;                        // Stop rest timer if all sets are completed&#10;                        stopRestTimer()&#10;                    } else {&#10;                        // Advance to next set - find the first incomplete set&#10;                        val nextIncompleteSetIndex = _setTimers.value.indexOfFirst { !it.isCompleted }&#10;                        if (nextIncompleteSetIndex != -1) {&#10;                            _activeSetIndex.value = nextIncompleteSetIndex&#10;                            println(&quot; DETAIL VM: Advanced to next set index: $nextIncompleteSetIndex&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            updateTotalExerciseTime()&#10;        }&#10;    }&#10;&#10;    fun completeSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        updatedTimers[setIndex] = timer.copy(&#10;            isCompleted = true,&#10;            isRunning = false&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;        timerJob?.cancel()&#10;&#10;        // Persist completion to database&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            val setEntry = dbSets.getOrNull(setIndex)&#10;&#10;            setEntry?.let {&#10;                repository.updateSetProgress(&#10;                    setId = it.id,&#10;                    isCompleted = true,&#10;                    elapsedTimeSeconds = (timer.elapsedTime / 1000).toInt()&#10;                )&#10;&#10;                // Check if all sets are completed and update exercise&#10;                repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;            }&#10;        }&#10;&#10;        // Update local state&#10;        val completedCount = updatedTimers.count { it.isCompleted }&#10;        _completedSets.value = completedCount&#10;&#10;        // Check if all sets are completed&#10;        if (completedCount == workoutEntry.sets) {&#10;            _isExerciseCompleted.value = true&#10;        }&#10;&#10;        updateTotalExerciseTime()&#10;    }&#10;&#10;    //  NEW: Rest timer functionality&#10;    private fun startRestTimer() {&#10;        println(&quot; REST DEBUG: startRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        // Don't start a new rest timer if one is already active&#10;        if (_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer already active, skipping start&quot;)&#10;            return&#10;        }&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to true&quot;)&#10;        _isRestActive.value = true&#10;        val restStartTime = System.currentTimeMillis()&#10;        println(&quot; REST DEBUG: Rest timer start time: $restStartTime&quot;)&#10;&#10;        // Start the rest timer job&#10;        restTimerJob = viewModelScope.launch {&#10;            var elapsedRestTime = 0L&#10;            println(&quot; REST DEBUG: Rest timer coroutine started&quot;)&#10;&#10;            while (_isRestActive.value) {&#10;                delay(1000) // Update every second&#10;                elapsedRestTime += 1000&#10;                _restTimer.value = elapsedRestTime&#10;&#10;                println(&quot;⏱️ REST TIMER: ${elapsedRestTime / 1000}s (Live) - _restTimer.value = ${_restTimer.value}&quot;)&#10;            }&#10;            println(&quot; REST DEBUG: Rest timer coroutine ended&quot;)&#10;        }&#10;&#10;        println(&quot; REST TIMER STARTED - Job created: ${restTimerJob != null}&quot;)&#10;    }&#10;&#10;    private fun stopRestTimer() {&#10;        println(&quot; REST DEBUG: stopRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        if (!_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer not active, nothing to stop&quot;)&#10;            return&#10;        }&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to false&quot;)&#10;        _isRestActive.value = false&#10;&#10;        println(&quot; REST DEBUG: Cancelling rest timer job&quot;)&#10;        restTimerJob?.cancel()&#10;        restTimerJob = null&#10;&#10;        // Reset rest timer value&#10;        val previousValue = _restTimer.value&#10;        _restTimer.value = 0L&#10;        println(&quot; REST DEBUG: Reset _restTimer from ${previousValue}ms to ${_restTimer.value}ms&quot;)&#10;&#10;        println(&quot;⏹️ REST TIMER STOPPED&quot;)&#10;    }&#10;&#10;    private fun stopAllTimers() {&#10;        timerJob?.cancel()&#10;        val updatedTimers = _setTimers.value.map { timer -&gt;&#10;            timer.copy(isRunning = false)&#10;        }&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;    }&#10;&#10;    private fun updateTimerForSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers[setIndex]&#10;&#10;        if (timer.isRunning) {&#10;            val currentTime = System.currentTimeMillis()&#10;            //  FIXED: Don't add previous elapsedTime - just calculate from start&#10;            val elapsed = currentTime - timer.startTime&#10;            updatedTimers[setIndex] = timer.copy(elapsedTime = elapsed)&#10;            _setTimers.value = updatedTimers&#10;&#10;            //  REMOVED: Don't update total time during live timer updates&#10;            // updateTotalExerciseTime() // This was causing live updates in top bar&#10;&#10;            //  ADDED: Force UI recomposition for live stopwatch display&#10;            println(&quot;⏱️ TIMER: Set ${setIndex + 1} - ${elapsed / 1000}s (Live)&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateTotalExerciseTime() {&#10;        //  FIXED: Only count completed sets for total time, not running timers&#10;        val completedSets = _setTimers.value.filter { it.isCompleted }&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Calculating total exercise time...&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Found ${completedSets.size} completed sets:&quot;)&#10;&#10;        completedSets.forEachIndexed { index, set -&gt;&#10;            println(&quot; TOTAL TIME DEBUG: Set ${index + 1}: ${set.elapsedTime}ms (${set.elapsedTime / 1000}s)&quot;)&#10;        }&#10;&#10;        val setTime = completedSets.sumOf { it.elapsedTime }&#10;        &#10;        //  NEW: Include accumulated rest time in total&#10;        val restTime = _totalRestTime.value&#10;        val totalTime = setTime + restTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Sum of all completed sets: ${setTime}ms (${setTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Total accumulated rest time: ${restTime}ms (${restTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Combined total time: ${totalTime}ms (${totalTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Setting _totalExerciseTime to: ${totalTime}&quot;)&#10;&#10;        _totalExerciseTime.value = totalTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: _totalExerciseTime.value is now: ${_totalExerciseTime.value}&quot;)&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        restTimerJob?.cancel() //  NEW: Clean up rest timer job&#10;    }&#10;}&#10;&#10;class ExerciseDetailViewModelFactory(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ExerciseDetailViewModel::class.java)) {&#10;            return ExerciseDetailViewModel(workoutEntry, repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>