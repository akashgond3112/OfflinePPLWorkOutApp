<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/MIGRATION_ROADMAP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MIGRATION_ROADMAP.md" />
              <option name="originalContent" value="# ️ PPL Workout App - Migration Roadmap&#10;&#10;## Overview&#10;This document outlines the migration path from the current simplified architecture to the advanced, production-ready architecture shown in the database and workflow diagrams.&#10;&#10;## Current State Analysis ✅&#10;&#10;### Database Schema (Working) - Version 7&#10;- [x] **exercises** table: Enhanced with rich metadata (primaryMuscle, secondaryMuscles, equipment, difficulty, instructions, tips, category) ✅&#10;- [x] **workout_days** table: Stores daily workout sessions ✅&#10;- [x] **workout_entries** table: Links exercises to workout days ✅&#10;- [x] **set_entries** table: Individual set tracking with timing ✅&#10;- [x] **workout_templates** table: Template definitions for reusable workouts ✅&#10;- [x] **template_exercises** table: Junction table linking templates to exercises ✅&#10;&#10;### Features Working ✅&#10;- [x] PPL workout creation based on day of week&#10;- [x] **Template-based workout creation system** ✅&#10;- [x] Exercise detail screens with set progression&#10;- [x] Individual set timing and completion tracking&#10;- [x] Cross-exercise contamination fixed (sets isolated per exercise)&#10;- [x] Database reset functionality for development&#10;- [x] Timer functionality with start/stop per set&#10;- [x] Enhanced exercise library with rich metadata (34+ exercises)&#10;- [x] Automatic template population on database creation&#10;- [x] Template selection and creation methods&#10;&#10;### Current Architecture Status&#10;- **Exercise Library**: Rich metadata with 34+ exercises in `ExerciseData.getPPLExercises()` ✅&#10;- **Template System**: Complete entities, DAOs, and repository methods ✅&#10;- **Workout Logic**: **Both day-based AND template-based systems working** ✅&#10;- **Database Version**: 7 (with complete template system migration)&#10;- **UI Layer**: Daily workout screens with template integration ✅&#10;&#10;---&#10;&#10;## Phase 1: Core Foundation ✅ **COMPLETED**&#10;&#10;### 1.1 Project Setup &amp; Database ✅&#10;- [x] 1.1.1 Android project with Kotlin &amp; Compose&#10;- [x] 1.1.2 Room database implementation&#10;- [x] 1.1.3 Entity models (WorkoutDay, Exercise, WorkoutEntry, SetEntry)&#10;- [x] 1.1.4 DAO implementations&#10;- [x] 1.1.5 Repository pattern&#10;&#10;### 1.2 Basic UI &amp; Navigation ✅&#10;- [x] 1.2.1 Material Design 3 theme&#10;- [x] 1.2.2 Navigation between screens&#10;- [x] 1.2.3 Daily workout view&#10;- [x] 1.2.4 Exercise list screen&#10;- [x] 1.2.5 Exercise detail screen&#10;&#10;### 1.3 Workout Logic ✅&#10;- [x] 1.3.1 PPL schedule implementation (6-day rotation)&#10;- [x] 1.3.2 Rest day handling with background image&#10;- [x] 1.3.3 Workout day creation and exercise population&#10;- [x] 1.3.4 Set tracking and completion logic&#10;- [x] 1.3.5 Exercise progress tracking&#10;&#10;### 1.4 Timer &amp; Time Tracking ✅ **COMPLETED**&#10;- [x] 1.4.1 Individual set timers (start/stop functionality)&#10;- [x] 1.4.2 Total exercise time calculation&#10;- [x] 1.4.3 Set completion tracking&#10;- [x] 1.4.4 Sequential set unlocking&#10;- [x] 1.4.5 Rest period timer implementation ✅ **FIXED**&#10;- [x] 1.4.6 Proper time formatting (HH:MM:SS) ✅ **FIXED**&#10;&#10;---&#10;&#10;##  **HOTFIX SECTION** ✅ **ALL COMPLETED**&#10;&#10;### Timer &amp; Time Display Issues ✅&#10;- [x] **HF-1**: Fix timer display format (was showing weird increments like 1,3,5,7...)&#10;  - ✅ FIXED: Timer now shows proper HH:MM:SS format&#10;  - ✅ FIXED: Standard stopwatch behavior (00:00:01, 00:00:02, etc.)&#10;&#10;- [x] **HF-2**: Fix total exercise time calculation&#10;  - ✅ FIXED: Total time shows accurate values&#10;  - ✅ FIXED: Consistent time calculations including rest periods&#10;  - ✅ FIXED: Rest time properly captured and added to total&#10;&#10;- [x] **HF-3**: Remove &quot;Mark as Done&quot; button confusion&#10;  - ✅ FIXED: Simplified to Start → Stop → Completed flow&#10;  - ✅ FIXED: Clean UX with single action buttons&#10;&#10;- [x] **HF-4**: Fix total time live updates&#10;  - ✅ FIXED: Total time only updates when set completes&#10;  - ✅ FIXED: No more live updates during active sets&#10;&#10;### UI/UX Improvements ✅&#10;- [x] **HF-5**: Color scheme improvements (black text, yellow accents)&#10;- [x] **HF-6**: Exercise completion state persistence&#10;- [x] **HF-7**: Set counter display accuracy&#10;- [x] **HF-8**: Database reset functionality&#10;&#10;### Rest Timer Implementation ✅ **NEW - COMPLETED**&#10;- [x] **HF-9**: Complete rest timer functionality&#10;  - ✅ FIXED: Rest timer starts automatically after set completion&#10;  - ✅ FIXED: Rest time captured and added to total exercise time&#10;  - ✅ FIXED: Rest timer stops when next set starts&#10;  - ✅ FIXED: Total time = completed set times + accumulated rest time&#10;  - ✅ TESTED: Manual testing confirms expected behavior&#10;&#10;---&#10;&#10;## Phase 2: Set Data Collection &amp; Management  **NEXT PRIORITY**&#10;&#10;### 2.1 Set Performance Data Entry ⭐ **NEW REQUIREMENT**&#10;- [x] 2.1.1 Add database fields for set performance data&#10;  - Add `reps_performed` (INT) to set_entries table&#10;  - Add `weight_used` (DECIMAL/FLOAT) to set_entries table&#10;  - Create database migration for new fields&#10;  - Update SetEntry entity and DAO methods&#10;&#10;- [x] 2.1.2 Set completion popup with data entry&#10;  - Create popup/dialog component for set data entry&#10;  - Two required text fields: &quot;Reps Performed&quot; and &quot;Weight Used&quot;&#10;  - Mandatory fields - no cancel button, only &quot;ADD&quot; button&#10;  - Popup appears when user completes a set (stops timer)&#10;  - Rest timer continues running in background during data entry&#10;&#10;- [x] 2.1.3 Set data persistence and validation&#10;  - Save reps and weight data to database on popup submit&#10;  - Input validation (positive numbers, reasonable ranges)&#10;  - Update set completion flow to include data entry step&#10;  - Handle data persistence errors gracefully&#10;&#10;### 2.2 Set Data Editing &amp; Management  **NEW REQUIREMENT**&#10;- [x] 2.2.1 Edit completed set data ✅ **COMPLETED**&#10;  - Allow users to edit reps/weight after set completion ✅&#10;  - Add edit button/icon to completed set cards ✅&#10;  - Reopen data entry popup with pre-filled values ✅&#10;  - Update database with edited values ✅&#10;&#10;- [x] 2.2.2 Dynamic set management ✅ **COMPLETED**&#10;  - Add &quot;+&quot; button to add extra sets to exercise ✅&#10;  - Add &quot;−&quot; button to remove sets from exercise (if not completed) ✅&#10;  - Update exercise completion logic for dynamic set counts ✅&#10;  - Maintain proper set numbering when adding/removing sets ✅&#10;&#10;- [x] 2.2.3 Enhanced set display ✅ **COMPLETED**&#10;  - Show reps and weight data on set cards ✅&#10;  - Display format: &quot;Set 1: 12 reps @ 135 lbs&quot; (when completed) ✅&#10;  - Show &quot;Set 1: — reps @ — lbs&quot; (when not completed) ✅&#10;  - Visual distinction between completed and pending sets ✅&#10;&#10;### 2.3 Data Validation &amp; UX Improvements  &#10;- [ ] 2.3.1 Input validation and user guidance&#10;  - Numeric keyboard for reps and weight fields&#10;  - Input hints and placeholders (&quot;e.g., 12&quot;, &quot;e.g., 135.5&quot;)&#10;  - Validation messages for invalid inputs&#10;  - Auto-focus progression between fields&#10;&#10;- [x] 2.3.2 Enhanced timer integration ✅&#10;  - Rest timer continues during data entry popup ✅&#10;  - Clear visual indication that rest timer is still running ✅&#10;  - Seamless transition from set completion → data entry → rest period ✅&#10;  - Timer state preservation across popup interactions ✅&#10;&#10;- [x] 2.3.3 Rest timer notification system ✅&#10;  - One-minute rest milestone notification with sound ✅ &#10;  - Notification permission handling for Android 13+ ✅&#10;  - Proper notification channel setup with sound and vibration ✅&#10;  - Heads-up notification display for better visibility ✅&#10;  - Automatic notification cancellation when rest ends ✅&#10;&#10;- [ ] 2.3.4 Additional UX enhancements&#10;  - Haptic feedback for important actions&#10;  - Animation transitions between screens&#10;  - Accessibility improvements&#10;&#10;---&#10;&#10;## Phase 3: Enhanced Exercise Experience  **PLANNED**&#10;- [ ] 3.1.1 Exercise instruction screens&#10;- [ ] 3.1.2 Exercise tips and form cues&#10;- [ ] 3.1.3 Primary/secondary muscle groups display&#10;- [ ] 3.1.4 Equipment requirements display&#10;- [ ] 3.1.5 Exercise difficulty indicators&#10;&#10;### 3.2 Calendar &amp; History View  **PLANNED**&#10;- [ ] 3.2.1 Calendar navigation&#10;- [ ] 3.2.2 Historical workout data view&#10;- [ ] 3.2.3 Progress tracking over time&#10;- [ ] 3.2.4 Workout completion statistics&#10;&#10;---&#10;&#10;## Phase 4: Advanced Features  **PLANNED**&#10;&#10;### 4.1 Location Services&#10;- [ ] 4.1.1 Gym location detection&#10;- [ ] 4.1.2 Location-based notifications&#10;- [ ] 4.1.3 Gym check-in tracking&#10;&#10;### 4.2 Data Management&#10;- [ ] 4.2.1 Data export functionality&#10;- [ ] 4.2.2 Backup/restore system&#10;- [ ] 4.2.3 30-day data cleanup job&#10;- [ ] 4.2.4 Data migration handling&#10;&#10;### 4.3 Enhanced UX&#10;- [ ] 4.3.1 Dark mode support&#10;- [ ] 4.3.2 Accessibility improvements&#10;- [ ] 4.3.3 Animations and transitions&#10;- [ ] 4.3.4 Haptic feedback&#10;&#10;---&#10;&#10;## Development Status&#10;&#10;### Current Achievement: PHASE 1 COMPLETE! &#10;**Major Milestone**: All core functionality is now solid and reliable!&#10;&#10;✅ **Database &amp; Architecture** - Robust Room implementation&#10;✅ **Timer System** - Professional-grade stopwatch with rest periods&#10;✅ **Workout Flow** - Smooth set progression and completion tracking&#10;✅ **UI/UX Foundation** - Clean, consistent Material Design 3 interface&#10;✅ **Data Persistence** - Reliable workout state management&#10;&#10;### Next Priority: Phase 2.1 - Set Data Collection &amp; Management&#10;**Focus**: Comprehensive workout tracking with performance data&#10;&#10;**Benefits for Users**:&#10;- Track actual reps performed and weight used per set&#10;- Progressive overload monitoring for strength gains&#10;- Flexible set management (add/remove sets during workout)&#10;- Professional workout data collection and analytics&#10;&#10;### Implementation Ready:&#10;The app now has a solid foundation with:&#10;- ✅ Accurate timer system (including rest periods)&#10;- ✅ Reliable data persistence&#10;- ✅ Clean user interface&#10;- ✅ Proper error handling&#10;- ✅ Comprehensive logging for debugging&#10;&#10;**Ready to implement**:&#10;- Database schema updates for reps_performed and weight_used&#10;- Set completion popup with mandatory data entry&#10;- Dynamic set management (+/- buttons)&#10;- Enhanced set display with performance data&#10;&#10;---&#10;&#10;## Testing Status&#10;&#10;### Core Functionality ✅ **ALL VERIFIED**&#10;- [x] App starts without crashes&#10;- [x] Workout creation for current day&#10;- [x] Exercise navigation&#10;- [x] Set completion tracking&#10;- [x] Database persistence&#10;- [x] Timer accuracy and formatting&#10;- [x] Rest timer functionality&#10;- [x] Total time calculations (including rest periods)&#10;&#10;### Ready for Phase 2 Implementation ✅&#10;All Phase 1 requirements have been implemented and tested successfully.&#10;Database and architecture are ready for performance data collection features.&#10;&#10;---&#10;&#10;*Last Updated: July 31, 2025*&#10;*Current Status: Phase 1 Complete ✅ | Ready for Phase 2.1 *&#10;" />
              <option name="updatedContent" value="# ️ PPL Workout App - Migration Roadmap&#10;&#10;## Overview&#10;This document outlines the migration path from the current simplified architecture to the advanced, production-ready architecture shown in the database and workflow diagrams.&#10;&#10;## Current State Analysis ✅&#10;&#10;### Database Schema (Working) - Version 7&#10;- [x] **exercises** table: Enhanced with rich metadata (primaryMuscle, secondaryMuscles, equipment, difficulty, instructions, tips, category) ✅&#10;- [x] **workout_days** table: Stores daily workout sessions ✅&#10;- [x] **workout_entries** table: Links exercises to workout days ✅&#10;- [x] **set_entries** table: Individual set tracking with timing ✅&#10;- [x] **workout_templates** table: Template definitions for reusable workouts ✅&#10;- [x] **template_exercises** table: Junction table linking templates to exercises ✅&#10;&#10;### Features Working ✅&#10;- [x] PPL workout creation based on day of week&#10;- [x] **Template-based workout creation system** ✅&#10;- [x] Exercise detail screens with set progression&#10;- [x] Individual set timing and completion tracking&#10;- [x] Cross-exercise contamination fixed (sets isolated per exercise)&#10;- [x] Database reset functionality for development&#10;- [x] Timer functionality with start/stop per set&#10;- [x] Enhanced exercise library with rich metadata (34+ exercises)&#10;- [x] Automatic template population on database creation&#10;- [x] Template selection and creation methods&#10;&#10;### Current Architecture Status&#10;- **Exercise Library**: Rich metadata with 34+ exercises in `ExerciseData.getPPLExercises()` ✅&#10;- **Template System**: Complete entities, DAOs, and repository methods ✅&#10;- **Workout Logic**: **Both day-based AND template-based systems working** ✅&#10;- **Database Version**: 7 (with complete template system migration)&#10;- **UI Layer**: Daily workout screens with template integration ✅&#10;&#10;---&#10;&#10;## Phase 1: Core Foundation ✅ **COMPLETED**&#10;&#10;### 1.1 Project Setup &amp; Database ✅&#10;- [x] 1.1.1 Android project with Kotlin &amp; Compose&#10;- [x] 1.1.2 Room database implementation&#10;- [x] 1.1.3 Entity models (WorkoutDay, Exercise, WorkoutEntry, SetEntry)&#10;- [x] 1.1.4 DAO implementations&#10;- [x] 1.1.5 Repository pattern&#10;&#10;### 1.2 Basic UI &amp; Navigation ✅&#10;- [x] 1.2.1 Material Design 3 theme&#10;- [x] 1.2.2 Navigation between screens&#10;- [x] 1.2.3 Daily workout view&#10;- [x] 1.2.4 Exercise list screen&#10;- [x] 1.2.5 Exercise detail screen&#10;&#10;### 1.3 Workout Logic ✅&#10;- [x] 1.3.1 PPL schedule implementation (6-day rotation)&#10;- [x] 1.3.2 Rest day handling with background image&#10;- [x] 1.3.3 Workout day creation and exercise population&#10;- [x] 1.3.4 Set tracking and completion logic&#10;- [x] 1.3.5 Exercise progress tracking&#10;&#10;### 1.4 Timer &amp; Time Tracking ✅ **COMPLETED**&#10;- [x] 1.4.1 Individual set timers (start/stop functionality)&#10;- [x] 1.4.2 Total exercise time calculation&#10;- [x] 1.4.3 Set completion tracking&#10;- [x] 1.4.4 Sequential set unlocking&#10;- [x] 1.4.5 Rest period timer implementation ✅ **FIXED**&#10;- [x] 1.4.6 Proper time formatting (HH:MM:SS) ✅ **FIXED**&#10;&#10;---&#10;&#10;##  **HOTFIX SECTION** ✅ **ALL COMPLETED**&#10;&#10;### Timer &amp; Time Display Issues ✅&#10;- [x] **HF-1**: Fix timer display format (was showing weird increments like 1,3,5,7...)&#10;  - ✅ FIXED: Timer now shows proper HH:MM:SS format&#10;  - ✅ FIXED: Standard stopwatch behavior (00:00:01, 00:00:02, etc.)&#10;&#10;- [x] **HF-2**: Fix total exercise time calculation&#10;  - ✅ FIXED: Total time shows accurate values&#10;  - ✅ FIXED: Consistent time calculations including rest periods&#10;  - ✅ FIXED: Rest time properly captured and added to total&#10;&#10;- [x] **HF-3**: Remove &quot;Mark as Done&quot; button confusion&#10;  - ✅ FIXED: Simplified to Start → Stop → Completed flow&#10;  - ✅ FIXED: Clean UX with single action buttons&#10;&#10;- [x] **HF-4**: Fix total time live updates&#10;  - ✅ FIXED: Total time only updates when set completes&#10;  - ✅ FIXED: No more live updates during active sets&#10;&#10;### UI/UX Improvements ✅&#10;- [x] **HF-5**: Color scheme improvements (black text, yellow accents)&#10;- [x] **HF-6**: Exercise completion state persistence&#10;- [x] **HF-7**: Set counter display accuracy&#10;- [x] **HF-8**: Database reset functionality&#10;&#10;### Rest Timer Implementation ✅ **NEW - COMPLETED**&#10;- [x] **HF-9**: Complete rest timer functionality&#10;  - ✅ FIXED: Rest timer starts automatically after set completion&#10;  - ✅ FIXED: Rest time captured and added to total exercise time&#10;  - ✅ FIXED: Rest timer stops when next set starts&#10;  - ✅ FIXED: Total time = completed set times + accumulated rest time&#10;  - ✅ TESTED: Manual testing confirms expected behavior&#10;&#10;---&#10;&#10;## Phase 2: Set Data Collection &amp; Management  **NEXT PRIORITY**&#10;&#10;### 2.1 Set Performance Data Entry ⭐ **NEW REQUIREMENT**&#10;- [x] 2.1.1 Add database fields for set performance data&#10;  - Add `reps_performed` (INT) to set_entries table&#10;  - Add `weight_used` (DECIMAL/FLOAT) to set_entries table&#10;  - Create database migration for new fields&#10;  - Update SetEntry entity and DAO methods&#10;&#10;- [x] 2.1.2 Set completion popup with data entry&#10;  - Create popup/dialog component for set data entry&#10;  - Two required text fields: &quot;Reps Performed&quot; and &quot;Weight Used&quot;&#10;  - Mandatory fields - no cancel button, only &quot;ADD&quot; button&#10;  - Popup appears when user completes a set (stops timer)&#10;  - Rest timer continues running in background during data entry&#10;&#10;- [x] 2.1.3 Set data persistence and validation&#10;  - Save reps and weight data to database on popup submit&#10;  - Input validation (positive numbers, reasonable ranges)&#10;  - Update set completion flow to include data entry step&#10;  - Handle data persistence errors gracefully&#10;&#10;### 2.2 Set Data Editing &amp; Management  **NEW REQUIREMENT**&#10;- [x] 2.2.1 Edit completed set data ✅ **COMPLETED**&#10;  - Allow users to edit reps/weight after set completion ✅&#10;  - Add edit button/icon to completed set cards ✅&#10;  - Reopen data entry popup with pre-filled values ✅&#10;  - Update database with edited values ✅&#10;&#10;- [x] 2.2.2 Dynamic set management ✅ **COMPLETED**&#10;  - Add &quot;+&quot; button to add extra sets to exercise ✅&#10;  - Add &quot;−&quot; button to remove sets from exercise (if not completed) ✅&#10;  - Update exercise completion logic for dynamic set counts ✅&#10;  - Maintain proper set numbering when adding/removing sets ✅&#10;&#10;- [x] 2.2.3 Enhanced set display ✅ **COMPLETED**&#10;  - Show reps and weight data on set cards ✅&#10;  - Display format: &quot;Set 1: 12 reps @ 135 lbs&quot; (when completed) ✅&#10;  - Show &quot;Set 1: — reps @ — lbs&quot; (when not completed) ✅&#10;  - Visual distinction between completed and pending sets ✅&#10;&#10;### 2.3 Data Validation &amp; UX Improvements  &#10;- [ ] 2.3.1 Input validation and user guidance&#10;  - Numeric keyboard for reps and weight fields&#10;  - Input hints and placeholders (&quot;e.g., 12&quot;, &quot;e.g., 135.5&quot;)&#10;  - Validation messages for invalid inputs&#10;  - Auto-focus progression between fields&#10;&#10;- [x] 2.3.2 Enhanced timer integration ✅&#10;  - Rest timer continues during data entry popup ✅&#10;  - Clear visual indication that rest timer is still running ✅&#10;  - Seamless transition from set completion → data entry → rest period ✅&#10;  - Timer state preservation across popup interactions ✅&#10;&#10;- [x] 2.3.3 Rest timer notification system ✅&#10;  - One-minute rest milestone notification with sound ✅ &#10;  - Notification permission handling for Android 13+ ✅&#10;  - Proper notification channel setup with sound and vibration ✅&#10;  - Heads-up notification display for better visibility ✅&#10;  - Automatic notification cancellation when rest ends ✅&#10;&#10;- [x] 2.3.4 Additional UX enhancements ✅&#10;  - Proper back button navigation handling ✅&#10;  - System back button override to prevent accidental app exit ✅&#10;  - Consistent navigation between screens ✅&#10;  - [ ] Haptic feedback for important actions&#10;  - [ ] Animation transitions between screens&#10;  - [ ] Accessibility improvements&#10;&#10;---&#10;&#10;## Phase 3: Enhanced Exercise Experience  **PLANNED**&#10;- [ ] 3.1.1 Exercise instruction screens&#10;- [ ] 3.1.2 Exercise tips and form cues&#10;- [ ] 3.1.3 Primary/secondary muscle groups display&#10;- [ ] 3.1.4 Equipment requirements display&#10;- [ ] 3.1.5 Exercise difficulty indicators&#10;&#10;### 3.2 Calendar &amp; History View  **PLANNED**&#10;- [ ] 3.2.1 Calendar navigation&#10;- [ ] 3.2.2 Historical workout data view&#10;- [ ] 3.2.3 Progress tracking over time&#10;- [ ] 3.2.4 Workout completion statistics&#10;&#10;---&#10;&#10;## Phase 4: Advanced Features  **PLANNED**&#10;&#10;### 4.1 Location Services&#10;- [ ] 4.1.1 Gym location detection&#10;- [ ] 4.1.2 Location-based notifications&#10;- [ ] 4.1.3 Gym check-in tracking&#10;&#10;### 4.2 Data Management&#10;- [ ] 4.2.1 Data export functionality&#10;- [ ] 4.2.2 Backup/restore system&#10;- [ ] 4.2.3 30-day data cleanup job&#10;- [ ] 4.2.4 Data migration handling&#10;&#10;### 4.3 Enhanced UX&#10;- [ ] 4.3.1 Dark mode support&#10;- [ ] 4.3.2 Accessibility improvements&#10;- [ ] 4.3.3 Animations and transitions&#10;- [ ] 4.3.4 Haptic feedback&#10;&#10;---&#10;&#10;## Development Status&#10;&#10;### Current Achievement: PHASE 1 COMPLETE! &#10;**Major Milestone**: All core functionality is now solid and reliable!&#10;&#10;✅ **Database &amp; Architecture** - Robust Room implementation&#10;✅ **Timer System** - Professional-grade stopwatch with rest periods&#10;✅ **Workout Flow** - Smooth set progression and completion tracking&#10;✅ **UI/UX Foundation** - Clean, consistent Material Design 3 interface&#10;✅ **Data Persistence** - Reliable workout state management&#10;&#10;### Next Priority: Phase 2.1 - Set Data Collection &amp; Management&#10;**Focus**: Comprehensive workout tracking with performance data&#10;&#10;**Benefits for Users**:&#10;- Track actual reps performed and weight used per set&#10;- Progressive overload monitoring for strength gains&#10;- Flexible set management (add/remove sets during workout)&#10;- Professional workout data collection and analytics&#10;&#10;### Implementation Ready:&#10;The app now has a solid foundation with:&#10;- ✅ Accurate timer system (including rest periods)&#10;- ✅ Reliable data persistence&#10;- ✅ Clean user interface&#10;- ✅ Proper error handling&#10;- ✅ Comprehensive logging for debugging&#10;&#10;**Ready to implement**:&#10;- Database schema updates for reps_performed and weight_used&#10;- Set completion popup with mandatory data entry&#10;- Dynamic set management (+/- buttons)&#10;- Enhanced set display with performance data&#10;&#10;---&#10;&#10;## Testing Status&#10;&#10;### Core Functionality ✅ **ALL VERIFIED**&#10;- [x] App starts without crashes&#10;- [x] Workout creation for current day&#10;- [x] Exercise navigation&#10;- [x] Set completion tracking&#10;- [x] Database persistence&#10;- [x] Timer accuracy and formatting&#10;- [x] Rest timer functionality&#10;- [x] Total time calculations (including rest periods)&#10;&#10;### Ready for Phase 2 Implementation ✅&#10;All Phase 1 requirements have been implemented and tested successfully.&#10;Database and architecture are ready for performance data collection features.&#10;&#10;---&#10;&#10;*Last Updated: July 31, 2025*&#10;*Current Status: Phase 1 Complete ✅ | Ready for Phase 2.1 *" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.OfflinePPLWorkOutApp&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.OfflinePPLWorkOutApp&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Add permission for notifications on Android 13+ --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.OfflinePPLWorkOutApp&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.OfflinePPLWorkOutApp&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/MainActivity.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import kotlinx.coroutines.launch&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.screens.ExerciseDetailScreen&#10;import com.example.offlinepplworkoutapp.ui.theme.OfflinePPLWorkOutAppTheme&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModelFactory&#10;import com.example.offlinepplworkoutapp.util.NotificationHelper&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;private const val IS_DEBUG_MODE = true&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var database: PPLWorkoutDatabase&#10;    private lateinit var repository: WorkoutRepository&#10;&#10;    // Initialize notification helper&#10;    private lateinit var notificationHelper: NotificationHelper&#10;&#10;    // Request notification permission launcher for Android 13+&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            println(&quot; NOTIFICATION: Permission granted&quot;)&#10;        } else {&#10;            println(&quot; NOTIFICATION: Permission denied&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Initialize database and repository&#10;        database = PPLWorkoutDatabase.getDatabase(this)&#10;        repository = WorkoutRepository(&#10;            workoutDayDao = database.workoutDayDao(),&#10;            workoutEntryDao = database.workoutEntryDao(),&#10;            setEntryDao = database.setEntryDao(),&#10;            workoutTemplateDao = database.workoutTemplateDao(),&#10;            templateExerciseDao = database.templateExerciseDao()&#10;        )&#10;&#10;        // Initialize notification helper and request permissions if needed&#10;        notificationHelper = NotificationHelper(this)&#10;        notificationHelper.createChannels()&#10;&#10;        // Request notification permission on Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (checkSelfPermission(Manifest.permission.POST_NOTIFICATIONS) !=&#10;                    PackageManager.PERMISSION_GRANTED) {&#10;                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                println(&quot; NOTIFICATION: Requesting notification permission&quot;)&#10;            } else {&#10;                println(&quot; NOTIFICATION: Permission already granted&quot;)&#10;            }&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            OfflinePPLWorkOutAppTheme {&#10;                MainScreen(repository = repository)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainScreen(&#10;    repository: WorkoutRepository&#10;) {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val viewModel: DailyWorkoutViewModel = viewModel(&#10;        factory = DailyWorkoutViewModelFactory(repository)&#10;    )&#10;&#10;    var showDebugMenu by remember { mutableStateOf(false) }&#10;    var selectedExercise by remember { mutableStateOf&lt;WorkoutEntryWithExercise?&gt;(null) }&#10;    var showResetConfirmation by remember { mutableStateOf(false) }&#10;    var showTemplateSelection by remember { mutableStateOf(false) }&#10;    val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Add reset confirmation dialog&#10;    if (showResetConfirmation) {&#10;        AlertDialog(&#10;            onDismissRequest = { showResetConfirmation = false },&#10;            title = {&#10;                Text(&#10;                    text = &quot;⚠️ Reset Workout Progress&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.error&#10;                )&#10;            },&#10;            text = {&#10;                Text(&#10;                    text = &quot;This will clear all your workout progress and history, but keep your exercise library intact.\n\nThis action cannot be undone. Are you sure you want to continue?&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        // Use coroutineScope.launch to call the suspend function properly&#10;                        coroutineScope.launch {&#10;                            println(&quot; UI: Starting reset process...&quot;)&#10;&#10;                            // Verify what's in database before reset&#10;                            val beforeReset = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                            println(&quot; BEFORE RESET: ${beforeReset.first} days, ${beforeReset.second} entries, ${beforeReset.third} sets&quot;)&#10;&#10;                            // Use the more aggressive reset that forces database recreation&#10;                            PPLWorkoutDatabase.forceResetDatabase(context)&#10;&#10;                            // Wait a moment for database operations to complete&#10;                            kotlinx.coroutines.delay(500)&#10;&#10;                            // Verify database is actually empty after reset&#10;                            val afterReset = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                            println(&quot; AFTER RESET: ${afterReset.first} days, ${afterReset.second} entries, ${afterReset.third} sets&quot;)&#10;&#10;                            // Force complete refresh of the ViewModel data&#10;                            println(&quot; UI: Forcing ViewModel refresh...&quot;)&#10;                            viewModel.forceCompleteRefresh()&#10;&#10;                            // Close dialogs&#10;                            showResetConfirmation = false&#10;                            showDebugMenu = false&#10;&#10;                            println(&quot;✅ UI: Reset process complete!&quot;)&#10;                        }&#10;                    },&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = MaterialTheme.colorScheme.error&#10;                    )&#10;                ) {&#10;                    Text(&quot;Reset All Progress&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                OutlinedButton(onClick = { showResetConfirmation = false }) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = Modifier.fillMaxSize(),&#10;        floatingActionButton = {&#10;            // Only show debug FAB in debug builds when not in exercise detail&#10;            if (IS_DEBUG_MODE &amp;&amp; selectedExercise == null) {&#10;                FloatingActionButton(&#10;                    onClick = { showDebugMenu = true },&#10;                    containerColor = MaterialTheme.colorScheme.secondary&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.DateRange,&#10;                        contentDescription = &quot;Debug Day Selector&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        when {&#10;            showTemplateSelection -&gt; {&#10;                // Show Template Selection Screen&#10;                com.example.offlinepplworkoutapp.ui.screens.TemplateSelectionScreen(&#10;                    repository = repository,&#10;                    selectedDate = viewModel.currentDate.collectAsState().value,&#10;                    onTemplateSelected = { template -&gt;&#10;                        viewModel.selectTemplate(template)&#10;                        viewModel.createWorkoutFromSelectedTemplate()&#10;                        showTemplateSelection = false&#10;                    },&#10;                    onBackClick = { showTemplateSelection = false }&#10;                )&#10;            }&#10;            selectedExercise != null -&gt; {&#10;                // Show Exercise Detail Screen&#10;                ExerciseDetailScreen(&#10;                    workoutEntry = selectedExercise!!,&#10;                    repository = repository,&#10;                    onBackClick = {&#10;                        // Force a refresh of workout data when returning from detail screen&#10;                        viewModel.refreshTodaysWorkout()&#10;                        selectedExercise = null&#10;                        viewModel.refreshTodaysWorkout()&#10;                    },&#10;                    onSaveChanges = { sets, reps, isCompleted -&gt;&#10;                        viewModel.updateExercise(selectedExercise!!.id, sets, reps, isCompleted)&#10;                        // Force a refresh to ensure updated set count is displayed&#10;                        viewModel.refreshTodaysWorkout()&#10;                    }&#10;                )&#10;            }&#10;            else -&gt; {&#10;                // Show Daily Workout Screen&#10;                DailyWorkoutScreen(&#10;                    viewModel = viewModel,&#10;                    repository = repository,&#10;                    onExerciseClick = { exercise -&gt; selectedExercise = exercise },&#10;                    onTemplateSelectionClick = { showTemplateSelection = true },&#10;                    modifier = Modifier.padding(innerPadding)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Debug day selector dialog&#10;        if (showDebugMenu &amp;&amp; IS_DEBUG_MODE) {&#10;            DebugDaySelector(&#10;                onDaySelected = { dayOfWeek -&gt;&#10;                    val calendar = Calendar.getInstance().apply {&#10;                        set(Calendar.DAY_OF_WEEK, dayOfWeek)&#10;                    }&#10;                    val debugDate = dateFormat.format(calendar.time)&#10;                    viewModel.setDebugDate(debugDate)&#10;                    showDebugMenu = false&#10;                },&#10;                onDismiss = { showDebugMenu = false }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DailyWorkoutScreen(&#10;    viewModel: DailyWorkoutViewModel,&#10;    repository: WorkoutRepository,&#10;    modifier: Modifier = Modifier,&#10;    onExerciseClick: (WorkoutEntryWithExercise) -&gt; Unit = {},&#10;    onTemplateSelectionClick: () -&gt; Unit = {}&#10;) {&#10;&#10;    val todaysWorkout by viewModel.todaysWorkout.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val completionProgress by viewModel.completionProgress.collectAsState()&#10;    val timerSeconds by viewModel.timerSeconds.collectAsState()&#10;    val isTimerRunning by viewModel.isTimerRunning.collectAsState()&#10;&#10;    var showResetWarning by remember { mutableStateOf(false) }&#10;    var exerciseToReset by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header with day, workout type, and timer&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;${viewModel.getCurrentDayName()}'s Workout&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = viewModel.getWorkoutTypeName(),&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;            }&#10;&#10;            // Timer Display in top-right corner&#10;            if (isTimerRunning) {&#10;                Card(&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                    ),&#10;                    modifier = Modifier.padding(start = 16.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(12.dp),&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.PlayArrow,&#10;                            contentDescription = &quot;Timer&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary,&#10;                            modifier = Modifier.size(20.dp)&#10;                        )&#10;                        Text(&#10;                            text = viewModel.formatTime(timerSeconds),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Progress indicator for non-rest days&#10;        if (todaysWorkout.isNotEmpty()) {&#10;            WorkoutProgressIndicator(&#10;                progress = completionProgress,&#10;                completionPercentage = viewModel.getCompletionPercentage(),&#10;                modifier = Modifier.padding(bottom = 16.dp)&#10;            )&#10;        }&#10;&#10;        if (isLoading) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    CircularProgressIndicator()&#10;                    Text(&#10;                        text = &quot;Loading today's workout...&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        modifier = Modifier.padding(top = 16.dp)&#10;                    )&#10;                }&#10;            }&#10;        } else if (todaysWorkout.isEmpty()) {&#10;            // Check if it's a rest day or if workout needs to be created&#10;            if (viewModel.getWorkoutTypeName() == &quot;Rest Day&quot;) {&#10;                // Rest Day with Background Image&#10;                RestDayScreen()&#10;            } else {&#10;                // Show &quot;Start Workout&quot; screen after reset or for new day&#10;                StartWorkoutScreen(&#10;                    workoutType = viewModel.getWorkoutTypeName(),&#10;                    onStartWorkout = {&#10;                        println(&quot; UI: Start Workout button clicked!&quot;)&#10;                        viewModel.createTodaysWorkout()&#10;                    },&#10;                    onTemplateSelection = onTemplateSelectionClick&#10;                )&#10;            }&#10;        } else {&#10;            // Exercise list header with template selection option&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Exercises: ${todaysWorkout.size}&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                // Template selection button&#10;                OutlinedButton(&#10;                    onClick = onTemplateSelectionClick,&#10;                    modifier = Modifier.padding(start = 8.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.DateRange,&#10;                        contentDescription = &quot;Change Template&quot;,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = &quot;Change Template&quot;,&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;                }&#10;            }&#10;&#10;            LazyColumn {&#10;                items(todaysWorkout) { workoutEntry -&gt;&#10;                    WorkoutExerciseItemWithSetProgress(&#10;                        workoutEntry = workoutEntry,&#10;                        onClick = onExerciseClick,&#10;                        repository = repository&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Auto-save logic when all exercises are completed&#10;    if (completionProgress == 1.0f) {&#10;        viewModel.saveTotalTimeSpent(timerSeconds)&#10;    }&#10;&#10;    // Reset Protection Dialog&#10;    if (showResetWarning &amp;&amp; exerciseToReset != null) {&#10;        AlertDialog(&#10;            onDismissRequest = {&#10;                showResetWarning = false&#10;                exerciseToReset = null&#10;            },&#10;            title = {&#10;                Text(&#10;                    text = &quot;⚠️ Reset Exercise&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;            },&#10;            text = {&#10;                Text(&#10;                    text = &quot;This will reset your entire workout progress for this exercise. It's better to go to the exercise detail to reset specific reps.\n\nAre you sure you want to completely reset this exercise?&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        exerciseToReset?.let { exerciseId -&gt;&#10;                            val exercise = todaysWorkout.find { it.id == exerciseId }&#10;                            exercise?.let { onExerciseClick(it) }&#10;                        }&#10;                        showResetWarning = false&#10;                        exerciseToReset = null&#10;                    }&#10;                ) {&#10;                    Text(&quot;Go to Details&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        showResetWarning = false&#10;                        exerciseToReset = null&#10;                    }&#10;                ) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WorkoutProgressIndicator(&#10;    progress: Float,&#10;    completionPercentage: Int,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Workout Progress&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Text(&#10;                    text = &quot;$completionPercentage%&quot;,&#10;                    style = MaterialTheme.typography.titleLarge,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = if (completionPercentage == 100)&#10;                        MaterialTheme.colorScheme.primary&#10;                    else&#10;                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            LinearProgressIndicator(&#10;                progress = { progress },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                color = MaterialTheme.colorScheme.primary,&#10;                trackColor = MaterialTheme.colorScheme.surfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WorkoutExerciseItem(workoutEntry: WorkoutEntryWithExercise, onCompletionToggle: () -&gt; Unit, onClick: (WorkoutEntryWithExercise) -&gt; Unit = {}) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .clickable { onClick(workoutEntry) }, // Pass the workout entry when clicked&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = workoutEntry.exerciseName,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = if (workoutEntry.isCompound) &quot;Compound Exercise&quot; else &quot;Isolation Exercise&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = if (workoutEntry.isCompound)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.secondary&#10;                    )&#10;                }&#10;&#10;                // Sets and Reps display&#10;                Surface(&#10;                    color = MaterialTheme.colorScheme.primaryContainer,&#10;                    shape = MaterialTheme.shapes.small,&#10;                    modifier = Modifier.padding(start = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;${workoutEntry.sets} × ${workoutEntry.reps} reps&quot;,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Completion toggle switch&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(top = 8.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = if (workoutEntry.isCompleted) &quot;Completed&quot; else &quot;Start&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = if (workoutEntry.isCompleted)&#10;                        MaterialTheme.colorScheme.primary&#10;                    else&#10;                        Color(0xFF4CAF50), // Green color for &quot;Start&quot;&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;&#10;                Switch(&#10;                    checked = workoutEntry.isCompleted,&#10;                    onCheckedChange = { onCompletionToggle() },&#10;                    colors = SwitchDefaults.colors(&#10;                        checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                        uncheckedThumbColor = Color(0xFF4CAF50), // Green thumb when not completed&#10;                        checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,&#10;                        uncheckedTrackColor = Color(0xFF4CAF50).copy(alpha = 0.3f) // Light green track&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WorkoutExerciseItemWithTimer(workoutEntry: WorkoutEntryWithExercise, onCompletionToggle: () -&gt; Unit, onClick: (WorkoutEntryWithExercise) -&gt; Unit = {}) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .clickable { onClick(workoutEntry) }, // Pass the workout entry when clicked&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = workoutEntry.exerciseName,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = if (workoutEntry.isCompound) &quot;Compound Exercise&quot; else &quot;Isolation Exercise&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = if (workoutEntry.isCompound)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.secondary&#10;                    )&#10;                }&#10;&#10;                // Sets and Reps display&#10;                Surface(&#10;                    color = MaterialTheme.colorScheme.primaryContainer,&#10;                    shape = MaterialTheme.shapes.small,&#10;                    modifier = Modifier.padding(start = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;${workoutEntry.sets} × ${workoutEntry.reps} reps&quot;,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Completion toggle switch&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(top = 8.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = if (workoutEntry.isCompleted) &quot;Completed&quot; else &quot;Start&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = if (workoutEntry.isCompleted)&#10;                        MaterialTheme.colorScheme.primary&#10;                    else&#10;                        Color(0xFF4CAF50), // Green color for &quot;Start&quot;&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;&#10;                Switch(&#10;                    checked = workoutEntry.isCompleted,&#10;                    onCheckedChange = { onCompletionToggle() },&#10;                    colors = SwitchDefaults.colors(&#10;                        checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                        uncheckedThumbColor = Color(0xFF4CAF50), // Green thumb when not completed&#10;                        checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,&#10;                        uncheckedTrackColor = Color(0xFF4CAF50).copy(alpha = 0.3f) // Light green track&#10;                    )&#10;                )&#10;            }&#10;&#10;            // Timer display for total time spent (if exercise has time recorded)&#10;            if (workoutEntry.totalSecondsSpent &gt; 0) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 8.dp),&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Time Spent&quot;,&#10;                        tint = MaterialTheme.colorScheme.secondary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Time spent: ${workoutEntry.totalSecondsSpent / 60}:${String.format(Locale.getDefault(), &quot;%02d&quot;, workoutEntry.totalSecondsSpent % 60)}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.secondary&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WorkoutExerciseItemWithSetProgress(workoutEntry: WorkoutEntryWithExercise, onClick: (WorkoutEntryWithExercise) -&gt; Unit = {}, repository: WorkoutRepository) {&#10;    // Get the actual completed sets count from the database for this specific exercise&#10;    var completedSetsCount by remember { mutableStateOf(0) }&#10;&#10;    // Load the actual completed sets for this specific workout entry&#10;    LaunchedEffect(workoutEntry.id) {&#10;        completedSetsCount = repository.getCompletedSetsCount(workoutEntry.id)&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .clickable { onClick(workoutEntry) },&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = workoutEntry.exerciseName,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = if (workoutEntry.isCompound) &quot;Compound Exercise&quot; else &quot;Isolation Exercise&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = if (workoutEntry.isCompound)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.secondary&#10;                    )&#10;                }&#10;&#10;                // Sets and Reps display&#10;                Surface(&#10;                    color = MaterialTheme.colorScheme.primaryContainer,&#10;                    shape = MaterialTheme.shapes.small,&#10;                    modifier = Modifier.padding(start = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;${workoutEntry.sets} × ${workoutEntry.reps} reps&quot;,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Set Progress Bar and Status - NOW USING ACTUAL COMPLETED SETS FROM DATABASE&#10;            val progress = if (workoutEntry.sets &gt; 0) completedSetsCount.toFloat() / workoutEntry.sets.toFloat() else 0f&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = if (workoutEntry.isCompleted) &quot;✅ Completed&quot; else &quot;Set $completedSetsCount/${workoutEntry.sets}&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = if (workoutEntry.isCompleted)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        fontWeight = if (workoutEntry.isCompleted) FontWeight.Bold else FontWeight.Normal&#10;                    )&#10;&#10;                    if (!workoutEntry.isCompleted) {&#10;                        LinearProgressIndicator(&#10;                            progress = { progress },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(top = 4.dp),&#10;                            color = MaterialTheme.colorScheme.primary,&#10;                            trackColor = MaterialTheme.colorScheme.surfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Total time spent display&#10;                if (workoutEntry.totalSecondsSpent &gt; 0) {&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                        modifier = Modifier.padding(start = 16.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.PlayArrow,&#10;                            contentDescription = &quot;Time Spent&quot;,&#10;                            tint = MaterialTheme.colorScheme.secondary,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;${workoutEntry.totalSecondsSpent / 60}:${String.format(&quot;%02d&quot;, workoutEntry.totalSecondsSpent % 60)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.secondary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RestDayScreen() {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Background image - your awesome Hanuman gym mural&#10;        Image(&#10;            painter = painterResource(id = R.drawable.rest_day),&#10;            contentDescription = &quot;Rest Day Background&quot;,&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;&#10;        // Overlay content with semi-transparent background for better text readability&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(32.dp),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(24.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;‍♂️&quot;,&#10;                        style = MaterialTheme.typography.displayLarge,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;Rest Day&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;Recovery is just as important as training&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        textAlign = TextAlign.Center,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;Take time to rest, stretch, and prepare for tomorrow's workout!&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        textAlign = TextAlign.Center,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DebugDaySelector(&#10;    onDaySelected: (Int) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&#10;                text = &quot; Debug Day Selector&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        },&#10;        text = {&#10;            LazyColumn {&#10;                item {&#10;                    Text(&#10;                        text = &quot;Select a day to test different workouts:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                }&#10;&#10;                val days = listOf(&#10;                    Calendar.MONDAY to &quot;Monday - Push Day 1 &quot;,&#10;                    Calendar.TUESDAY to &quot;Tuesday - Pull Day 1 ️&quot;,&#10;                    Calendar.WEDNESDAY to &quot;Wednesday - Legs Day 1 &quot;,&#10;                    Calendar.THURSDAY to &quot;Thursday - Push Day 2 &quot;,&#10;                    Calendar.FRIDAY to &quot;Friday - Pull Day 2 ️&quot;,&#10;                    Calendar.SATURDAY to &quot;Saturday - Legs Day 2 &quot;,&#10;                    Calendar.SUNDAY to &quot;Sunday - Rest Day ‍♂️&quot;&#10;                )&#10;&#10;                items(days) { (dayOfWeek, dayLabel) -&gt;&#10;                    OutlinedButton(&#10;                        onClick = { onDaySelected(dayOfWeek) },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 4.dp),&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            containerColor = if (dayOfWeek == Calendar.SUNDAY)&#10;                                MaterialTheme.colorScheme.secondaryContainer&#10;                            else&#10;                                MaterialTheme.colorScheme.primaryContainer&#10;                        )&#10;                    ) {&#10;                        Text(&#10;                            text = dayLabel,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            modifier = Modifier.padding(8.dp)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Debug Actions:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                println(&quot; DEBUG: Checking current database state...&quot;)&#10;                                val currentState = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                                println(&quot; CURRENT STATE: ${currentState.first} days, ${currentState.second} entries, ${currentState.third} sets&quot;)&#10;                            }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.tertiary&#10;                        )&#10;                    ) {&#10;                        Text(&quot; Check DB State&quot;)&#10;                    }&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                println(&quot; DEBUG: Force reset database...&quot;)&#10;                                PPLWorkoutDatabase.forceResetDatabase(context)&#10;                                kotlinx.coroutines.delay(200)&#10;                                val afterState = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                                println(&quot; AFTER FORCE RESET: ${afterState.first} days, ${afterState.second} entries, ${afterState.third} sets&quot;)&#10;                            }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.error&#10;                        )&#10;                    ) {&#10;                        Text(&quot; Force Reset DB&quot;)&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            //TODO: Uncomment when reset functionality is implemented&#10;//            TextButton(onClick = onResetToToday) {&#10;//                Text(&quot;Reset to Today&quot;)&#10;//            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun StartWorkoutScreen(&#10;    workoutType: String,&#10;    onStartWorkout: () -&gt; Unit,&#10;    onTemplateSelection: () -&gt; Unit = {}&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(32.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = &quot;&quot;,&#10;                    style = MaterialTheme.typography.displayLarge,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Ready to Start?&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = workoutType,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(bottom = 24.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Choose how you want to start your workout:&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(bottom = 32.dp)&#10;                )&#10;&#10;                // Default workout button&#10;                Button(&#10;                    onClick = onStartWorkout,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(56.dp),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = MaterialTheme.colorScheme.primary&#10;                    )&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Start Workout&quot;,&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Start Today's Workout&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Template selection button&#10;                OutlinedButton(&#10;                    onClick = onTemplateSelection,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(56.dp),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        contentColor = MaterialTheme.colorScheme.primary&#10;                    )&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.DateRange,&#10;                        contentDescription = &quot;Choose Template&quot;,&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Choose Different Workout&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&#10;                    text = &quot; Use 'Choose Different Workout' to pick from Push, Pull, or Legs templates&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun WorkoutPreview() {&#10;    OfflinePPLWorkOutAppTheme {&#10;        // Preview with sample workout entry data&#10;        val sampleWorkoutEntry = WorkoutEntryWithExercise(&#10;            id = 1,&#10;            dayId = 1,&#10;            exerciseId = 1,&#10;            sets = 4,&#10;            reps = 8,&#10;            isCompleted = false,&#10;            exerciseName = &quot;Barbell Bench Press&quot;,&#10;            isCompound = true&#10;        )&#10;        WorkoutExerciseItem(workoutEntry = sampleWorkoutEntry, onCompletionToggle = {})&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.BackHandler&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import kotlinx.coroutines.launch&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.screens.ExerciseDetailScreen&#10;import com.example.offlinepplworkoutapp.ui.theme.OfflinePPLWorkOutAppTheme&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModelFactory&#10;import com.example.offlinepplworkoutapp.util.NotificationHelper&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;private const val IS_DEBUG_MODE = true&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var database: PPLWorkoutDatabase&#10;    private lateinit var repository: WorkoutRepository&#10;&#10;    // Initialize notification helper&#10;    private lateinit var notificationHelper: NotificationHelper&#10;&#10;    // Request notification permission launcher for Android 13+&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            println(&quot; NOTIFICATION: Permission granted&quot;)&#10;        } else {&#10;            println(&quot; NOTIFICATION: Permission denied&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Initialize database and repository&#10;        database = PPLWorkoutDatabase.getDatabase(this)&#10;        repository = WorkoutRepository(&#10;            workoutDayDao = database.workoutDayDao(),&#10;            workoutEntryDao = database.workoutEntryDao(),&#10;            setEntryDao = database.setEntryDao(),&#10;            workoutTemplateDao = database.workoutTemplateDao(),&#10;            templateExerciseDao = database.templateExerciseDao()&#10;        )&#10;&#10;        // Initialize notification helper and request permissions if needed&#10;        notificationHelper = NotificationHelper(this)&#10;        notificationHelper.createChannels()&#10;&#10;        // Request notification permission on Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (checkSelfPermission(Manifest.permission.POST_NOTIFICATIONS) !=&#10;                    PackageManager.PERMISSION_GRANTED) {&#10;                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                println(&quot; NOTIFICATION: Requesting notification permission&quot;)&#10;            } else {&#10;                println(&quot; NOTIFICATION: Permission already granted&quot;)&#10;            }&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            OfflinePPLWorkOutAppTheme {&#10;                MainScreen(repository = repository)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainScreen(&#10;    repository: WorkoutRepository&#10;) {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val viewModel: DailyWorkoutViewModel = viewModel(&#10;        factory = DailyWorkoutViewModelFactory(repository)&#10;    )&#10;&#10;    var showDebugMenu by remember { mutableStateOf(false) }&#10;    var selectedExercise by remember { mutableStateOf&lt;WorkoutEntryWithExercise?&gt;(null) }&#10;    var showResetConfirmation by remember { mutableStateOf(false) }&#10;    var showTemplateSelection by remember { mutableStateOf(false) }&#10;    val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    //  NEW: Back handler to override back button behavior&#10;    BackHandler(&#10;        enabled = selectedExercise != null || showTemplateSelection,&#10;        onBack = {&#10;            when {&#10;                selectedExercise != null -&gt; {&#10;                    // Return to main workout screen when back is pressed in exercise detail&#10;                    println(&quot; NAVIGATION: Back button pressed in exercise detail, returning to main screen&quot;)&#10;                    viewModel.refreshTodaysWorkout() // Refresh data&#10;                    selectedExercise = null&#10;                }&#10;                showTemplateSelection -&gt; {&#10;                    // Return from template selection&#10;                    println(&quot; NAVIGATION: Back button pressed in template selection, returning to main screen&quot;)&#10;                    showTemplateSelection = false&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    // Add reset confirmation dialog&#10;    if (showResetConfirmation) {&#10;        AlertDialog(&#10;            onDismissRequest = { showResetConfirmation = false },&#10;            title = {&#10;                Text(&#10;                    text = &quot;⚠️ Reset Workout Progress&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.error&#10;                )&#10;            },&#10;            text = {&#10;                Text(&#10;                    text = &quot;This will clear all your workout progress and history, but keep your exercise library intact.\n\nThis action cannot be undone. Are you sure you want to continue?&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        // Use coroutineScope.launch to call the suspend function properly&#10;                        coroutineScope.launch {&#10;                            println(&quot; UI: Starting reset process...&quot;)&#10;&#10;                            // Verify what's in database before reset&#10;                            val beforeReset = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                            println(&quot; BEFORE RESET: ${beforeReset.first} days, ${beforeReset.second} entries, ${beforeReset.third} sets&quot;)&#10;&#10;                            // Use the more aggressive reset that forces database recreation&#10;                            PPLWorkoutDatabase.forceResetDatabase(context)&#10;&#10;                            // Wait a moment for database operations to complete&#10;                            kotlinx.coroutines.delay(500)&#10;&#10;                            // Verify database is actually empty after reset&#10;                            val afterReset = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                            println(&quot; AFTER RESET: ${afterReset.first} days, ${afterReset.second} entries, ${afterReset.third} sets&quot;)&#10;&#10;                            // Force complete refresh of the ViewModel data&#10;                            println(&quot; UI: Forcing ViewModel refresh...&quot;)&#10;                            viewModel.forceCompleteRefresh()&#10;&#10;                            // Close dialogs&#10;                            showResetConfirmation = false&#10;                            showDebugMenu = false&#10;&#10;                            println(&quot;✅ UI: Reset process complete!&quot;)&#10;                        }&#10;                    },&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = MaterialTheme.colorScheme.error&#10;                    )&#10;                ) {&#10;                    Text(&quot;Reset All Progress&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                OutlinedButton(onClick = { showResetConfirmation = false }) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = Modifier.fillMaxSize(),&#10;        floatingActionButton = {&#10;            // Only show debug FAB in debug builds when not in exercise detail&#10;            if (IS_DEBUG_MODE &amp;&amp; selectedExercise == null) {&#10;                FloatingActionButton(&#10;                    onClick = { showDebugMenu = true },&#10;                    containerColor = MaterialTheme.colorScheme.secondary&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.DateRange,&#10;                        contentDescription = &quot;Debug Day Selector&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        when {&#10;            showTemplateSelection -&gt; {&#10;                // Show Template Selection Screen&#10;                com.example.offlinepplworkoutapp.ui.screens.TemplateSelectionScreen(&#10;                    repository = repository,&#10;                    selectedDate = viewModel.currentDate.collectAsState().value,&#10;                    onTemplateSelected = { template -&gt;&#10;                        viewModel.selectTemplate(template)&#10;                        viewModel.createWorkoutFromSelectedTemplate()&#10;                        showTemplateSelection = false&#10;                    },&#10;                    onBackClick = { showTemplateSelection = false }&#10;                )&#10;            }&#10;            selectedExercise != null -&gt; {&#10;                // Show Exercise Detail Screen&#10;                ExerciseDetailScreen(&#10;                    workoutEntry = selectedExercise!!,&#10;                    repository = repository,&#10;                    onBackClick = {&#10;                        // Force a refresh of workout data when returning from detail screen&#10;                        viewModel.refreshTodaysWorkout()&#10;                        selectedExercise = null&#10;                        viewModel.refreshTodaysWorkout()&#10;                    },&#10;                    onSaveChanges = { sets, reps, isCompleted -&gt;&#10;                        viewModel.updateExercise(selectedExercise!!.id, sets, reps, isCompleted)&#10;                        // Force a refresh to ensure updated set count is displayed&#10;                        viewModel.refreshTodaysWorkout()&#10;                    }&#10;                )&#10;            }&#10;            else -&gt; {&#10;                // Show Daily Workout Screen&#10;                DailyWorkoutScreen(&#10;                    viewModel = viewModel,&#10;                    repository = repository,&#10;                    onExerciseClick = { exercise -&gt; selectedExercise = exercise },&#10;                    onTemplateSelectionClick = { showTemplateSelection = true },&#10;                    modifier = Modifier.padding(innerPadding)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Debug day selector dialog&#10;        if (showDebugMenu &amp;&amp; IS_DEBUG_MODE) {&#10;            DebugDaySelector(&#10;                onDaySelected = { dayOfWeek -&gt;&#10;                    val calendar = Calendar.getInstance().apply {&#10;                        set(Calendar.DAY_OF_WEEK, dayOfWeek)&#10;                    }&#10;                    val debugDate = dateFormat.format(calendar.time)&#10;                    viewModel.setDebugDate(debugDate)&#10;                    showDebugMenu = false&#10;                },&#10;                onDismiss = { showDebugMenu = false }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DailyWorkoutScreen(&#10;    viewModel: DailyWorkoutViewModel,&#10;    repository: WorkoutRepository,&#10;    modifier: Modifier = Modifier,&#10;    onExerciseClick: (WorkoutEntryWithExercise) -&gt; Unit = {},&#10;    onTemplateSelectionClick: () -&gt; Unit = {}&#10;) {&#10;&#10;    val todaysWorkout by viewModel.todaysWorkout.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val completionProgress by viewModel.completionProgress.collectAsState()&#10;    val timerSeconds by viewModel.timerSeconds.collectAsState()&#10;    val isTimerRunning by viewModel.isTimerRunning.collectAsState()&#10;&#10;    var showResetWarning by remember { mutableStateOf(false) }&#10;    var exerciseToReset by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header with day, workout type, and timer&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;${viewModel.getCurrentDayName()}'s Workout&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = viewModel.getWorkoutTypeName(),&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;            }&#10;&#10;            // Timer Display in top-right corner&#10;            if (isTimerRunning) {&#10;                Card(&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                    ),&#10;                    modifier = Modifier.padding(start = 16.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(12.dp),&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.PlayArrow,&#10;                            contentDescription = &quot;Timer&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary,&#10;                            modifier = Modifier.size(20.dp)&#10;                        )&#10;                        Text(&#10;                            text = viewModel.formatTime(timerSeconds),&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Progress indicator for non-rest days&#10;        if (todaysWorkout.isNotEmpty()) {&#10;            WorkoutProgressIndicator(&#10;                progress = completionProgress,&#10;                completionPercentage = viewModel.getCompletionPercentage(),&#10;                modifier = Modifier.padding(bottom = 16.dp)&#10;            )&#10;        }&#10;&#10;        if (isLoading) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    CircularProgressIndicator()&#10;                    Text(&#10;                        text = &quot;Loading today's workout...&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        modifier = Modifier.padding(top = 16.dp)&#10;                    )&#10;                }&#10;            }&#10;        } else if (todaysWorkout.isEmpty()) {&#10;            // Check if it's a rest day or if workout needs to be created&#10;            if (viewModel.getWorkoutTypeName() == &quot;Rest Day&quot;) {&#10;                // Rest Day with Background Image&#10;                RestDayScreen()&#10;            } else {&#10;                // Show &quot;Start Workout&quot; screen after reset or for new day&#10;                StartWorkoutScreen(&#10;                    workoutType = viewModel.getWorkoutTypeName(),&#10;                    onStartWorkout = {&#10;                        println(&quot; UI: Start Workout button clicked!&quot;)&#10;                        viewModel.createTodaysWorkout()&#10;                    },&#10;                    onTemplateSelection = onTemplateSelectionClick&#10;                )&#10;            }&#10;        } else {&#10;            // Exercise list header with template selection option&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Exercises: ${todaysWorkout.size}&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                // Template selection button&#10;                OutlinedButton(&#10;                    onClick = onTemplateSelectionClick,&#10;                    modifier = Modifier.padding(start = 8.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.DateRange,&#10;                        contentDescription = &quot;Change Template&quot;,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = &quot;Change Template&quot;,&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;                }&#10;            }&#10;&#10;            LazyColumn {&#10;                items(todaysWorkout) { workoutEntry -&gt;&#10;                    WorkoutExerciseItemWithSetProgress(&#10;                        workoutEntry = workoutEntry,&#10;                        onClick = onExerciseClick,&#10;                        repository = repository&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Auto-save logic when all exercises are completed&#10;    if (completionProgress == 1.0f) {&#10;        viewModel.saveTotalTimeSpent(timerSeconds)&#10;    }&#10;&#10;    // Reset Protection Dialog&#10;    if (showResetWarning &amp;&amp; exerciseToReset != null) {&#10;        AlertDialog(&#10;            onDismissRequest = {&#10;                showResetWarning = false&#10;                exerciseToReset = null&#10;            },&#10;            title = {&#10;                Text(&#10;                    text = &quot;⚠️ Reset Exercise&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;            },&#10;            text = {&#10;                Text(&#10;                    text = &quot;This will reset your entire workout progress for this exercise. It's better to go to the exercise detail to reset specific reps.\n\nAre you sure you want to completely reset this exercise?&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        exerciseToReset?.let { exerciseId -&gt;&#10;                            val exercise = todaysWorkout.find { it.id == exerciseId }&#10;                            exercise?.let { onExerciseClick(it) }&#10;                        }&#10;                        showResetWarning = false&#10;                        exerciseToReset = null&#10;                    }&#10;                ) {&#10;                    Text(&quot;Go to Details&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        showResetWarning = false&#10;                        exerciseToReset = null&#10;                    }&#10;                ) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WorkoutProgressIndicator(&#10;    progress: Float,&#10;    completionPercentage: Int,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Workout Progress&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Text(&#10;                    text = &quot;$completionPercentage%&quot;,&#10;                    style = MaterialTheme.typography.titleLarge,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = if (completionPercentage == 100)&#10;                        MaterialTheme.colorScheme.primary&#10;                    else&#10;                        MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            LinearProgressIndicator(&#10;                progress = { progress },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                color = MaterialTheme.colorScheme.primary,&#10;                trackColor = MaterialTheme.colorScheme.surfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WorkoutExerciseItem(workoutEntry: WorkoutEntryWithExercise, onCompletionToggle: () -&gt; Unit, onClick: (WorkoutEntryWithExercise) -&gt; Unit = {}) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .clickable { onClick(workoutEntry) }, // Pass the workout entry when clicked&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = workoutEntry.exerciseName,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = if (workoutEntry.isCompound) &quot;Compound Exercise&quot; else &quot;Isolation Exercise&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = if (workoutEntry.isCompound)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.secondary&#10;                    )&#10;                }&#10;&#10;                // Sets and Reps display&#10;                Surface(&#10;                    color = MaterialTheme.colorScheme.primaryContainer,&#10;                    shape = MaterialTheme.shapes.small,&#10;                    modifier = Modifier.padding(start = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;${workoutEntry.sets} × ${workoutEntry.reps} reps&quot;,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Completion toggle switch&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(top = 8.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = if (workoutEntry.isCompleted) &quot;Completed&quot; else &quot;Start&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = if (workoutEntry.isCompleted)&#10;                        MaterialTheme.colorScheme.primary&#10;                    else&#10;                        Color(0xFF4CAF50), // Green color for &quot;Start&quot;&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;&#10;                Switch(&#10;                    checked = workoutEntry.isCompleted,&#10;                    onCheckedChange = { onCompletionToggle() },&#10;                    colors = SwitchDefaults.colors(&#10;                        checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                        uncheckedThumbColor = Color(0xFF4CAF50), // Green thumb when not completed&#10;                        checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,&#10;                        uncheckedTrackColor = Color(0xFF4CAF50).copy(alpha = 0.3f) // Light green track&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WorkoutExerciseItemWithTimer(workoutEntry: WorkoutEntryWithExercise, onCompletionToggle: () -&gt; Unit, onClick: (WorkoutEntryWithExercise) -&gt; Unit = {}) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .clickable { onClick(workoutEntry) }, // Pass the workout entry when clicked&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = workoutEntry.exerciseName,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = if (workoutEntry.isCompound) &quot;Compound Exercise&quot; else &quot;Isolation Exercise&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = if (workoutEntry.isCompound)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.secondary&#10;                    )&#10;                }&#10;&#10;                // Sets and Reps display&#10;                Surface(&#10;                    color = MaterialTheme.colorScheme.primaryContainer,&#10;                    shape = MaterialTheme.shapes.small,&#10;                    modifier = Modifier.padding(start = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;${workoutEntry.sets} × ${workoutEntry.reps} reps&quot;,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Completion toggle switch&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(top = 8.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = if (workoutEntry.isCompleted) &quot;Completed&quot; else &quot;Start&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = if (workoutEntry.isCompleted)&#10;                        MaterialTheme.colorScheme.primary&#10;                    else&#10;                        Color(0xFF4CAF50), // Green color for &quot;Start&quot;&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;&#10;                Switch(&#10;                    checked = workoutEntry.isCompleted,&#10;                    onCheckedChange = { onCompletionToggle() },&#10;                    colors = SwitchDefaults.colors(&#10;                        checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                        uncheckedThumbColor = Color(0xFF4CAF50), // Green thumb when not completed&#10;                        checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,&#10;                        uncheckedTrackColor = Color(0xFF4CAF50).copy(alpha = 0.3f) // Light green track&#10;                    )&#10;                )&#10;            }&#10;&#10;            // Timer display for total time spent (if exercise has time recorded)&#10;            if (workoutEntry.totalSecondsSpent &gt; 0) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 8.dp),&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Time Spent&quot;,&#10;                        tint = MaterialTheme.colorScheme.secondary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Time spent: ${workoutEntry.totalSecondsSpent / 60}:${String.format(Locale.getDefault(), &quot;%02d&quot;, workoutEntry.totalSecondsSpent % 60)}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.secondary&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WorkoutExerciseItemWithSetProgress(workoutEntry: WorkoutEntryWithExercise, onClick: (WorkoutEntryWithExercise) -&gt; Unit = {}, repository: WorkoutRepository) {&#10;    // Get the actual completed sets count from the database for this specific exercise&#10;    var completedSetsCount by remember { mutableStateOf(0) }&#10;&#10;    // Load the actual completed sets for this specific workout entry&#10;    LaunchedEffect(workoutEntry.id) {&#10;        completedSetsCount = repository.getCompletedSetsCount(workoutEntry.id)&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .clickable { onClick(workoutEntry) },&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = workoutEntry.exerciseName,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = if (workoutEntry.isCompound) &quot;Compound Exercise&quot; else &quot;Isolation Exercise&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = if (workoutEntry.isCompound)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.secondary&#10;                    )&#10;                }&#10;&#10;                // Sets and Reps display&#10;                Surface(&#10;                    color = MaterialTheme.colorScheme.primaryContainer,&#10;                    shape = MaterialTheme.shapes.small,&#10;                    modifier = Modifier.padding(start = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;${workoutEntry.sets} × ${workoutEntry.reps} reps&quot;,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Set Progress Bar and Status - NOW USING ACTUAL COMPLETED SETS FROM DATABASE&#10;            val progress = if (workoutEntry.sets &gt; 0) completedSetsCount.toFloat() / workoutEntry.sets.toFloat() else 0f&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = if (workoutEntry.isCompleted) &quot;✅ Completed&quot; else &quot;Set $completedSetsCount/${workoutEntry.sets}&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = if (workoutEntry.isCompleted)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        fontWeight = if (workoutEntry.isCompleted) FontWeight.Bold else FontWeight.Normal&#10;                    )&#10;&#10;                    if (!workoutEntry.isCompleted) {&#10;                        LinearProgressIndicator(&#10;                            progress = { progress },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(top = 4.dp),&#10;                            color = MaterialTheme.colorScheme.primary,&#10;                            trackColor = MaterialTheme.colorScheme.surfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Total time spent display&#10;                if (workoutEntry.totalSecondsSpent &gt; 0) {&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                        modifier = Modifier.padding(start = 16.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.PlayArrow,&#10;                            contentDescription = &quot;Time Spent&quot;,&#10;                            tint = MaterialTheme.colorScheme.secondary,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;${workoutEntry.totalSecondsSpent / 60}:${String.format(&quot;%02d&quot;, workoutEntry.totalSecondsSpent % 60)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.secondary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RestDayScreen() {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Background image - your awesome Hanuman gym mural&#10;        Image(&#10;            painter = painterResource(id = R.drawable.rest_day),&#10;            contentDescription = &quot;Rest Day Background&quot;,&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;&#10;        // Overlay content with semi-transparent background for better text readability&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(32.dp),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(24.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;‍♂️&quot;,&#10;                        style = MaterialTheme.typography.displayLarge,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;Rest Day&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;Recovery is just as important as training&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        textAlign = TextAlign.Center,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;Take time to rest, stretch, and prepare for tomorrow's workout!&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        textAlign = TextAlign.Center,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DebugDaySelector(&#10;    onDaySelected: (Int) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&#10;                text = &quot; Debug Day Selector&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        },&#10;        text = {&#10;            LazyColumn {&#10;                item {&#10;                    Text(&#10;                        text = &quot;Select a day to test different workouts:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                }&#10;&#10;                val days = listOf(&#10;                    Calendar.MONDAY to &quot;Monday - Push Day 1 &quot;,&#10;                    Calendar.TUESDAY to &quot;Tuesday - Pull Day 1 ️&quot;,&#10;                    Calendar.WEDNESDAY to &quot;Wednesday - Legs Day 1 &quot;,&#10;                    Calendar.THURSDAY to &quot;Thursday - Push Day 2 &quot;,&#10;                    Calendar.FRIDAY to &quot;Friday - Pull Day 2 ️&quot;,&#10;                    Calendar.SATURDAY to &quot;Saturday - Legs Day 2 &quot;,&#10;                    Calendar.SUNDAY to &quot;Sunday - Rest Day ‍♂️&quot;&#10;                )&#10;&#10;                items(days) { (dayOfWeek, dayLabel) -&gt;&#10;                    OutlinedButton(&#10;                        onClick = { onDaySelected(dayOfWeek) },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 4.dp),&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            containerColor = if (dayOfWeek == Calendar.SUNDAY)&#10;                                MaterialTheme.colorScheme.secondaryContainer&#10;                            else&#10;                                MaterialTheme.colorScheme.primaryContainer&#10;                        )&#10;                    ) {&#10;                        Text(&#10;                            text = dayLabel,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            modifier = Modifier.padding(8.dp)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Debug Actions:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                println(&quot; DEBUG: Checking current database state...&quot;)&#10;                                val currentState = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                                println(&quot; CURRENT STATE: ${currentState.first} days, ${currentState.second} entries, ${currentState.third} sets&quot;)&#10;                            }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.tertiary&#10;                        )&#10;                    ) {&#10;                        Text(&quot; Check DB State&quot;)&#10;                    }&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                println(&quot; DEBUG: Force reset database...&quot;)&#10;                                PPLWorkoutDatabase.forceResetDatabase(context)&#10;                                kotlinx.coroutines.delay(200)&#10;                                val afterState = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                                println(&quot; AFTER FORCE RESET: ${afterState.first} days, ${afterState.second} entries, ${afterState.third} sets&quot;)&#10;                            }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.error&#10;                        )&#10;                    ) {&#10;                        Text(&quot; Force Reset DB&quot;)&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            //TODO: Uncomment when reset functionality is implemented&#10;//            TextButton(onClick = onResetToToday) {&#10;//                Text(&quot;Reset to Today&quot;)&#10;//            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun StartWorkoutScreen(&#10;    workoutType: String,&#10;    onStartWorkout: () -&gt; Unit,&#10;    onTemplateSelection: () -&gt; Unit = {}&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(32.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = &quot;&quot;,&#10;                    style = MaterialTheme.typography.displayLarge,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Ready to Start?&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = workoutType,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(bottom = 24.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Choose how you want to start your workout:&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(bottom = 32.dp)&#10;                )&#10;&#10;                // Default workout button&#10;                Button(&#10;                    onClick = onStartWorkout,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(56.dp),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = MaterialTheme.colorScheme.primary&#10;                    )&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Start Workout&quot;,&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Start Today's Workout&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Template selection button&#10;                OutlinedButton(&#10;                    onClick = onTemplateSelection,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(56.dp),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        contentColor = MaterialTheme.colorScheme.primary&#10;                    )&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.DateRange,&#10;                        contentDescription = &quot;Choose Template&quot;,&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Choose Different Workout&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&#10;                    text = &quot; Use 'Choose Different Workout' to pick from Push, Pull, or Legs templates&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun WorkoutPreview() {&#10;    OfflinePPLWorkOutAppTheme {&#10;        // Preview with sample workout entry data&#10;        val sampleWorkoutEntry = WorkoutEntryWithExercise(&#10;            id = 1,&#10;            dayId = 1,&#10;            exerciseId = 1,&#10;            sets = 4,&#10;            reps = 8,&#10;            isCompleted = false,&#10;            exerciseName = &quot;Barbell Bench Press&quot;,&#10;            isCompound = true&#10;        )&#10;        WorkoutExerciseItem(workoutEntry = sampleWorkoutEntry, onCompletionToggle = {})&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/ExerciseDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/ExerciseDetailScreen.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.components.SetDataEntryDialog&#10;import com.example.offlinepplworkoutapp.ui.theme.AmberAccent&#10;import com.example.offlinepplworkoutapp.ui.theme.BackgroundLight&#10;import com.example.offlinepplworkoutapp.ui.theme.CardBackground&#10;import com.example.offlinepplworkoutapp.ui.theme.PrimaryCoral&#10;import com.example.offlinepplworkoutapp.ui.theme.ProgressEnd&#10;import com.example.offlinepplworkoutapp.ui.theme.ProgressStart&#10;import com.example.offlinepplworkoutapp.ui.theme.SuccessGreen&#10;import com.example.offlinepplworkoutapp.ui.theme.TealSecondary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextOnPrimary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextPrimary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextSecondary&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModelFactory&#10;import com.example.offlinepplworkoutapp.util.NotificationHelper&#10;import kotlinx.coroutines.delay&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ExerciseDetailScreen(&#10;    workoutEntry: WorkoutEntryWithExercise,&#10;    repository: WorkoutRepository,&#10;    onBackClick: () -&gt; Unit,&#10;    onSaveChanges: (sets: Int, reps: Int, isCompleted: Boolean) -&gt; Unit&#10;) {&#10;    //  FIX: Add unique key to force new ViewModel creation for each exercise&#10;    val viewModel: ExerciseDetailViewModel = viewModel(&#10;        key = &quot;exercise_${workoutEntry.id}&quot;, // Unique key for each exercise&#10;        factory = ExerciseDetailViewModelFactory(workoutEntry, repository)&#10;    )&#10;&#10;    println(&quot; UI: Created ExerciseDetailViewModel for ${workoutEntry.exerciseName} (ID: ${workoutEntry.id})&quot;)&#10;&#10;    val setTimers by viewModel.setTimers.collectAsState()&#10;    val currentRunningSet by viewModel.currentRunningSet.collectAsState()&#10;    val totalExerciseTime by viewModel.totalExerciseTime.collectAsState()&#10;    val completedSets by viewModel.completedSets.collectAsState()&#10;    val isExerciseCompleted by viewModel.isExerciseCompleted.collectAsState()&#10;&#10;    //  NEW: Rest timer state&#10;    val restTimer by viewModel.restTimer.collectAsState()&#10;    val isRestActive by viewModel.isRestActive.collectAsState()&#10;    val restMinuteMilestoneReached by viewModel.restMinuteMilestoneReached.collectAsState()&#10;&#10;    // Get context for notification&#10;    val context = LocalContext.current&#10;    val notificationHelper = remember { NotificationHelper(context) }&#10;&#10;    //  NEW: Notification for 1-minute rest milestone&#10;    LaunchedEffect(restMinuteMilestoneReached) {&#10;        if (restMinuteMilestoneReached &amp;&amp; isRestActive) {&#10;            println(&quot; NOTIFICATION: Rest milestone reached, showing notification&quot;)&#10;            notificationHelper.showRestTimerNotification(workoutEntry.exerciseName)&#10;        }&#10;    }&#10;&#10;    //  NEW: Reset notification when rest timer stops&#10;    LaunchedEffect(isRestActive) {&#10;        if (!isRestActive) {&#10;            println(&quot; NOTIFICATION: Rest timer stopped, cancelling notifications&quot;)&#10;            notificationHelper.cancelRestTimerNotification()&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Set data entry dialog state&#10;    val showSetDataDialog by viewModel.showSetDataDialog.collectAsState()&#10;    val pendingSetData by viewModel.pendingSetData.collectAsState()&#10;&#10;    val originalCompletionStatus = remember { workoutEntry.isCompleted }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = workoutEntry.exerciseName,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontSize = 22.sp,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = PrimaryCoral&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Sets: $completedSets/${setTimers.size} • Total: ${formatTime(totalExerciseTime / 1000)}&quot;.also {&#10;                                println(&quot; UI DEBUG: Displaying total time - Raw: ${totalExerciseTime}ms, Converted: ${totalExerciseTime / 1000}s, Formatted: ${formatTime(totalExerciseTime / 1000)}&quot;)&#10;                            },&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontSize = 14.sp,&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = {&#10;                        val shouldMarkCompleted = isExerciseCompleted &amp;&amp; completedSets == workoutEntry.sets&#10;                        if (shouldMarkCompleted != originalCompletionStatus) {&#10;                            onSaveChanges(workoutEntry.sets, workoutEntry.reps, shouldMarkCompleted)&#10;                        }&#10;                        onBackClick()&#10;                    }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = PrimaryCoral&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = CardBackground&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(BackgroundLight)&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            //  NEW: Rest timer display at top of screen&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isRestActive,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    RestTimerCard(&#10;                        restTime = restTimer / 1000, // Convert milliseconds to seconds&#10;                        isActive = isRestActive&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Exercise completion status with animation&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isExerciseCompleted,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    CompletionCard()&#10;                }&#10;            }&#10;&#10;            // Set cards with improved design and delete functionality&#10;            itemsIndexed(setTimers) { index, setTimer -&gt;&#10;                val activeSetIndex by viewModel.activeSetIndex.collectAsState()&#10;&#10;                // Get performance data from view model&#10;                val setData by viewModel.getSetData(index).collectAsState(initial = null)&#10;                val repsPerformed = setData?.repsPerformed ?: 0&#10;                val weightUsed = setData?.weightUsed ?: 0f&#10;&#10;                ModernSetTimerCard(&#10;                    setNumber = index + 1,&#10;                    totalSets = setTimers.size,&#10;                    targetReps = workoutEntry.reps,&#10;                    setTimer = setTimer.elapsedTime / 1000, //  FIXED: Convert milliseconds to seconds&#10;                    isCurrentSet = currentRunningSet == index,&#10;                    isCompleted = setTimer.isCompleted,&#10;                    isActive = index == activeSetIndex,&#10;                    isLocked = index &gt; activeSetIndex &amp;&amp; !setTimer.isCompleted,&#10;                    repsPerformed = repsPerformed,&#10;                    weightUsed = weightUsed,&#10;                    onStartTimer = { viewModel.startSetTimer(index) },&#10;                    onStopTimer = { viewModel.stopSetTimer(index) },&#10;                    onCompleteSet = { /* This callback is not needed anymore since we use onStopTimer */ },&#10;                    onEditSet = { viewModel.editSetData(index) },&#10;                    //  NEW: Add delete functionality for incomplete sets&#10;                    onDeleteSet = if (!setTimer.isCompleted &amp;&amp; setTimers.size &gt; 1) {&#10;                        { viewModel.removeSpecificSet(index) }&#10;                    } else null&#10;                )&#10;            }&#10;&#10;            //  NEW: Simple Add Set Button (replaces the bulky management card)&#10;            item {&#10;                val canAddSet = setTimers.size &lt; 8 // Max 8 sets per exercise&#10;&#10;                if (canAddSet) {&#10;                    AddSetButton(&#10;                        onAddSet = { viewModel.addSetWithReps() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Set Data Entry Dialog&#10;    if (showSetDataDialog) {&#10;        pendingSetData?.let { (setIndex, _) -&gt;&#10;            // Get existing set data for editing mode&#10;            val setData by viewModel.getSetData(setIndex).collectAsState(initial = null)&#10;            val currentSetData = setData // Create a local variable for smart casting&#10;            val isEditMode = currentSetData != null &amp;&amp; currentSetData.isCompleted&#10;&#10;            SetDataEntryDialog(&#10;                setNumber = setIndex + 1,&#10;                exerciseName = workoutEntry.exerciseName,&#10;                onDataEntered = { performanceData -&gt;&#10;                    viewModel.submitSetPerformanceData(&#10;                        repsPerformed = performanceData.repsPerformed,&#10;                        weightUsed = performanceData.weightUsed&#10;                    )&#10;                },&#10;                onCancel = if (isEditMode) {&#10;                    //  NEW: Cancel callback for edit mode&#10;                    { viewModel.dismissSetDataDialog() }&#10;                } else null, // No cancel for new entries&#10;                isRestTimerRunning = isRestActive &amp;&amp; !isEditMode, // Don't show rest timer when editing&#10;                restTimeFormatted = formatTime(restTimer / 1000),&#10;                //  NEW: Edit mode parameters&#10;                isEditMode = isEditMode,&#10;                initialReps = currentSetData?.repsPerformed ?: 0,&#10;                initialWeight = currentSetData?.weightUsed ?: 0f&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CompletionCard() {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(8.dp, RoundedCornerShape(20.dp))&#10;            .clip(RoundedCornerShape(20.dp))&#10;            .background(&#10;                brush = Brush.horizontalGradient(&#10;                    colors = listOf(SuccessGreen, TealSecondary)&#10;                )&#10;            ),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Check,&#10;                contentDescription = &quot;Completed&quot;,&#10;                tint = TextOnPrimary,&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Text(&#10;                text = &quot;Exercise Completed! &quot;,&#10;                style = MaterialTheme.typography.titleLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextOnPrimary&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ModernSetTimerCard(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    targetReps: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean = false,&#10;    isActive: Boolean = false,&#10;    isLocked: Boolean = false,&#10;    repsPerformed: Int = 0,&#10;    weightUsed: Float = 0f,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onCompleteSet: () -&gt; Unit,&#10;    onEditSet: () -&gt; Unit, //  NEW: Edit action&#10;    onDeleteSet: (() -&gt; Unit)? = null //  NEW: Delete action&#10;) {&#10;    // Animation for card state changes&#10;    val animatedElevation by animateDpAsState(&#10;        targetValue = when {&#10;            isCurrentSet -&gt; 12.dp&#10;            isActive -&gt; 6.dp&#10;            else -&gt; 2.dp&#10;        },&#10;        animationSpec = tween(300)&#10;    )&#10;&#10;    // Card colors based on state&#10;    val cardColors = when {&#10;        isCompleted -&gt; CardDefaults.cardColors(&#10;            containerColor = SuccessGreen.copy(alpha = 0.1f)&#10;        )&#10;        isCurrentSet -&gt; CardDefaults.cardColors(&#10;            containerColor = Color.Transparent&#10;        )&#10;        isActive -&gt; CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        )&#10;        isLocked -&gt; CardDefaults.cardColors(&#10;            containerColor = TextSecondary.copy(alpha = 0.05f)&#10;        )&#10;        else -&gt; CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(animatedElevation, RoundedCornerShape(16.dp))&#10;            .then(&#10;                if (isCurrentSet) {&#10;                    Modifier&#10;                        .border(&#10;                            width = 3.dp,&#10;                            brush = Brush.horizontalGradient(&#10;                                colors = listOf(ProgressStart, ProgressEnd)&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                        .background(&#10;                            brush = Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    ProgressStart.copy(alpha = 0.1f),&#10;                                    ProgressEnd.copy(alpha = 0.05f)&#10;                                )&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                } else {&#10;                    Modifier&#10;                }&#10;            ),&#10;        colors = cardColors,&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            // Set Header with improved typography&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Set status icon&#10;                    when {&#10;                        isCompleted -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isCurrentSet -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Active&quot;,&#10;                                tint = PrimaryCoral,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isLocked -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Lock,&#10;                                contentDescription = &quot;Locked&quot;,&#10;                                tint = TextSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        else -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.DateRange,&#10;                                contentDescription = &quot;Ready&quot;,&#10;                                tint = TealSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Set $setNumber of $totalSets&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontSize = 16.sp,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = when {&#10;                                isLocked -&gt; TextSecondary.copy(alpha = 0.6f)&#10;                                else -&gt; TextPrimary&#10;                            }&#10;                        )&#10;                    )&#10;                }&#10;&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    //  NEW: Delete button for incomplete sets&#10;                    if (onDeleteSet != null) {&#10;                        IconButton(&#10;                            onClick = onDeleteSet,&#10;                            modifier = Modifier.size(32.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Delete,&#10;                                contentDescription = &quot;Delete set&quot;,&#10;                                tint = PrimaryCoral,&#10;                                modifier = Modifier.size(18.dp)&#10;                            )&#10;                        }&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;&#10;                    // Timer display with improved styling&#10;                    TimerDisplay(&#10;                        time = setTimer,&#10;                        isActive = isCurrentSet,&#10;                        isCompleted = isCompleted&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Target reps info&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Target: $targetReps reps&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        color = TextSecondary,&#10;                        fontSize = 14.sp&#10;                    )&#10;                )&#10;&#10;                //  NEW: Display performance data when set is completed&#10;                if (isCompleted &amp;&amp; (repsPerformed &gt; 0 || weightUsed &gt; 0f)) {&#10;                    Text(&#10;                        text = buildString {&#10;                            if (repsPerformed &gt; 0) append(&quot;$repsPerformed reps&quot;)&#10;                            if (repsPerformed &gt; 0 &amp;&amp; weightUsed &gt; 0f) append(&quot; × &quot;)&#10;                            if (weightUsed &gt; 0f) append(&quot;${weightUsed}lbs&quot;)&#10;                        },&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            color = PrimaryCoral,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Action buttons with modern design&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                when {&#10;                    isCompleted -&gt; {&#10;                        // Completed state - show success message and performance data&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier.weight(1f),&#10;                                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                            ) {&#10;                                Row(&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Check,&#10;                                        contentDescription = &quot;Completed&quot;,&#10;                                        tint = SuccessGreen,&#10;                                        modifier = Modifier.size(16.dp)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Set Completed&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = SuccessGreen,&#10;                                            fontWeight = FontWeight.Medium&#10;                                        )&#10;                                    )&#10;                                }&#10;&#10;                                //  NEW: Detailed performance data display&#10;                                if (repsPerformed &gt; 0 || weightUsed &gt; 0f) {&#10;                                    Row(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(top = 4.dp),&#10;                                        horizontalArrangement = Arrangement.Start&#10;                                    ) {&#10;                                        if (repsPerformed &gt; 0) {&#10;                                            Text(&#10;                                                text = &quot;Performed: $repsPerformed reps&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                                    color = TextSecondary&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                        if (repsPerformed &gt; 0 &amp;&amp; weightUsed &gt; 0f) {&#10;                                            Spacer(modifier = Modifier.width(8.dp))&#10;                                        }&#10;                                        if (weightUsed &gt; 0f) {&#10;                                            Text(&#10;                                                text = &quot;Weight: ${weightUsed}lbs&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                                    color = TextSecondary&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            //  NEW: Edit button for completed sets&#10;                            IconButton(&#10;                                onClick = onEditSet,&#10;                                modifier = Modifier.size(40.dp)&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Edit,&#10;                                    contentDescription = &quot;Edit set data&quot;,&#10;                                    tint = PrimaryCoral,&#10;                                    modifier = Modifier.size(20.dp)&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                    isLocked -&gt; {&#10;                        // Locked state&#10;                        Text(&#10;                            text = &quot;Complete previous sets first&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                color = TextSecondary,&#10;                                fontStyle = androidx.compose.ui.text.font.FontStyle.Italic&#10;                            ),&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    }&#10;                    isCurrentSet -&gt; {&#10;                        //  NEW: Phase 2.1.2 - Just stop timer, dialog will handle completion&#10;                        Button(&#10;                            onClick = {&#10;                                //  FIX: Call onStopTimer to stop the timer and trigger the dialog&#10;                                onStopTimer()&#10;                                println(&quot; DEBUG: Complete Set button clicked - stopping timer&quot;)&#10;                            },&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = SuccessGreen&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Stop and Complete&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Complete Set&quot;)&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // Ready to start&#10;                        Button(&#10;                            onClick = onStartTimer,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = PrimaryCoral&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp),&#10;                            enabled = !isLocked&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Start&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Start Set&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimerDisplay(&#10;    time: Long,&#10;    isActive: Boolean,&#10;    isCompleted: Boolean&#10;) {&#10;    val textColor = when {&#10;        isCompleted -&gt; SuccessGreen&#10;        isActive -&gt; PrimaryCoral&#10;        else -&gt; TextSecondary&#10;    }&#10;&#10;    //  PROPER STOPWATCH: Start from stored time and count up properly&#10;    var displayTime by remember(time) { mutableStateOf(time) }&#10;&#10;    // Track when timer starts to calculate elapsed time properly&#10;    val startTimeRef = remember { mutableStateOf(0L) }&#10;&#10;    LaunchedEffect(isActive) {&#10;        if (isActive) {&#10;            // Record the actual start time when timer becomes active&#10;            startTimeRef.value = System.currentTimeMillis()&#10;&#10;            while (isActive) {&#10;                // Calculate elapsed seconds since timer started&#10;                val elapsedMs = System.currentTimeMillis() - startTimeRef.value&#10;                val elapsedSeconds = elapsedMs / 1000&#10;&#10;                // Display = stored time + elapsed time&#10;                displayTime = time + elapsedSeconds&#10;&#10;                delay(1000) // Update every second&#10;            }&#10;        } else {&#10;            // When not active, show the stored time from database&#10;            displayTime = time&#10;        }&#10;    }&#10;&#10;    Text(&#10;        text = formatTime(displayTime),&#10;        style = MaterialTheme.typography.titleLarge.copy(&#10;            fontSize = if (isActive) 20.sp else 18.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = textColor&#10;        )&#10;    )&#10;}&#10;&#10;private fun formatTime(timeInSeconds: Long): String {&#10;    val hours = timeInSeconds / 3600&#10;    val minutes = (timeInSeconds % 3600) / 60&#10;    val seconds = timeInSeconds % 60&#10;&#10;    return if (hours &gt; 0) {&#10;        String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds)&#10;    } else {&#10;        String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;}&#10;&#10;//  NEW: Rest Timer Card Component&#10;@Composable&#10;fun RestTimerCard(&#10;    restTime: Long,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(6.dp, RoundedCornerShape(16.dp)),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                // Rest icon - using a pause/timer-like icon&#10;                Icon(&#10;                    imageVector = Icons.Default.PlayArrow, // We'll use this as a rest indicator&#10;                    contentDescription = &quot;Rest&quot;,&#10;                    tint = AmberAccent,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                Text(&#10;                    text = &quot;Rest Timer&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = TextPrimary&#10;                    )&#10;                )&#10;            }&#10;&#10;            // Rest time display with prominent styling&#10;            Text(&#10;                text = formatTime(restTime),&#10;                style = MaterialTheme.typography.headlineMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = AmberAccent,&#10;                    fontSize = 24.sp&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;//  NEW: 2.2.2 - Dynamic Set Management Controls with simplified UI&#10;@Composable&#10;fun AddSetButton(&#10;    onAddSet: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(4.dp, RoundedCornerShape(16.dp)),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Header with description&#10;            Text(&#10;                text = &quot;Add New Set&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextPrimary&#10;                )&#10;            )&#10;&#10;            Text(&#10;                text = &quot;Add a new set using the default target repetitions for this exercise.&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    color = TextSecondary,&#10;                    fontSize = 14.sp&#10;                )&#10;            )&#10;&#10;            // Add set button&#10;            Button(&#10;                onClick = onAddSet,&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = PrimaryCoral&#10;                ),&#10;                shape = RoundedCornerShape(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Add,&#10;                    contentDescription = &quot;Add Set&quot;,&#10;                    modifier = Modifier.size(16.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&quot;Add Set&quot;)&#10;            }&#10;&#10;            // Help text&#10;            Text(&#10;                text = &quot;Maximum 8 sets per exercise.&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    color = TextSecondary.copy(alpha = 0.7f),&#10;                    fontSize = 12.sp&#10;                ),&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.components.SetDataEntryDialog&#10;import com.example.offlinepplworkoutapp.ui.theme.AmberAccent&#10;import com.example.offlinepplworkoutapp.ui.theme.BackgroundLight&#10;import com.example.offlinepplworkoutapp.ui.theme.CardBackground&#10;import com.example.offlinepplworkoutapp.ui.theme.PrimaryCoral&#10;import com.example.offlinepplworkoutapp.ui.theme.ProgressEnd&#10;import com.example.offlinepplworkoutapp.ui.theme.ProgressStart&#10;import com.example.offlinepplworkoutapp.ui.theme.SuccessGreen&#10;import com.example.offlinepplworkoutapp.ui.theme.TealSecondary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextOnPrimary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextPrimary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextSecondary&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModelFactory&#10;import com.example.offlinepplworkoutapp.util.HapticFeedbackHelper&#10;import com.example.offlinepplworkoutapp.util.NotificationHelper&#10;import com.example.offlinepplworkoutapp.util.rememberHapticFeedback&#10;import kotlinx.coroutines.delay&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ExerciseDetailScreen(&#10;    workoutEntry: WorkoutEntryWithExercise,&#10;    repository: WorkoutRepository,&#10;    onBackClick: () -&gt; Unit,&#10;    onSaveChanges: (sets: Int, reps: Int, isCompleted: Boolean) -&gt; Unit&#10;) {&#10;    //  FIX: Add unique key to force new ViewModel creation for each exercise&#10;    val viewModel: ExerciseDetailViewModel = viewModel(&#10;        key = &quot;exercise_${workoutEntry.id}&quot;, // Unique key for each exercise&#10;        factory = ExerciseDetailViewModelFactory(workoutEntry, repository)&#10;    )&#10;&#10;    println(&quot; UI: Created ExerciseDetailViewModel for ${workoutEntry.exerciseName} (ID: ${workoutEntry.id})&quot;)&#10;&#10;    val setTimers by viewModel.setTimers.collectAsState()&#10;    val currentRunningSet by viewModel.currentRunningSet.collectAsState()&#10;    val totalExerciseTime by viewModel.totalExerciseTime.collectAsState()&#10;    val completedSets by viewModel.completedSets.collectAsState()&#10;    val isExerciseCompleted by viewModel.isExerciseCompleted.collectAsState()&#10;&#10;    //  NEW: Rest timer state&#10;    val restTimer by viewModel.restTimer.collectAsState()&#10;    val isRestActive by viewModel.isRestActive.collectAsState()&#10;    val restMinuteMilestoneReached by viewModel.restMinuteMilestoneReached.collectAsState()&#10;&#10;    // Get context for notification and haptic feedback&#10;    val context = LocalContext.current&#10;    val notificationHelper = remember { NotificationHelper(context) }&#10;    &#10;    //  NEW: Add haptic feedback helper&#10;    val hapticFeedback = rememberHapticFeedback()&#10;&#10;    //  NEW: Notification for 1-minute rest milestone&#10;    LaunchedEffect(restMinuteMilestoneReached) @androidx.annotation.RequiresPermission(android.Manifest.permission.VIBRATE) {&#10;        if (restMinuteMilestoneReached &amp;&amp; isRestActive) {&#10;            println(&quot; NOTIFICATION: Rest milestone reached, showing notification&quot;)&#10;            notificationHelper.showRestTimerNotification(workoutEntry.exerciseName)&#10;            &#10;            //  NEW: Add haptic feedback for milestone reached&#10;            hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.SUCCESS)&#10;        }&#10;    }&#10;&#10;    //  NEW: Reset notification when rest timer stops&#10;    LaunchedEffect(isRestActive) {&#10;        if (!isRestActive) {&#10;            println(&quot; NOTIFICATION: Rest timer stopped, cancelling notifications&quot;)&#10;            notificationHelper.cancelRestTimerNotification()&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Set data entry dialog state&#10;    val showSetDataDialog by viewModel.showSetDataDialog.collectAsState()&#10;    val pendingSetData by viewModel.pendingSetData.collectAsState()&#10;&#10;    val originalCompletionStatus = remember { workoutEntry.isCompleted }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = workoutEntry.exerciseName,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontSize = 22.sp,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = PrimaryCoral&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Sets: $completedSets/${setTimers.size} • Total: ${formatTime(totalExerciseTime / 1000)}&quot;.also {&#10;                                println(&quot; UI DEBUG: Displaying total time - Raw: ${totalExerciseTime}ms, Converted: ${totalExerciseTime / 1000}s, Formatted: ${formatTime(totalExerciseTime / 1000)}&quot;)&#10;                            },&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontSize = 14.sp,&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = {&#10;                        val shouldMarkCompleted = isExerciseCompleted &amp;&amp; completedSets == workoutEntry.sets&#10;                        if (shouldMarkCompleted != originalCompletionStatus) {&#10;                            onSaveChanges(workoutEntry.sets, workoutEntry.reps, shouldMarkCompleted)&#10;                        }&#10;                        onBackClick()&#10;                    }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = PrimaryCoral&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = CardBackground&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(BackgroundLight)&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            //  NEW: Rest timer display at top of screen&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isRestActive,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    RestTimerCard(&#10;                        restTime = restTimer / 1000, // Convert milliseconds to seconds&#10;                        isActive = isRestActive&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Exercise completion status with animation&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isExerciseCompleted,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    CompletionCard()&#10;                }&#10;            }&#10;&#10;            // Set cards with improved design and delete functionality&#10;            itemsIndexed(setTimers) { index, setTimer -&gt;&#10;                val activeSetIndex by viewModel.activeSetIndex.collectAsState()&#10;&#10;                // Get performance data from view model&#10;                val setData by viewModel.getSetData(index).collectAsState(initial = null)&#10;                val repsPerformed = setData?.repsPerformed ?: 0&#10;                val weightUsed = setData?.weightUsed ?: 0f&#10;&#10;                ModernSetTimerCard(&#10;                    setNumber = index + 1,&#10;                    totalSets = setTimers.size,&#10;                    targetReps = workoutEntry.reps,&#10;                    setTimer = setTimer.elapsedTime / 1000, //  FIXED: Convert milliseconds to seconds&#10;                    isCurrentSet = currentRunningSet == index,&#10;                    isCompleted = setTimer.isCompleted,&#10;                    isActive = index == activeSetIndex,&#10;                    isLocked = index &gt; activeSetIndex &amp;&amp; !setTimer.isCompleted,&#10;                    repsPerformed = repsPerformed,&#10;                    weightUsed = weightUsed,&#10;                    onStartTimer = { viewModel.startSetTimer(index) },&#10;                    onStopTimer = { viewModel.stopSetTimer(index) },&#10;                    onCompleteSet = { /* This callback is not needed anymore since we use onStopTimer */ },&#10;                    onEditSet = { viewModel.editSetData(index) },&#10;                    //  NEW: Add delete functionality for incomplete sets&#10;                    onDeleteSet = if (!setTimer.isCompleted &amp;&amp; setTimers.size &gt; 1) {&#10;                        { viewModel.removeSpecificSet(index) }&#10;                    } else null&#10;                )&#10;            }&#10;&#10;            //  NEW: Simple Add Set Button (replaces the bulky management card)&#10;            item {&#10;                val canAddSet = setTimers.size &lt; 8 // Max 8 sets per exercise&#10;&#10;                if (canAddSet) {&#10;                    AddSetButton(&#10;                        onAddSet = { viewModel.addSetWithReps() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Set Data Entry Dialog&#10;    if (showSetDataDialog) {&#10;        pendingSetData?.let { (setIndex, _) -&gt;&#10;            // Get existing set data for editing mode&#10;            val setData by viewModel.getSetData(setIndex).collectAsState(initial = null)&#10;            val currentSetData = setData // Create a local variable for smart casting&#10;            val isEditMode = currentSetData != null &amp;&amp; currentSetData.isCompleted&#10;&#10;            SetDataEntryDialog(&#10;                setNumber = setIndex + 1,&#10;                exerciseName = workoutEntry.exerciseName,&#10;                onDataEntered = { performanceData -&gt;&#10;                    viewModel.submitSetPerformanceData(&#10;                        repsPerformed = performanceData.repsPerformed,&#10;                        weightUsed = performanceData.weightUsed&#10;                    )&#10;                },&#10;                onCancel = if (isEditMode) {&#10;                    //  NEW: Cancel callback for edit mode&#10;                    { viewModel.dismissSetDataDialog() }&#10;                } else null, // No cancel for new entries&#10;                isRestTimerRunning = isRestActive &amp;&amp; !isEditMode, // Don't show rest timer when editing&#10;                restTimeFormatted = formatTime(restTimer / 1000),&#10;                //  NEW: Edit mode parameters&#10;                isEditMode = isEditMode,&#10;                initialReps = currentSetData?.repsPerformed ?: 0,&#10;                initialWeight = currentSetData?.weightUsed ?: 0f&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CompletionCard() {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(8.dp, RoundedCornerShape(20.dp))&#10;            .clip(RoundedCornerShape(20.dp))&#10;            .background(&#10;                brush = Brush.horizontalGradient(&#10;                    colors = listOf(SuccessGreen, TealSecondary)&#10;                )&#10;            ),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Check,&#10;                contentDescription = &quot;Completed&quot;,&#10;                tint = TextOnPrimary,&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Text(&#10;                text = &quot;Exercise Completed! &quot;,&#10;                style = MaterialTheme.typography.titleLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextOnPrimary&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ModernSetTimerCard(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    targetReps: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean = false,&#10;    isActive: Boolean = false,&#10;    isLocked: Boolean = false,&#10;    repsPerformed: Int = 0,&#10;    weightUsed: Float = 0f,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onCompleteSet: () -&gt; Unit,&#10;    onEditSet: () -&gt; Unit, //  NEW: Edit action&#10;    onDeleteSet: (() -&gt; Unit)? = null //  NEW: Delete action&#10;) {&#10;    //  NEW: Add haptic feedback helper&#10;    val hapticFeedback = rememberHapticFeedback()&#10;    &#10;    // Animation for card state changes&#10;    val animatedElevation by animateDpAsState(&#10;        targetValue = when {&#10;            isCurrentSet -&gt; 12.dp&#10;            isActive -&gt; 6.dp&#10;            else -&gt; 2.dp&#10;        },&#10;        animationSpec = tween(300)&#10;    )&#10;&#10;    // Card colors based on state&#10;    val cardColors = when {&#10;        isCompleted -&gt; CardDefaults.cardColors(&#10;            containerColor = SuccessGreen.copy(alpha = 0.1f)&#10;        )&#10;        isCurrentSet -&gt; CardDefaults.cardColors(&#10;            containerColor = Color.Transparent&#10;        )&#10;        isActive -&gt; CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        )&#10;        isLocked -&gt; CardDefaults.cardColors(&#10;            containerColor = TextSecondary.copy(alpha = 0.05f)&#10;        )&#10;        else -&gt; CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(animatedElevation, RoundedCornerShape(16.dp))&#10;            .then(&#10;                if (isCurrentSet) {&#10;                    Modifier&#10;                        .border(&#10;                            width = 3.dp,&#10;                            brush = Brush.horizontalGradient(&#10;                                colors = listOf(ProgressStart, ProgressEnd)&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                        .background(&#10;                            brush = Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    ProgressStart.copy(alpha = 0.1f),&#10;                                    ProgressEnd.copy(alpha = 0.05f)&#10;                                )&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                } else {&#10;                    Modifier&#10;                }&#10;            ),&#10;        colors = cardColors,&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            // Set Header with improved typography&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Set status icon&#10;                    when {&#10;                        isCompleted -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isCurrentSet -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Active&quot;,&#10;                                tint = PrimaryCoral,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isLocked -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Lock,&#10;                                contentDescription = &quot;Locked&quot;,&#10;                                tint = TextSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        else -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.DateRange,&#10;                                contentDescription = &quot;Ready&quot;,&#10;                                tint = TealSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Set $setNumber of $totalSets&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontSize = 16.sp,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = when {&#10;                                isLocked -&gt; TextSecondary.copy(alpha = 0.6f)&#10;                                else -&gt; TextPrimary&#10;                            }&#10;                        )&#10;                    )&#10;                }&#10;&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    //  NEW: Delete button for incomplete sets&#10;                    if (onDeleteSet != null) {&#10;                        IconButton(&#10;                            onClick = onDeleteSet,&#10;                            modifier = Modifier.size(32.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Delete,&#10;                                contentDescription = &quot;Delete set&quot;,&#10;                                tint = PrimaryCoral,&#10;                                modifier = Modifier.size(18.dp)&#10;                            )&#10;                        }&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;&#10;                    // Timer display with improved styling&#10;                    TimerDisplay(&#10;                        time = setTimer,&#10;                        isActive = isCurrentSet,&#10;                        isCompleted = isCompleted&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Target reps info&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;Target: $targetReps reps&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        color = TextSecondary,&#10;                        fontSize = 14.sp&#10;                    )&#10;                )&#10;&#10;                //  NEW: Display performance data when set is completed&#10;                if (isCompleted &amp;&amp; (repsPerformed &gt; 0 || weightUsed &gt; 0f)) {&#10;                    Text(&#10;                        text = buildString {&#10;                            if (repsPerformed &gt; 0) append(&quot;$repsPerformed reps&quot;)&#10;                            if (repsPerformed &gt; 0 &amp;&amp; weightUsed &gt; 0f) append(&quot; × &quot;)&#10;                            if (weightUsed &gt; 0f) append(&quot;${weightUsed}lbs&quot;)&#10;                        },&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            color = PrimaryCoral,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Action buttons with modern design&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                when {&#10;                    isCompleted -&gt; {&#10;                        // Completed state - show success message and performance data&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier.weight(1f),&#10;                                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                            ) {&#10;                                Row(&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Check,&#10;                                        contentDescription = &quot;Completed&quot;,&#10;                                        tint = SuccessGreen,&#10;                                        modifier = Modifier.size(16.dp)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Set Completed&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = SuccessGreen,&#10;                                            fontWeight = FontWeight.Medium&#10;                                        )&#10;                                    )&#10;                                }&#10;&#10;                                //  NEW: Detailed performance data display&#10;                                if (repsPerformed &gt; 0 || weightUsed &gt; 0f) {&#10;                                    Row(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(top = 4.dp),&#10;                                        horizontalArrangement = Arrangement.Start&#10;                                    ) {&#10;                                        if (repsPerformed &gt; 0) {&#10;                                            Text(&#10;                                                text = &quot;Performed: $repsPerformed reps&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                                    color = TextSecondary&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                        if (repsPerformed &gt; 0 &amp;&amp; weightUsed &gt; 0f) {&#10;                                            Spacer(modifier = Modifier.width(8.dp))&#10;                                        }&#10;                                        if (weightUsed &gt; 0f) {&#10;                                            Text(&#10;                                                text = &quot;Weight: ${weightUsed}lbs&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                                    color = TextSecondary&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            //  NEW: Edit button for completed sets&#10;                            IconButton(&#10;                                onClick = { &#10;                                    //  NEW: Add haptic feedback for edit action&#10;                                    hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.BUTTON_PRESS)&#10;                                    onEditSet() &#10;                                },&#10;                                modifier = Modifier.size(40.dp)&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Edit,&#10;                                    contentDescription = &quot;Edit set data&quot;,&#10;                                    tint = PrimaryCoral,&#10;                                    modifier = Modifier.size(20.dp)&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                    isLocked -&gt; {&#10;                        // Locked state&#10;                        Text(&#10;                            text = &quot;Complete previous sets first&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                color = TextSecondary,&#10;                                fontStyle = androidx.compose.ui.text.font.FontStyle.Italic&#10;                            ),&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    }&#10;                    isCurrentSet -&gt; {&#10;                        //  NEW: Phase 2.1.2 - Just stop timer, dialog will handle completion&#10;                        Button(&#10;                            onClick = {&#10;                                //  NEW: Add haptic feedback when completing a set&#10;                                hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.SUCCESS)&#10;                                &#10;                                //  FIX: Call onStopTimer to stop the timer and trigger the dialog&#10;                                onStopTimer()&#10;                                println(&quot; DEBUG: Complete Set button clicked - stopping timer&quot;)&#10;                            },&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = SuccessGreen&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Stop and Complete&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Complete Set&quot;)&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // Ready to start&#10;                        Button(&#10;                            onClick = {&#10;                                //  NEW: Add haptic feedback when starting a set timer&#10;                                hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.TIMER_START_STOP)&#10;                                onStartTimer()&#10;                            },&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = PrimaryCoral&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp),&#10;                            enabled = !isLocked&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Start&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Start Set&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimerDisplay(&#10;    time: Long,&#10;    isActive: Boolean,&#10;    isCompleted: Boolean&#10;) {&#10;    val textColor = when {&#10;        isCompleted -&gt; SuccessGreen&#10;        isActive -&gt; PrimaryCoral&#10;        else -&gt; TextSecondary&#10;    }&#10;&#10;    //  PROPER STOPWATCH: Start from stored time and count up properly&#10;    var displayTime by remember(time) { mutableStateOf(time) }&#10;&#10;    // Track when timer starts to calculate elapsed time properly&#10;    val startTimeRef = remember { mutableStateOf(0L) }&#10;&#10;    LaunchedEffect(isActive) {&#10;        if (isActive) {&#10;            // Record the actual start time when timer becomes active&#10;            startTimeRef.value = System.currentTimeMillis()&#10;&#10;            while (isActive) {&#10;                // Calculate elapsed seconds since timer started&#10;                val elapsedMs = System.currentTimeMillis() - startTimeRef.value&#10;                val elapsedSeconds = elapsedMs / 1000&#10;&#10;                // Display = stored time + elapsed time&#10;                displayTime = time + elapsedSeconds&#10;&#10;                delay(1000) // Update every second&#10;            }&#10;        } else {&#10;            // When not active, show the stored time from database&#10;            displayTime = time&#10;        }&#10;    }&#10;&#10;    Text(&#10;        text = formatTime(displayTime),&#10;        style = MaterialTheme.typography.titleLarge.copy(&#10;            fontSize = if (isActive) 20.sp else 18.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = textColor&#10;        )&#10;    )&#10;}&#10;&#10;private fun formatTime(timeInSeconds: Long): String {&#10;    val hours = timeInSeconds / 3600&#10;    val minutes = (timeInSeconds % 3600) / 60&#10;    val seconds = timeInSeconds % 60&#10;&#10;    return if (hours &gt; 0) {&#10;        String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds)&#10;    } else {&#10;        String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;}&#10;&#10;//  NEW: Rest Timer Card Component&#10;@Composable&#10;fun RestTimerCard(&#10;    restTime: Long,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(6.dp, RoundedCornerShape(16.dp)),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                // Rest icon - using a pause/timer-like icon&#10;                Icon(&#10;                    imageVector = Icons.Default.PlayArrow, // We'll use this as a rest indicator&#10;                    contentDescription = &quot;Rest&quot;,&#10;                    tint = AmberAccent,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                Text(&#10;                    text = &quot;Rest Timer&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = TextPrimary&#10;                    )&#10;                )&#10;            }&#10;&#10;            // Rest time display with prominent styling&#10;            Text(&#10;                text = formatTime(restTime),&#10;                style = MaterialTheme.typography.headlineMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = AmberAccent,&#10;                    fontSize = 24.sp&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;//  NEW: 2.2.2 - Dynamic Set Management Controls with simplified UI&#10;@Composable&#10;fun AddSetButton(&#10;    onAddSet: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(4.dp, RoundedCornerShape(16.dp)),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Header with description&#10;            Text(&#10;                text = &quot;Add New Set&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextPrimary&#10;                )&#10;            )&#10;&#10;            Text(&#10;                text = &quot;Add a new set using the default target repetitions for this exercise.&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    color = TextSecondary,&#10;                    fontSize = 14.sp&#10;                )&#10;            )&#10;&#10;            // Add set button&#10;            Button(&#10;                onClick = onAddSet,&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = PrimaryCoral&#10;                ),&#10;                shape = RoundedCornerShape(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Add,&#10;                    contentDescription = &quot;Add Set&quot;,&#10;                    modifier = Modifier.size(16.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&quot;Add Set&quot;)&#10;            }&#10;&#10;            // Help text&#10;            Text(&#10;                text = &quot;Maximum 8 sets per exercise.&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    color = TextSecondary.copy(alpha = 0.7f),&#10;                    fontSize = 12.sp&#10;                ),&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/viewmodel/ExerciseDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/viewmodel/ExerciseDetailViewModel.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class SetTimer(&#10;    val setNumber: Int,&#10;    val elapsedTime: Long = 0L,&#10;    val isRunning: Boolean = false,&#10;    val isCompleted: Boolean = false,&#10;    val startTime: Long = 0L&#10;)&#10;&#10;class ExerciseDetailViewModel(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModel() {&#10;&#10;    // Load actual sets from database instead of creating in memory&#10;    private val _setTimers = MutableStateFlow&lt;List&lt;SetTimer&gt;&gt;(emptyList())&#10;    val setTimers: StateFlow&lt;List&lt;SetTimer&gt;&gt; = _setTimers.asStateFlow()&#10;&#10;    private val _currentRunningSet = MutableStateFlow&lt;Int?&gt;(null)&#10;    val currentRunningSet: StateFlow&lt;Int?&gt; = _currentRunningSet.asStateFlow()&#10;&#10;    private val _activeSetIndex = MutableStateFlow&lt;Int&gt;(0)&#10;    val activeSetIndex: StateFlow&lt;Int&gt; = _activeSetIndex.asStateFlow()&#10;&#10;    private val _totalExerciseTime = MutableStateFlow(0L)&#10;    val totalExerciseTime: StateFlow&lt;Long&gt; = _totalExerciseTime.asStateFlow()&#10;&#10;    private val _completedSets = MutableStateFlow(0)&#10;    val completedSets: StateFlow&lt;Int&gt; = _completedSets.asStateFlow()&#10;&#10;    private val _isExerciseCompleted = MutableStateFlow(false)&#10;    val isExerciseCompleted: StateFlow&lt;Boolean&gt; = _isExerciseCompleted.asStateFlow()&#10;&#10;    //  FIXED: Enhanced rest timer functionality with proper time tracking&#10;    private val _restTimer = MutableStateFlow(0L)&#10;    val restTimer: StateFlow&lt;Long&gt; = _restTimer.asStateFlow()&#10;&#10;    private val _isRestActive = MutableStateFlow(false)&#10;    val isRestActive: StateFlow&lt;Boolean&gt; = _isRestActive.asStateFlow()&#10;&#10;    //  NEW: Track accumulated rest time for total exercise time calculation&#10;    private val _totalRestTime = MutableStateFlow(0L)&#10;    val totalRestTime: StateFlow&lt;Long&gt; = _totalRestTime.asStateFlow()&#10;&#10;    //  NEW: Phase 2.1.2 - Set data entry dialog state&#10;    private val _showSetDataDialog = MutableStateFlow(false)&#10;    val showSetDataDialog: StateFlow&lt;Boolean&gt; = _showSetDataDialog.asStateFlow()&#10;&#10;    private val _pendingSetData = MutableStateFlow&lt;Pair&lt;Int, Int&gt;?&gt;(null) // (setIndex, setId)&#10;    val pendingSetData: StateFlow&lt;Pair&lt;Int, Int&gt;?&gt; = _pendingSetData.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var restTimerJob: Job? = null&#10;    private var currentSetId: Int? = null&#10;&#10;    init {&#10;        loadSetsFromDatabase()&#10;    }&#10;&#10;    private fun loadSetsFromDatabase() {&#10;        viewModelScope.launch {&#10;            println(&quot; DETAIL VM: Loading sets for workout entry ID: ${workoutEntry.id}&quot;)&#10;            println(&quot; DETAIL VM: Exercise: '${workoutEntry.exerciseName}' (Exercise ID: ${workoutEntry.exerciseId})&quot;)&#10;&#10;            // First, ensure sets exist in database&#10;            val existingSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            println(&quot; DETAIL VM: Found ${existingSets.size} existing sets in database&quot;)&#10;&#10;            if (existingSets.isEmpty()) {&#10;                println(&quot; DETAIL VM: No sets found, creating ${workoutEntry.sets} sets&quot;)&#10;                // Create sets in database if they don't exist&#10;                repository.createSetsForWorkoutEntry(workoutEntry.id, workoutEntry.sets)&#10;                println(&quot; DETAIL VM: Sets created, reloading...&quot;)&#10;            } else {&#10;                println(&quot; DETAIL VM: Sets already exist:&quot;)&#10;                existingSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;            }&#10;&#10;            // Now load sets from database and observe changes&#10;            repository.getSetsForWorkoutEntry(workoutEntry.id).collect { dbSets -&gt;&#10;                println(&quot; DETAIL VM: Received ${dbSets.size} sets from Flow for WorkoutEntry ID: ${workoutEntry.id}&quot;)&#10;                dbSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Flow Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s, repsPerformed=${set.repsPerformed}&quot;)&#10;                }&#10;&#10;                val setTimers = dbSets.map { setEntry -&gt;&#10;                    SetTimer(&#10;                        setNumber = setEntry.setNumber,&#10;                        elapsedTime = (setEntry.elapsedTimeSeconds * 1000).toLong(),&#10;                        isRunning = false, // Never restore running state from DB&#10;                        isCompleted = setEntry.isCompleted,&#10;                        startTime = 0L&#10;                    )&#10;                }&#10;&#10;                println(&quot; DETAIL VM: Created ${setTimers.size} SetTimer objects for '${workoutEntry.exerciseName}'&quot;)&#10;                _setTimers.value = setTimers&#10;                _completedSets.value = dbSets.count { it.isCompleted }&#10;                _isExerciseCompleted.value = dbSets.all { it.isCompleted } &amp;&amp; dbSets.isNotEmpty()&#10;&#10;                //  FIX: Set the active set index to the first incomplete set&#10;                val firstIncompleteSetIndex = setTimers.indexOfFirst { !it.isCompleted }&#10;                _activeSetIndex.value =&#10;                    if (firstIncompleteSetIndex != -1) firstIncompleteSetIndex else 0&#10;                println(&quot; DETAIL VM: Set active set index to: ${_activeSetIndex.value}&quot;)&#10;&#10;                updateTotalExerciseTime()&#10;&#10;                println(&quot; DETAIL VM: State updated for '${workoutEntry.exerciseName}' - completedSets: ${_completedSets.value}, isCompleted: ${_isExerciseCompleted.value}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startSetTimer(setIndex: Int) {&#10;        println(&quot; REST DEBUG: startSetTimer called for set ${setIndex + 1}&quot;)&#10;&#10;        // Stop any currently running timer&#10;        stopAllTimers()&#10;&#10;        //  NEW: Stop rest timer when starting a new set&#10;        println(&quot; REST DEBUG: Stopping rest timer before starting new set&quot;)&#10;        stopRestTimer()&#10;&#10;        // Start timer for this set&#10;        val currentTime = System.currentTimeMillis()&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        updatedTimers[setIndex] = updatedTimers[setIndex].copy(&#10;            isRunning = true,&#10;            startTime = currentTime&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = setIndex&#10;&#10;        println(&quot; REST DEBUG: Set ${setIndex + 1} timer started at $currentTime&quot;)&#10;&#10;        // Store the database set ID for persistence&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            currentSetId = dbSets.getOrNull(setIndex)?.id&#10;        }&#10;&#10;        // Start the timer coroutine&#10;        timerJob = viewModelScope.launch {&#10;            while (_setTimers.value.getOrNull(setIndex)?.isRunning == true) {&#10;                delay(1000) // Update every second&#10;                updateTimerForSet(setIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopSetTimer(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        if (timer.isRunning) {&#10;            //  FIXED: Use current elapsed time directly, don't double-count&#10;            val finalElapsedTime = System.currentTimeMillis() - timer.startTime&#10;&#10;            println(&quot; STOP TIMER DEBUG: Set ${setIndex + 1}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: timer.elapsedTime = ${timer.elapsedTime}ms&quot;)&#10;            println(&quot; STOP TIMER DEBUG: startTime = ${timer.startTime}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: currentTime = ${System.currentTimeMillis()}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: calculated elapsed = ${finalElapsedTime}ms (${finalElapsedTime / 1000}s)&quot;)&#10;&#10;            updatedTimers[setIndex] = timer.copy(&#10;                isRunning = false,&#10;                elapsedTime = finalElapsedTime&#10;                //  CHANGED: Don't mark as completed here - wait for user data entry&#10;            )&#10;            _setTimers.value = updatedTimers&#10;            _currentRunningSet.value = null&#10;            timerJob?.cancel()&#10;&#10;            //  NEW: Phase 2.1.2 - Show data entry dialog instead of immediate completion&#10;            currentSetId?.let { setId -&gt;&#10;                println(&quot; DIALOG: Showing set data entry dialog for set ${setIndex + 1}&quot;)&#10;                _pendingSetData.value = Pair(setIndex, setId)&#10;                _showSetDataDialog.value = true&#10;&#10;                //  IMPORTANT: Start rest timer while user enters data&#10;                startRestTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Handle set performance data submission&#10;    fun submitSetPerformanceData(repsPerformed: Int, weightUsed: Float) {&#10;        val pendingData = _pendingSetData.value ?: return&#10;        val (setIndex, setId) = pendingData&#10;&#10;        println(&quot; DIALOG: Submitting performance data - Set ${setIndex + 1}, Reps: $repsPerformed, Weight: $weightUsed&quot;)&#10;&#10;        viewModelScope.launch {&#10;            // Get the timer data for this set&#10;            val timer = _setTimers.value.getOrNull(setIndex)&#10;            val elapsedTimeSeconds = ((timer?.elapsedTime ?: 0L) / 1000).toInt()&#10;&#10;            // Update database with completion and performance data&#10;            repository.updateSetProgressWithPerformanceData(&#10;                setId = setId,&#10;                isCompleted = true,&#10;                elapsedTimeSeconds = elapsedTimeSeconds,&#10;                repsPerformed = repsPerformed,&#10;                weightUsed = weightUsed&#10;            )&#10;&#10;            // Update local state to mark set as completed&#10;            val updatedTimers = _setTimers.value.toMutableList()&#10;            updatedTimers[setIndex] = updatedTimers[setIndex].copy(isCompleted = true)&#10;            _setTimers.value = updatedTimers&#10;&#10;            // Update exercise completion status&#10;            repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;&#10;            // Update local completed sets count&#10;            val completedCount = _setTimers.value.count { it.isCompleted }&#10;            _completedSets.value = completedCount&#10;&#10;            // Check if all sets are completed&#10;            if (completedCount == workoutEntry.sets) {&#10;                _isExerciseCompleted.value = true&#10;                // Stop rest timer if all sets are completed&#10;                stopRestTimer()&#10;            } else {&#10;                // Advance to next set - find the first incomplete set&#10;                val nextIncompleteSetIndex = _setTimers.value.indexOfFirst { !it.isCompleted }&#10;                if (nextIncompleteSetIndex != -1) {&#10;                    _activeSetIndex.value = nextIncompleteSetIndex&#10;                    println(&quot; DETAIL VM: Advanced to next set index: $nextIncompleteSetIndex&quot;)&#10;                }&#10;            }&#10;&#10;            // Update total time calculation&#10;            updateTotalExerciseTime()&#10;&#10;            // Hide dialog and clear pending data&#10;            _showSetDataDialog.value = false&#10;            _pendingSetData.value = null&#10;&#10;            println(&quot; DIALOG: Set performance data saved successfully&quot;)&#10;        }&#10;    }&#10;&#10;    //  NEW: 2.2.1 - Edit set data functionality&#10;    fun editSetData(setIndex: Int) {&#10;        println(&quot; EDIT: editSetData called for set ${setIndex + 1}&quot;)&#10;&#10;        viewModelScope.launch {&#10;            val sets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            val setToEdit = sets.getOrNull(setIndex)&#10;&#10;            if (setToEdit != null &amp;&amp; setToEdit.isCompleted) {&#10;                println(&quot; EDIT: Opening edit dialog for completed set ${setIndex + 1}&quot;)&#10;                _pendingSetData.value = Pair(setIndex, setToEdit.id)&#10;                _showSetDataDialog.value = true&#10;            } else {&#10;                println(&quot; EDIT: Cannot edit set ${setIndex + 1} - not completed or not found&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Enhanced dialog state management for editing&#10;    fun dismissSetDataDialog() {&#10;        println(&quot; DIALOG: Dismissing set data dialog&quot;)&#10;        _showSetDataDialog.value = false&#10;        _pendingSetData.value = null&#10;    }&#10;&#10;    // Get set data for UI display&#10;    fun getSetData(setIndex: Int) = repository.getSetByIndex(workoutEntry.id, setIndex + 1)&#10;&#10;    //  NEW: 2.2.2 - Dynamic Set Management Functions&#10;&#10;    //  NEW: Enhanced set management methods&#10;    fun removeSpecificSet(setIndex: Int) {&#10;        println(&quot; SET MGMT: removeSpecificSet() called for index $setIndex&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;&#10;                if (setIndex &lt; currentSets.size) {&#10;                    val setToRemove = currentSets[setIndex]&#10;&#10;                    // Can only remove incomplete sets and must have more than 1 set&#10;                    if (!setToRemove.isCompleted &amp;&amp; currentSets.size &gt; 1) {&#10;                        println(&quot; SET MGMT: Removing set #${setToRemove.setNumber} (ID: ${setToRemove.id})&quot;)&#10;&#10;                        // Stop any running timer for this set&#10;                        if (_currentRunningSet.value == setIndex) {&#10;                            stopAllTimers()&#10;                        }&#10;&#10;                        // Remove set from database&#10;                        repository.removeSetFromWorkoutEntry(setToRemove.id)&#10;&#10;                        // Update active set index if needed&#10;                        val newSetCount = currentSets.size - 1&#10;                        if (_activeSetIndex.value &gt;= newSetCount) {&#10;                            _activeSetIndex.value = maxOf(0, newSetCount - 1)&#10;                        }&#10;&#10;                        println(&quot; SET MGMT: Successfully removed set at index $setIndex&quot;)&#10;                    } else {&#10;                        println(&quot; SET MGMT ERROR: Cannot remove set - either completed or minimum count reached&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot; SET MGMT ERROR: Failed to remove specific set - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addSetWithReps() {&#10;        println(&quot; SET MGMT: addSetWithReps() called&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;                val newSetNumber = currentSets.size + 1&#10;&#10;                if (currentSets.size &lt; 8) { // Max 8 sets per exercise&#10;                    println(&quot; SET MGMT: Adding set #$newSetNumber&quot;)&#10;&#10;                    // Add new set to database - we don't need to pass targetReps since&#10;                    // the target reps value comes from the parent workout entry&#10;                    repository.addSetToWorkoutEntry(workoutEntry.id, newSetNumber)&#10;&#10;                    println(&quot; SET MGMT: Successfully added set #$newSetNumber&quot;)&#10;                } else {&#10;                    println(&quot; SET MGMT ERROR: Cannot add set - maximum 8 sets reached&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot; SET MGMT ERROR: Failed to add set - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        restTimerJob?.cancel() //  NEW: Clean up rest timer job&#10;    }&#10;&#10;    private fun stopAllTimers() {&#10;        timerJob?.cancel()&#10;        val updatedTimers = _setTimers.value.map { timer -&gt;&#10;            timer.copy(isRunning = false)&#10;        }&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;    }&#10;&#10;    private fun updateTimerForSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers[setIndex]&#10;&#10;        if (timer.isRunning) {&#10;            val currentTime = System.currentTimeMillis()&#10;            //  FIXED: Don't add previous elapsedTime - just calculate from start&#10;            val elapsed = currentTime - timer.startTime&#10;            updatedTimers[setIndex] = timer.copy(elapsedTime = elapsed)&#10;            _setTimers.value = updatedTimers&#10;&#10;            //  REMOVED: Don't update total time during live timer updates&#10;            // updateTotalExerciseTime() // This was causing live updates in top bar&#10;&#10;            //  ADDED: Force UI recomposition for live stopwatch display&#10;            println(&quot;⏱️ TIMER: Set ${setIndex + 1} - ${elapsed / 1000}s (Live)&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateTotalExerciseTime() {&#10;        //  FIXED: Only count completed sets for total time, not running timers&#10;        val completedSets = _setTimers.value.filter { it.isCompleted }&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Calculating total exercise time...&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Found ${completedSets.size} completed sets:&quot;)&#10;&#10;        completedSets.forEachIndexed { index, set -&gt;&#10;            println(&quot; TOTAL TIME DEBUG: Set ${index + 1}: ${set.elapsedTime}ms (${set.elapsedTime / 1000}s)&quot;)&#10;        }&#10;&#10;        val setTime = completedSets.sumOf { it.elapsedTime }&#10;&#10;        //  NEW: Include accumulated rest time in total&#10;        val restTime = _totalRestTime.value&#10;        val totalTime = setTime + restTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Sum of all completed sets: ${setTime}ms (${setTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Total accumulated rest time: ${restTime}ms (${restTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Combined total time: ${totalTime}ms (${totalTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Setting _totalExerciseTime to: ${totalTime}&quot;)&#10;&#10;        _totalExerciseTime.value = totalTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: _totalExerciseTime.value is now: ${_totalExerciseTime.value}&quot;)&#10;&#10;        //  NEW: Update totalSecondsSpent in WorkoutEntry database record&#10;        val totalSeconds = (totalTime / 1000).toInt()&#10;        viewModelScope.launch {&#10;            println(&quot; TOTAL TIME DEBUG: Updating WorkoutEntry.totalSecondsSpent to ${totalSeconds}s&quot;)&#10;            repository.updateExerciseTime(workoutEntry.id, totalSeconds)&#10;            println(&quot; TOTAL TIME DEBUG: Database updated with new exercise time&quot;)&#10;        }&#10;    }&#10;&#10;    //  NEW: Rest timer functionality&#10;    private fun startRestTimer() {&#10;        println(&quot; REST DEBUG: startRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        // Don't start a new rest timer if one is already active&#10;        if (_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer already active, skipping start&quot;)&#10;            return&#10;        }&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to true&quot;)&#10;        _isRestActive.value = true&#10;        val restStartTime = System.currentTimeMillis()&#10;        println(&quot; REST DEBUG: Rest timer start time: $restStartTime&quot;)&#10;&#10;        // Start the rest timer job&#10;        restTimerJob = viewModelScope.launch {&#10;            var elapsedRestTime = 0L&#10;            println(&quot; REST DEBUG: Rest timer coroutine started&quot;)&#10;&#10;            while (_isRestActive.value) {&#10;                delay(1000) // Update every second&#10;                elapsedRestTime += 1000&#10;                _restTimer.value = elapsedRestTime&#10;&#10;                println(&quot;⏱️ REST TIMER: ${elapsedRestTime / 1000}s (Live) - _restTimer.value = ${_restTimer.value}&quot;)&#10;            }&#10;            println(&quot; REST DEBUG: Rest timer coroutine ended&quot;)&#10;        }&#10;&#10;        println(&quot; REST TIMER STARTED - Job created: ${restTimerJob != null}&quot;)&#10;    }&#10;&#10;    private fun stopRestTimer() {&#10;        println(&quot; REST DEBUG: stopRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        if (!_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer not active, nothing to stop&quot;)&#10;            return&#10;        }&#10;&#10;        //  CRITICAL FIX: Capture rest time before stopping&#10;        val completedRestTime = _restTimer.value&#10;        println(&quot; REST DEBUG: Capturing rest time: ${completedRestTime}ms (${completedRestTime / 1000}s)&quot;)&#10;&#10;        //  NEW: Add to total rest time accumulator&#10;        _totalRestTime.value += completedRestTime&#10;        println(&quot; REST DEBUG: Added ${completedRestTime}ms to total rest time&quot;)&#10;        println(&quot; REST DEBUG: Total accumulated rest time is now: ${_totalRestTime.value}ms (${_totalRestTime.value / 1000}s)&quot;)&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to false&quot;)&#10;        _isRestActive.value = false&#10;&#10;        println(&quot; REST DEBUG: Cancelling rest timer job&quot;)&#10;        restTimerJob?.cancel()&#10;        restTimerJob = null&#10;&#10;        // Reset rest timer value (but keep the accumulated total)&#10;        val previousValue = _restTimer.value&#10;        _restTimer.value = 0L&#10;        println(&quot; REST DEBUG: Reset _restTimer from ${previousValue}ms to ${_restTimer.value}ms&quot;)&#10;&#10;        //  NEW: Update total exercise time with new rest time&#10;        updateTotalExerciseTime()&#10;&#10;        println(&quot;⏹️ REST TIMER STOPPED - Rest time captured and added to total&quot;)&#10;    }&#10;}&#10;&#10;class ExerciseDetailViewModelFactory(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ExerciseDetailViewModel::class.java)) {&#10;            return ExerciseDetailViewModel(workoutEntry, repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class SetTimer(&#10;    val setNumber: Int,&#10;    val elapsedTime: Long = 0L,&#10;    val isRunning: Boolean = false,&#10;    val isCompleted: Boolean = false,&#10;    val startTime: Long = 0L&#10;)&#10;&#10;class ExerciseDetailViewModel(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModel() {&#10;&#10;    // Load actual sets from database instead of creating in memory&#10;    private val _setTimers = MutableStateFlow&lt;List&lt;SetTimer&gt;&gt;(emptyList())&#10;    val setTimers: StateFlow&lt;List&lt;SetTimer&gt;&gt; = _setTimers.asStateFlow()&#10;&#10;    private val _currentRunningSet = MutableStateFlow&lt;Int?&gt;(null)&#10;    val currentRunningSet: StateFlow&lt;Int?&gt; = _currentRunningSet.asStateFlow()&#10;&#10;    private val _activeSetIndex = MutableStateFlow&lt;Int&gt;(0)&#10;    val activeSetIndex: StateFlow&lt;Int&gt; = _activeSetIndex.asStateFlow()&#10;&#10;    private val _totalExerciseTime = MutableStateFlow(0L)&#10;    val totalExerciseTime: StateFlow&lt;Long&gt; = _totalExerciseTime.asStateFlow()&#10;&#10;    private val _completedSets = MutableStateFlow(0)&#10;    val completedSets: StateFlow&lt;Int&gt; = _completedSets.asStateFlow()&#10;&#10;    private val _isExerciseCompleted = MutableStateFlow(false)&#10;    val isExerciseCompleted: StateFlow&lt;Boolean&gt; = _isExerciseCompleted.asStateFlow()&#10;&#10;    //  FIXED: Enhanced rest timer functionality with proper time tracking&#10;    private val _restTimer = MutableStateFlow(0L)&#10;    val restTimer: StateFlow&lt;Long&gt; = _restTimer.asStateFlow()&#10;&#10;    private val _isRestActive = MutableStateFlow(false)&#10;    val isRestActive: StateFlow&lt;Boolean&gt; = _isRestActive.asStateFlow()&#10;&#10;    //  NEW: Track accumulated rest time for total exercise time calculation&#10;    private val _totalRestTime = MutableStateFlow(0L)&#10;    val totalRestTime: StateFlow&lt;Long&gt; = _totalRestTime.asStateFlow()&#10;&#10;    //  NEW: Phase 2.1.2 - Set data entry dialog state&#10;    private val _showSetDataDialog = MutableStateFlow(false)&#10;    val showSetDataDialog: StateFlow&lt;Boolean&gt; = _showSetDataDialog.asStateFlow()&#10;&#10;    private val _pendingSetData = MutableStateFlow&lt;Pair&lt;Int, Int&gt;?&gt;(null) // (setIndex, setId)&#10;    val pendingSetData: StateFlow&lt;Pair&lt;Int, Int&gt;?&gt; = _pendingSetData.asStateFlow()&#10;&#10;    //  NEW: State flow to signal when 1-minute rest milestone is reached&#10;    private val _restMinuteMilestoneReached = MutableStateFlow(false)&#10;    val restMinuteMilestoneReached: StateFlow&lt;Boolean&gt; = _restMinuteMilestoneReached.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var restTimerJob: Job? = null&#10;    private var currentSetId: Int? = null&#10;&#10;    init {&#10;        loadSetsFromDatabase()&#10;    }&#10;&#10;    private fun loadSetsFromDatabase() {&#10;        viewModelScope.launch {&#10;            println(&quot; DETAIL VM: Loading sets for workout entry ID: ${workoutEntry.id}&quot;)&#10;            println(&quot; DETAIL VM: Exercise: '${workoutEntry.exerciseName}' (Exercise ID: ${workoutEntry.exerciseId})&quot;)&#10;&#10;            // First, ensure sets exist in database&#10;            val existingSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            println(&quot; DETAIL VM: Found ${existingSets.size} existing sets in database&quot;)&#10;&#10;            if (existingSets.isEmpty()) {&#10;                println(&quot; DETAIL VM: No sets found, creating ${workoutEntry.sets} sets&quot;)&#10;                // Create sets in database if they don't exist&#10;                repository.createSetsForWorkoutEntry(workoutEntry.id, workoutEntry.sets)&#10;                println(&quot; DETAIL VM: Sets created, reloading...&quot;)&#10;            } else {&#10;                println(&quot; DETAIL VM: Sets already exist:&quot;)&#10;                existingSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;            }&#10;&#10;            // Now load sets from database and observe changes&#10;            repository.getSetsForWorkoutEntry(workoutEntry.id).collect { dbSets -&gt;&#10;                println(&quot; DETAIL VM: Received ${dbSets.size} sets from Flow for WorkoutEntry ID: ${workoutEntry.id}&quot;)&#10;                dbSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Flow Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s, repsPerformed=${set.repsPerformed}&quot;)&#10;                }&#10;&#10;                val setTimers = dbSets.map { setEntry -&gt;&#10;                    SetTimer(&#10;                        setNumber = setEntry.setNumber,&#10;                        elapsedTime = (setEntry.elapsedTimeSeconds * 1000).toLong(),&#10;                        isRunning = false, // Never restore running state from DB&#10;                        isCompleted = setEntry.isCompleted,&#10;                        startTime = 0L&#10;                    )&#10;                }&#10;&#10;                println(&quot; DETAIL VM: Created ${setTimers.size} SetTimer objects for '${workoutEntry.exerciseName}'&quot;)&#10;                _setTimers.value = setTimers&#10;                _completedSets.value = dbSets.count { it.isCompleted }&#10;                _isExerciseCompleted.value = dbSets.all { it.isCompleted } &amp;&amp; dbSets.isNotEmpty()&#10;&#10;                //  FIX: Set the active set index to the first incomplete set&#10;                val firstIncompleteSetIndex = setTimers.indexOfFirst { !it.isCompleted }&#10;                _activeSetIndex.value =&#10;                    if (firstIncompleteSetIndex != -1) firstIncompleteSetIndex else 0&#10;                println(&quot; DETAIL VM: Set active set index to: ${_activeSetIndex.value}&quot;)&#10;&#10;                updateTotalExerciseTime()&#10;&#10;                println(&quot; DETAIL VM: State updated for '${workoutEntry.exerciseName}' - completedSets: ${_completedSets.value}, isCompleted: ${_isExerciseCompleted.value}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startSetTimer(setIndex: Int) {&#10;        println(&quot; REST DEBUG: startSetTimer called for set ${setIndex + 1}&quot;)&#10;&#10;        // Stop any currently running timer&#10;        stopAllTimers()&#10;&#10;        //  NEW: Stop rest timer when starting a new set&#10;        println(&quot; REST DEBUG: Stopping rest timer before starting new set&quot;)&#10;        stopRestTimer()&#10;&#10;        // Start timer for this set&#10;        val currentTime = System.currentTimeMillis()&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        updatedTimers[setIndex] = updatedTimers[setIndex].copy(&#10;            isRunning = true,&#10;            startTime = currentTime&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = setIndex&#10;&#10;        println(&quot; REST DEBUG: Set ${setIndex + 1} timer started at $currentTime&quot;)&#10;&#10;        // Store the database set ID for persistence&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            currentSetId = dbSets.getOrNull(setIndex)?.id&#10;        }&#10;&#10;        // Start the timer coroutine&#10;        timerJob = viewModelScope.launch {&#10;            while (_setTimers.value.getOrNull(setIndex)?.isRunning == true) {&#10;                delay(1000) // Update every second&#10;                updateTimerForSet(setIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopSetTimer(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        if (timer.isRunning) {&#10;            //  FIXED: Use current elapsed time directly, don't double-count&#10;            val finalElapsedTime = System.currentTimeMillis() - timer.startTime&#10;&#10;            println(&quot; STOP TIMER DEBUG: Set ${setIndex + 1}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: timer.elapsedTime = ${timer.elapsedTime}ms&quot;)&#10;            println(&quot; STOP TIMER DEBUG: startTime = ${timer.startTime}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: currentTime = ${System.currentTimeMillis()}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: calculated elapsed = ${finalElapsedTime}ms (${finalElapsedTime / 1000}s)&quot;)&#10;&#10;            updatedTimers[setIndex] = timer.copy(&#10;                isRunning = false,&#10;                elapsedTime = finalElapsedTime&#10;                //  CHANGED: Don't mark as completed here - wait for user data entry&#10;            )&#10;            _setTimers.value = updatedTimers&#10;            _currentRunningSet.value = null&#10;            timerJob?.cancel()&#10;&#10;            //  NEW: Phase 2.1.2 - Show data entry dialog instead of immediate completion&#10;            currentSetId?.let { setId -&gt;&#10;                println(&quot; DIALOG: Showing set data entry dialog for set ${setIndex + 1}&quot;)&#10;                _pendingSetData.value = Pair(setIndex, setId)&#10;                _showSetDataDialog.value = true&#10;&#10;                //  IMPORTANT: Start rest timer while user enters data&#10;                startRestTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Handle set performance data submission&#10;    fun submitSetPerformanceData(repsPerformed: Int, weightUsed: Float) {&#10;        val pendingData = _pendingSetData.value ?: return&#10;        val (setIndex, setId) = pendingData&#10;&#10;        println(&quot; DIALOG: Submitting performance data - Set ${setIndex + 1}, Reps: $repsPerformed, Weight: $weightUsed&quot;)&#10;&#10;        viewModelScope.launch {&#10;            // Get the timer data for this set&#10;            val timer = _setTimers.value.getOrNull(setIndex)&#10;            val elapsedTimeSeconds = ((timer?.elapsedTime ?: 0L) / 1000).toInt()&#10;&#10;            // Update database with completion and performance data&#10;            repository.updateSetProgressWithPerformanceData(&#10;                setId = setId,&#10;                isCompleted = true,&#10;                elapsedTimeSeconds = elapsedTimeSeconds,&#10;                repsPerformed = repsPerformed,&#10;                weightUsed = weightUsed&#10;            )&#10;&#10;            // Update local state to mark set as completed&#10;            val updatedTimers = _setTimers.value.toMutableList()&#10;            updatedTimers[setIndex] = updatedTimers[setIndex].copy(isCompleted = true)&#10;            _setTimers.value = updatedTimers&#10;&#10;            // Update exercise completion status&#10;            repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;&#10;            // Update local completed sets count&#10;            val completedCount = _setTimers.value.count { it.isCompleted }&#10;            _completedSets.value = completedCount&#10;&#10;            // Check if all sets are completed&#10;            if (completedCount == workoutEntry.sets) {&#10;                _isExerciseCompleted.value = true&#10;                // Stop rest timer if all sets are completed&#10;                stopRestTimer()&#10;            } else {&#10;                // Advance to next set - find the first incomplete set&#10;                val nextIncompleteSetIndex = _setTimers.value.indexOfFirst { !it.isCompleted }&#10;                if (nextIncompleteSetIndex != -1) {&#10;                    _activeSetIndex.value = nextIncompleteSetIndex&#10;                    println(&quot; DETAIL VM: Advanced to next set index: $nextIncompleteSetIndex&quot;)&#10;                }&#10;            }&#10;&#10;            // Update total time calculation&#10;            updateTotalExerciseTime()&#10;&#10;            // Hide dialog and clear pending data&#10;            _showSetDataDialog.value = false&#10;            _pendingSetData.value = null&#10;&#10;            println(&quot; DIALOG: Set performance data saved successfully&quot;)&#10;        }&#10;    }&#10;&#10;    //  NEW: 2.2.1 - Edit set data functionality&#10;    fun editSetData(setIndex: Int) {&#10;        println(&quot; EDIT: editSetData called for set ${setIndex + 1}&quot;)&#10;&#10;        viewModelScope.launch {&#10;            val sets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            val setToEdit = sets.getOrNull(setIndex)&#10;&#10;            if (setToEdit != null &amp;&amp; setToEdit.isCompleted) {&#10;                println(&quot; EDIT: Opening edit dialog for completed set ${setIndex + 1}&quot;)&#10;                _pendingSetData.value = Pair(setIndex, setToEdit.id)&#10;                _showSetDataDialog.value = true&#10;            } else {&#10;                println(&quot; EDIT: Cannot edit set ${setIndex + 1} - not completed or not found&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Enhanced dialog state management for editing&#10;    fun dismissSetDataDialog() {&#10;        println(&quot; DIALOG: Dismissing set data dialog&quot;)&#10;        _showSetDataDialog.value = false&#10;        _pendingSetData.value = null&#10;    }&#10;&#10;    // Get set data for UI display&#10;    fun getSetData(setIndex: Int) = repository.getSetByIndex(workoutEntry.id, setIndex + 1)&#10;&#10;    //  NEW: 2.2.2 - Dynamic Set Management Functions&#10;&#10;    //  NEW: Enhanced set management methods&#10;    fun removeSpecificSet(setIndex: Int) {&#10;        println(&quot; SET MGMT: removeSpecificSet() called for index $setIndex&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;&#10;                if (setIndex &lt; currentSets.size) {&#10;                    val setToRemove = currentSets[setIndex]&#10;&#10;                    // Can only remove incomplete sets and must have more than 1 set&#10;                    if (!setToRemove.isCompleted &amp;&amp; currentSets.size &gt; 1) {&#10;                        println(&quot; SET MGMT: Removing set #${setToRemove.setNumber} (ID: ${setToRemove.id})&quot;)&#10;&#10;                        // Stop any running timer for this set&#10;                        if (_currentRunningSet.value == setIndex) {&#10;                            stopAllTimers()&#10;                        }&#10;&#10;                        // Remove set from database&#10;                        repository.removeSetFromWorkoutEntry(setToRemove.id)&#10;&#10;                        // Update active set index if needed&#10;                        val newSetCount = currentSets.size - 1&#10;                        if (_activeSetIndex.value &gt;= newSetCount) {&#10;                            _activeSetIndex.value = maxOf(0, newSetCount - 1)&#10;                        }&#10;&#10;                        println(&quot; SET MGMT: Successfully removed set at index $setIndex&quot;)&#10;                    } else {&#10;                        println(&quot; SET MGMT ERROR: Cannot remove set - either completed or minimum count reached&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot; SET MGMT ERROR: Failed to remove specific set - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addSetWithReps() {&#10;        println(&quot; SET MGMT: addSetWithReps() called&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;                val newSetNumber = currentSets.size + 1&#10;&#10;                if (currentSets.size &lt; 8) { // Max 8 sets per exercise&#10;                    println(&quot; SET MGMT: Adding set #$newSetNumber&quot;)&#10;&#10;                    // Add new set to database - we don't need to pass targetReps since&#10;                    // the target reps value comes from the parent workout entry&#10;                    repository.addSetToWorkoutEntry(workoutEntry.id, newSetNumber)&#10;&#10;                    println(&quot; SET MGMT: Successfully added set #$newSetNumber&quot;)&#10;                } else {&#10;                    println(&quot; SET MGMT ERROR: Cannot add set - maximum 8 sets reached&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot; SET MGMT ERROR: Failed to add set - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        restTimerJob?.cancel() //  NEW: Clean up rest timer job&#10;    }&#10;&#10;    private fun stopAllTimers() {&#10;        timerJob?.cancel()&#10;        val updatedTimers = _setTimers.value.map { timer -&gt;&#10;            timer.copy(isRunning = false)&#10;        }&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;    }&#10;&#10;    private fun updateTimerForSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers[setIndex]&#10;&#10;        if (timer.isRunning) {&#10;            val currentTime = System.currentTimeMillis()&#10;            //  FIXED: Don't add previous elapsedTime - just calculate from start&#10;            val elapsed = currentTime - timer.startTime&#10;            updatedTimers[setIndex] = timer.copy(elapsedTime = elapsed)&#10;            _setTimers.value = updatedTimers&#10;&#10;            //  REMOVED: Don't update total time during live timer updates&#10;            // updateTotalExerciseTime() // This was causing live updates in top bar&#10;&#10;            //  ADDED: Force UI recomposition for live stopwatch display&#10;            println(&quot;⏱️ TIMER: Set ${setIndex + 1} - ${elapsed / 1000}s (Live)&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateTotalExerciseTime() {&#10;        //  FIXED: Only count completed sets for total time, not running timers&#10;        val completedSets = _setTimers.value.filter { it.isCompleted }&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Calculating total exercise time...&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Found ${completedSets.size} completed sets:&quot;)&#10;&#10;        completedSets.forEachIndexed { index, set -&gt;&#10;            println(&quot; TOTAL TIME DEBUG: Set ${index + 1}: ${set.elapsedTime}ms (${set.elapsedTime / 1000}s)&quot;)&#10;        }&#10;&#10;        val setTime = completedSets.sumOf { it.elapsedTime }&#10;&#10;        //  NEW: Include accumulated rest time in total&#10;        val restTime = _totalRestTime.value&#10;        val totalTime = setTime + restTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Sum of all completed sets: ${setTime}ms (${setTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Total accumulated rest time: ${restTime}ms (${restTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Combined total time: ${totalTime}ms (${totalTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Setting _totalExerciseTime to: ${totalTime}&quot;)&#10;&#10;        _totalExerciseTime.value = totalTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: _totalExerciseTime.value is now: ${_totalExerciseTime.value}&quot;)&#10;&#10;        //  NEW: Update totalSecondsSpent in WorkoutEntry database record&#10;        val totalSeconds = (totalTime / 1000).toInt()&#10;        viewModelScope.launch {&#10;            println(&quot; TOTAL TIME DEBUG: Updating WorkoutEntry.totalSecondsSpent to ${totalSeconds}s&quot;)&#10;            repository.updateExerciseTime(workoutEntry.id, totalSeconds)&#10;            println(&quot; TOTAL TIME DEBUG: Database updated with new exercise time&quot;)&#10;        }&#10;    }&#10;&#10;    //  NEW: Rest timer functionality&#10;    private fun startRestTimer() {&#10;        println(&quot; REST DEBUG: startRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        // Don't start a new rest timer if one is already active&#10;        if (_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer already active, skipping start&quot;)&#10;            return&#10;        }&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to true&quot;)&#10;        _isRestActive.value = true&#10;        val restStartTime = System.currentTimeMillis()&#10;        println(&quot; REST DEBUG: Rest timer start time: $restStartTime&quot;)&#10;&#10;        // Start the rest timer job&#10;        restTimerJob = viewModelScope.launch {&#10;            var elapsedRestTime = 0L&#10;            println(&quot; REST DEBUG: Rest timer coroutine started&quot;)&#10;&#10;            while (_isRestActive.value) {&#10;                delay(1000) // Update every second&#10;                elapsedRestTime += 1000&#10;                _restTimer.value = elapsedRestTime&#10;&#10;                //  NEW: Trigger milestone notification at 1 minute&#10;                if (elapsedRestTime &gt;= 60000 &amp;&amp; !_restMinuteMilestoneReached.value) {&#10;                    _restMinuteMilestoneReached.value = true&#10;                    println(&quot; REST MILESTONE: 1 minute of rest reached&quot;)&#10;                }&#10;&#10;                println(&quot;⏱️ REST TIMER: ${elapsedRestTime / 1000}s (Live) - _restTimer.value = ${_restTimer.value}&quot;)&#10;            }&#10;            println(&quot; REST DEBUG: Rest timer coroutine ended&quot;)&#10;        }&#10;&#10;        println(&quot; REST TIMER STARTED - Job created: ${restTimerJob != null}&quot;)&#10;    }&#10;&#10;    private fun stopRestTimer() {&#10;        println(&quot; REST DEBUG: stopRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        if (!_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer not active, nothing to stop&quot;)&#10;            return&#10;        }&#10;&#10;        //  CRITICAL FIX: Capture rest time before stopping&#10;        val completedRestTime = _restTimer.value&#10;        println(&quot; REST DEBUG: Capturing rest time: ${completedRestTime}ms (${completedRestTime / 1000}s)&quot;)&#10;&#10;        //  NEW: Add to total rest time accumulator&#10;        _totalRestTime.value += completedRestTime&#10;        println(&quot; REST DEBUG: Added ${completedRestTime}ms to total rest time&quot;)&#10;        println(&quot; REST DEBUG: Total accumulated rest time is now: ${_totalRestTime.value}ms (${_totalRestTime.value / 1000}s)&quot;)&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to false&quot;)&#10;        _isRestActive.value = false&#10;&#10;        println(&quot; REST DEBUG: Cancelling rest timer job&quot;)&#10;        restTimerJob?.cancel()&#10;        restTimerJob = null&#10;&#10;        // Reset rest timer value (but keep the accumulated total)&#10;        val previousValue = _restTimer.value&#10;        _restTimer.value = 0L&#10;        println(&quot; REST DEBUG: Reset _restTimer from ${previousValue}ms to ${_restTimer.value}ms&quot;)&#10;&#10;        //  NEW: Update total exercise time with new rest time&#10;        updateTotalExerciseTime()&#10;&#10;        println(&quot;⏹️ REST TIMER STOPPED - Rest time captured and added to total&quot;)&#10;    }&#10;}&#10;&#10;class ExerciseDetailViewModelFactory(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ExerciseDetailViewModel::class.java)) {&#10;            return ExerciseDetailViewModel(workoutEntry, repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/util/HapticFeedbackHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/util/HapticFeedbackHelper.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.util&#10;&#10;import android.content.Context&#10;import android.os.Build&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.view.HapticFeedbackConstants&#10;import android.view.View&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalView&#10;&#10;/**&#10; * Helper class for providing haptic feedback throughout the app&#10; */&#10;class HapticFeedbackHelper(private val context: Context) {&#10;&#10;    private val vibrator by lazy {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            val vibratorManager = context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            vibratorManager.defaultVibrator&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Different haptic feedback types for different actions&#10;     */&#10;    enum class FeedbackType {&#10;        BUTTON_PRESS,       // Light click for normal button presses&#10;        SUCCESS,            // Medium click with pattern for success actions (like completing a set)&#10;        ERROR,              // Error pattern (like validation error)&#10;        TIMER_START_STOP,   // Special pattern for timer start/stop&#10;        HEAVY_CLICK         // Strong click for important actions&#10;    }&#10;&#10;    /**&#10;     * Perform haptic feedback based on the feedback type&#10;     */&#10;    fun performHapticFeedback(feedbackType: FeedbackType) {&#10;        when (feedbackType) {&#10;            FeedbackType.BUTTON_PRESS -&gt; {&#10;                // Simple click for buttons&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    vibrator.vibrate(VibrationEffect.createOneShot(20, VibrationEffect.DEFAULT_AMPLITUDE))&#10;                } else {&#10;                    @Suppress(&quot;DEPRECATION&quot;)&#10;                    vibrator.vibrate(20)&#10;                }&#10;            }&#10;            FeedbackType.SUCCESS -&gt; {&#10;                // Double click pattern for success&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    vibrator.vibrate(VibrationEffect.createWaveform(longArrayOf(0, 40, 60, 40), -1))&#10;                } else {&#10;                    @Suppress(&quot;DEPRECATION&quot;)&#10;                    vibrator.vibrate(longArrayOf(0, 40, 60, 40), -1)&#10;                }&#10;            }&#10;            FeedbackType.ERROR -&gt; {&#10;                // Error pattern (longer vibration)&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    vibrator.vibrate(VibrationEffect.createOneShot(80, VibrationEffect.DEFAULT_AMPLITUDE))&#10;                } else {&#10;                    @Suppress(&quot;DEPRECATION&quot;)&#10;                    vibrator.vibrate(80)&#10;                }&#10;            }&#10;            FeedbackType.TIMER_START_STOP -&gt; {&#10;                // Special pattern for timer actions&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    vibrator.vibrate(VibrationEffect.createWaveform(longArrayOf(0, 30, 50, 30), -1))&#10;                } else {&#10;                    @Suppress(&quot;DEPRECATION&quot;)&#10;                    vibrator.vibrate(longArrayOf(0, 30, 50, 30), -1)&#10;                }&#10;            }&#10;            FeedbackType.HEAVY_CLICK -&gt; {&#10;                // Strong click&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    vibrator.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE))&#10;                } else {&#10;                    @Suppress(&quot;DEPRECATION&quot;)&#10;                    vibrator.vibrate(50)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Alternative method using View for haptic feedback&#10;     * This may work better in some cases where the vibrator service has limitations&#10;     */&#10;    fun performViewHapticFeedback(view: View, feedbackType: FeedbackType) {&#10;        when (feedbackType) {&#10;            FeedbackType.BUTTON_PRESS -&gt; {&#10;                view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY)&#10;            }&#10;            FeedbackType.SUCCESS -&gt; {&#10;                view.performHapticFeedback(HapticFeedbackConstants.CONFIRM)&#10;            }&#10;            FeedbackType.ERROR -&gt; {&#10;                view.performHapticFeedback(HapticFeedbackConstants.REJECT)&#10;            }&#10;            FeedbackType.TIMER_START_STOP -&gt; {&#10;                view.performHapticFeedback(HapticFeedbackConstants.CLOCK_TICK)&#10;            }&#10;            FeedbackType.HEAVY_CLICK -&gt; {&#10;                view.performHapticFeedback(HapticFeedbackConstants.CONTEXT_CLICK)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Composable function to create and remember a HapticFeedbackHelper instance&#10; */&#10;@Composable&#10;fun rememberHapticFeedback(): HapticFeedbackHelper {&#10;    val context = LocalContext.current&#10;    return remember { HapticFeedbackHelper(context) }&#10;}&#10;&#10;/**&#10; * Extension function for View to perform haptic feedback&#10; */&#10;fun View.performCustomHapticFeedback(feedbackType: HapticFeedbackHelper.FeedbackType) {&#10;    val hapticHelper = HapticFeedbackHelper(this.context)&#10;    hapticHelper.performViewHapticFeedback(this, feedbackType)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/util/NotificationHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/util/NotificationHelper.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.util&#10;&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.media.RingtoneManager&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import com.example.offlinepplworkoutapp.MainActivity&#10;import com.example.offlinepplworkoutapp.R&#10;&#10;/**&#10; * Helper class for creating and showing notifications in the app&#10; */&#10;class NotificationHelper(private val context: Context) {&#10;&#10;    companion object {&#10;        const val CHANNEL_ID_WORKOUT = &quot;workout_notifications&quot;&#10;        const val NOTIFICATION_ID_REST_TIMER = 1001&#10;    }&#10;&#10;    private val notificationManager: NotificationManager by lazy {&#10;        context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;    }&#10;&#10;    /**&#10;     * Initialize notification channels for the app.&#10;     * This should be called once at app startup.&#10;     */&#10;    fun createChannels() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val workoutChannel = NotificationChannel(&#10;                CHANNEL_ID_WORKOUT,&#10;                &quot;Workout Notifications&quot;,&#10;                NotificationManager.IMPORTANCE_HIGH // Changed to HIGH for sound and heads-up notification&#10;            ).apply {&#10;                description = &quot;Notifications for workout timers and events&quot;&#10;                enableVibration(true)&#10;                setShowBadge(true)&#10;            }&#10;&#10;            notificationManager.createNotificationChannel(workoutChannel)&#10;            println(&quot; NOTIFICATION: Created notification channel: ${workoutChannel.id}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Show a notification when rest timer reaches 1 minute&#10;     */&#10;    fun showRestTimerNotification(exerciseName: String) {&#10;        println(&quot; NOTIFICATION: Preparing to show rest timer notification for $exerciseName&quot;)&#10;&#10;        // Create an intent to open the app when notification is tapped&#10;        val intent = Intent(context, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        // Get default notification sound&#10;        val defaultSoundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)&#10;&#10;        // Build the notification&#10;        val notification = NotificationCompat.Builder(context, CHANNEL_ID_WORKOUT)&#10;            .setSmallIcon(R.drawable.ic_notification)&#10;            .setContentTitle(&quot;Rest Timer&quot;)&#10;            .setContentText(&quot;You've been resting for 1 minute on $exerciseName&quot;)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH) // Set high priority&#10;            .setContentIntent(pendingIntent)&#10;            .setSound(defaultSoundUri) // Add sound&#10;            .setVibrate(longArrayOf(0, 250, 250, 250)) // Add vibration pattern&#10;            .setAutoCancel(true)&#10;            .build()&#10;&#10;        // Show the notification&#10;        notificationManager.notify(NOTIFICATION_ID_REST_TIMER, notification)&#10;        println(&quot; NOTIFICATION: Rest timer notification sent with ID: $NOTIFICATION_ID_REST_TIMER&quot;)&#10;    }&#10;&#10;    /**&#10;     * Cancel any active rest timer notifications&#10;     */&#10;    fun cancelRestTimerNotification() {&#10;        notificationManager.cancel(NOTIFICATION_ID_REST_TIMER)&#10;        println(&quot; NOTIFICATION: Rest timer notification cancelled&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.util&#10;&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.media.AudioAttributes&#10;import android.media.RingtoneManager&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import com.example.offlinepplworkoutapp.MainActivity&#10;import com.example.offlinepplworkoutapp.R&#10;&#10;/**&#10; * Helper class for creating and showing notifications in the app&#10; */&#10;class NotificationHelper(private val context: Context) {&#10;&#10;    companion object {&#10;        const val CHANNEL_ID_WORKOUT = &quot;workout_notifications&quot;&#10;        const val NOTIFICATION_ID_REST_TIMER = 1001&#10;    }&#10;&#10;    private val notificationManager: NotificationManager by lazy {&#10;        context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;    }&#10;&#10;    /**&#10;     * Initialize notification channels for the app.&#10;     * This should be called once at app startup.&#10;     */&#10;    fun createChannels() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            // Get default notification sound&#10;            val defaultSoundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)&#10;&#10;            // Set audio attributes for the channel&#10;            val audioAttributes = AudioAttributes.Builder()&#10;                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)&#10;                .setUsage(AudioAttributes.USAGE_NOTIFICATION)&#10;                .build()&#10;&#10;            val workoutChannel = NotificationChannel(&#10;                CHANNEL_ID_WORKOUT,&#10;                &quot;Workout Notifications&quot;,&#10;                NotificationManager.IMPORTANCE_HIGH // HIGH importance for heads-up display&#10;            ).apply {&#10;                description = &quot;Notifications for workout timers and events&quot;&#10;                enableVibration(true)&#10;                vibrationPattern = longArrayOf(0, 250, 250, 250) // Vibration pattern&#10;                setSound(defaultSoundUri, audioAttributes) // Set sound with attributes&#10;                setShowBadge(true)&#10;                enableLights(true)&#10;                lightColor = context.resources.getColor(R.color.purple_500, null)&#10;            }&#10;&#10;            notificationManager.createNotificationChannel(workoutChannel)&#10;            println(&quot; NOTIFICATION: Created notification channel: ${workoutChannel.id}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Show a notification when rest timer reaches 1 minute&#10;     */&#10;    fun showRestTimerNotification(exerciseName: String) {&#10;        println(&quot; NOTIFICATION: Preparing to show rest timer notification for $exerciseName&quot;)&#10;&#10;        // Create an intent to open the app when notification is tapped&#10;        val intent = Intent(context, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        // Get default notification sound&#10;        val defaultSoundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)&#10;&#10;        // Build the notification with heads-up display capability&#10;        val notification = NotificationCompat.Builder(context, CHANNEL_ID_WORKOUT)&#10;            .setSmallIcon(R.drawable.ic_notification)&#10;            .setContentTitle(&quot;Rest Timer Alert&quot;)&#10;            .setContentText(&quot;You've been resting for 1 minute on $exerciseName&quot;)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH) // High priority for heads-up&#10;            .setCategory(NotificationCompat.CATEGORY_ALARM) // Use alarm category for higher priority&#10;            .setContentIntent(pendingIntent)&#10;            .setSound(defaultSoundUri)&#10;            .setVibrate(longArrayOf(0, 250, 250, 250)) // Add vibration pattern&#10;            .setAutoCancel(true)&#10;            // Make this a heads-up notification&#10;            .setFullScreenIntent(pendingIntent, true)&#10;            .build()&#10;&#10;        // Show the notification&#10;        notificationManager.notify(NOTIFICATION_ID_REST_TIMER, notification)&#10;        println(&quot; NOTIFICATION: Rest timer notification sent with ID: $NOTIFICATION_ID_REST_TIMER&quot;)&#10;    }&#10;&#10;    /**&#10;     * Cancel any active rest timer notifications&#10;     */&#10;    fun cancelRestTimerNotification() {&#10;        notificationManager.cancel(NOTIFICATION_ID_REST_TIMER)&#10;        println(&quot; NOTIFICATION: Rest timer notification cancelled&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_notification.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_notification.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorControlNormal&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/white&quot;&#10;        android:pathData=&quot;M20,2L4,2c-1.1,0 -1.99,0.9 -1.99,2L2,22l4,-4h14c1.1,0 2,-0.9 2,-2L22,4c0,-1.1 -0.9,-2 -2,-2zM13,11h-2L11,5h2v6zM13,15h-2v-2h2v2z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>