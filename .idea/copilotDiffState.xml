<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.offlinepplworkoutapp&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.offlinepplworkoutapp&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;    lint {&#10;        disable += &quot;SuspiciousModifierThen&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Room database&#10;    implementation(libs.androidx.room.runtime)&#10;    implementation(libs.androidx.room.ktx)&#10;    ksp(libs.androidx.room.compiler)&#10;&#10;    // Navigation&#10;    implementation(libs.androidx.navigation.compose)&#10;&#10;    testImplementation(libs.junit)&#10;    testImplementation(libs.androidx.room.testing)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.offlinepplworkoutapp&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.offlinepplworkoutapp&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;    lint {&#10;        disable += &quot;SuspiciousModifierThen&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Material Icons - Core and Extended sets&#10;    implementation(libs.androidx.material.icons.core)&#10;    implementation(libs.androidx.material.icons.extended)&#10;&#10;    // Room database&#10;    implementation(libs.androidx.room.runtime)&#10;    implementation(libs.androidx.room.ktx)&#10;    ksp(libs.androidx.room.compiler)&#10;&#10;    // Navigation&#10;    implementation(libs.androidx.navigation.compose)&#10;&#10;    testImplementation(libs.junit)&#10;    testImplementation(libs.androidx.room.testing)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/MainActivity.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.screens.MainScreen&#10;import com.example.offlinepplworkoutapp.ui.theme.OfflinePPLWorkOutAppTheme&#10;import com.example.offlinepplworkoutapp.util.NotificationHelper&#10;&#10;private const val IS_DEBUG_MODE = true&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var database: PPLWorkoutDatabase&#10;    private lateinit var repository: WorkoutRepository&#10;    private lateinit var notificationHelper: NotificationHelper&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        println(&quot; NOTIFICATION: Permission ${if (isGranted) &quot;granted&quot; else &quot;denied&quot;}&quot;)&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        database = PPLWorkoutDatabase.getDatabase(this)&#10;        repository = WorkoutRepository(&#10;            workoutDayDao = database.workoutDayDao(),&#10;            workoutEntryDao = database.workoutEntryDao(),&#10;            setEntryDao = database.setEntryDao(),&#10;            workoutTemplateDao = database.workoutTemplateDao(),&#10;            templateExerciseDao = database.templateExerciseDao()&#10;        )&#10;&#10;        notificationHelper = NotificationHelper(this)&#10;        notificationHelper.createChannels()&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (checkSelfPermission(Manifest.permission.POST_NOTIFICATIONS) !=&#10;                PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            OfflinePPLWorkOutAppTheme {&#10;                MainScreen(repository = repository)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.screens.AppNavigationContainer&#10;import com.example.offlinepplworkoutapp.ui.theme.OfflinePPLWorkOutAppTheme&#10;import com.example.offlinepplworkoutapp.util.NotificationHelper&#10;&#10;private const val IS_DEBUG_MODE = true&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var database: PPLWorkoutDatabase&#10;    private lateinit var repository: WorkoutRepository&#10;    private lateinit var notificationHelper: NotificationHelper&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        println(&quot; NOTIFICATION: Permission ${if (isGranted) &quot;granted&quot; else &quot;denied&quot;}&quot;)&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        database = PPLWorkoutDatabase.getDatabase(this)&#10;        repository = WorkoutRepository(&#10;            workoutDayDao = database.workoutDayDao(),&#10;            workoutEntryDao = database.workoutEntryDao(),&#10;            setEntryDao = database.setEntryDao(),&#10;            workoutTemplateDao = database.workoutTemplateDao(),&#10;            templateExerciseDao = database.templateExerciseDao()&#10;        )&#10;&#10;        notificationHelper = NotificationHelper(this)&#10;        notificationHelper.createChannels()&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (checkSelfPermission(Manifest.permission.POST_NOTIFICATIONS) !=&#10;                PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            OfflinePPLWorkOutAppTheme {&#10;                AppNavigationContainer(repository = repository)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/entity/TemplateExercise.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/entity/TemplateExercise.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.data.entity&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import androidx.room.ForeignKey&#10;&#10;/**&#10; * Template Exercise Junction Entity - Links exercises to workout templates&#10; *&#10; * This entity defines which exercises belong to each template and their configuration&#10; * (sets, reps, rest periods, order). This allows for flexible template composition.&#10; */&#10;@Entity(&#10;    tableName = &quot;template_exercises&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = WorkoutTemplate::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;templateId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        ),&#10;        ForeignKey(&#10;            entity = Exercise::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;exerciseId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        )&#10;    ]&#10;)&#10;data class TemplateExercise(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;&#10;    val templateId: Int,           // FK to workout_templates&#10;    val exerciseId: Int,           // FK to exercises&#10;    val orderIndex: Int,           // Exercise order in template (0, 1, 2, etc.)&#10;    val sets: Int,                 // Default sets for this exercise in this template&#10;    val reps: Int,                 // Default reps for this exercise&#10;    val restSeconds: Int,          // Recommended rest between sets (in seconds)&#10;&#10;    // Optional fields for advanced configurations&#10;    val weight: Double = 0.0,      // Suggested starting weight (if applicable)&#10;    val notes: String = &quot;&quot;,        // Exercise-specific notes for this template&#10;    val isSuperset: Boolean = false, // For future superset implementation&#10;    val supersetGroup: Int = 0     // Group ID for supersets (0 = no superset)&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.entity&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import androidx.room.ForeignKey&#10;import androidx.room.Index&#10;&#10;/**&#10; * Template Exercise Junction Entity - Links exercises to workout templates&#10; *&#10; * This entity defines which exercises belong to each template and their configuration&#10; * (sets, reps, rest periods, order). This allows for flexible template composition.&#10; */&#10;@Entity(&#10;    tableName = &quot;template_exercises&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = WorkoutTemplate::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;templateId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        ),&#10;        ForeignKey(&#10;            entity = Exercise::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;exerciseId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        )&#10;    ],&#10;    indices = [&#10;        Index(value = [&quot;templateId&quot;]),&#10;        Index(value = [&quot;exerciseId&quot;])&#10;    ]&#10;)&#10;data class TemplateExercise(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;&#10;    val templateId: Int,           // FK to workout_templates&#10;    val exerciseId: Int,           // FK to exercises&#10;    val orderIndex: Int,           // Exercise order in template (0, 1, 2, etc.)&#10;    val sets: Int,                 // Default sets for this exercise in this template&#10;    val reps: Int,                 // Default reps for this exercise&#10;    val restSeconds: Int,          // Recommended rest between sets (in seconds)&#10;&#10;    // Optional fields for advanced configurations&#10;    val weight: Double = 0.0,      // Suggested starting weight (if applicable)&#10;    val notes: String = &quot;&quot;,        // Exercise-specific notes for this template&#10;    val isSuperset: Boolean = false, // For future superset implementation&#10;    val supersetGroup: Int = 0     // Group ID for supersets (0 = no superset)&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/navigation/NavigationGraph.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/navigation/NavigationGraph.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.navigation&#10;&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.screens.HistoryScreen&#10;import com.example.offlinepplworkoutapp.ui.screens.HomeScreen&#10;import com.example.offlinepplworkoutapp.ui.screens.PerformanceScreen&#10;import com.example.offlinepplworkoutapp.ui.screens.SettingsScreen&#10;&#10;sealed class Screen(val route: String) {&#10;    object Home : Screen(&quot;home&quot;)&#10;    object History : Screen(&quot;history&quot;)&#10;    object Performance : Screen(&quot;performance&quot;)&#10;    object Settings : Screen(&quot;settings&quot;)&#10;    object ExerciseDetail : Screen(&quot;exercise_detail&quot;)&#10;}&#10;&#10;@Composable&#10;fun NavigationGraph(&#10;    navController: NavHostController,&#10;    repository: WorkoutRepository,&#10;    onNavigateToExerciseDetail: () -&gt; Unit&#10;) {&#10;    // Store selected exercise at the navigation graph level&#10;    var selectedExercise by remember { mutableStateOf&lt;WorkoutEntryWithExercise?&gt;(null) }&#10;    &#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = Screen.Home.route&#10;    ) {&#10;        composable(Screen.Home.route) {&#10;            HomeScreen(&#10;                repository = repository,&#10;                onNavigateToExerciseDetail = {&#10;                    // When navigating to exercise detail, we'll handle it within the HomeScreen&#10;                    // This is because we need to maintain the exercise state there&#10;                    onNavigateToExerciseDetail()&#10;                }&#10;            )&#10;        }&#10;        &#10;        composable(Screen.History.route) {&#10;            HistoryScreen(repository = repository)&#10;        }&#10;        &#10;        composable(Screen.Performance.route) {&#10;            PerformanceScreen(repository = repository)&#10;        }&#10;        &#10;        composable(Screen.Settings.route) {&#10;            SettingsScreen()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/BottomNavigation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/BottomNavigation.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.components&#10;&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import com.example.offlinepplworkoutapp.R&#10;import com.example.offlinepplworkoutapp.navigation.Screen&#10;&#10;@Composable&#10;fun BottomNavigation(navController: NavController) {&#10;    val items = listOf(&#10;        BottomNavItem(Screen.Home.route, &quot;Home&quot;, R.drawable.ic_home),&#10;        BottomNavItem(Screen.History.route, &quot;History&quot;, R.drawable.ic_history),&#10;        BottomNavItem(Screen.Performance.route, &quot;Performance&quot;, R.drawable.ic_performance),&#10;        BottomNavItem(Screen.Settings.route, &quot;Settings&quot;, R.drawable.ic_settings)&#10;    )&#10;&#10;    NavigationBar(&#10;        containerColor = MaterialTheme.colorScheme.surface&#10;    ) {&#10;        val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;        val currentRoute = navBackStackEntry?.destination?.route&#10;        &#10;        items.forEach { item -&gt;&#10;            NavigationBarItem(&#10;                icon = { &#10;                    Icon(&#10;                        painter = painterResource(id = item.icon), &#10;                        contentDescription = item.title&#10;                    )&#10;                },&#10;                label = { &#10;                    Text(&#10;                        text = item.title,&#10;                        fontSize = 12.sp&#10;                    ) &#10;                },&#10;                selected = currentRoute == item.route,&#10;                onClick = {&#10;                    if (currentRoute != item.route) {&#10;                        navController.navigate(item.route) {&#10;                            // Pop up to the start destination of the graph to&#10;                            // avoid building up a large stack of destinations&#10;                            popUpTo(navController.graph.startDestinationId) {&#10;                                saveState = true&#10;                            }&#10;                            // Avoid multiple copies of the same destination&#10;                            launchSingleTop = true&#10;                            // Restore state when re-selecting a previously selected item&#10;                            restoreState = true&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;data class BottomNavItem(&#10;    val route: String,&#10;    val title: String,&#10;    val icon: Int&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/DebugDaySelector.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/DebugDaySelector.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.components&#10;&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import com.example.offlinepplworkoutapp.data.database.PPLWorkoutDatabase&#10;import kotlinx.coroutines.launch&#10;import java.util.Calendar&#10;&#10;@Composable&#10;fun DebugDaySelector(&#10;    onDaySelected: (Int) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit,&#10;    onResetDatabase: () -&gt; Unit = {}&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&#10;                text = &quot; Debug Day Selector&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        },&#10;        text = {&#10;            LazyColumn {&#10;                item {&#10;                    Text(&#10;                        text = &quot;Select a day to test different workouts:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                }&#10;&#10;                val days = listOf(&#10;                    Calendar.MONDAY to &quot;Monday - Push Day 1 &quot;,&#10;                    Calendar.TUESDAY to &quot;Tuesday - Pull Day 1 ️&quot;,&#10;                    Calendar.WEDNESDAY to &quot;Wednesday - Legs Day 1 &quot;,&#10;                    Calendar.THURSDAY to &quot;Thursday - Push Day 2 &quot;,&#10;                    Calendar.FRIDAY to &quot;Friday - Pull Day 2 ️&quot;,&#10;                    Calendar.SATURDAY to &quot;Saturday - Legs Day 2 &quot;,&#10;                    Calendar.SUNDAY to &quot;Sunday - Rest Day ‍♂️&quot;&#10;                )&#10;&#10;                items(days) { (dayOfWeek, dayLabel) -&gt;&#10;                    OutlinedButton(&#10;                        onClick = { onDaySelected(dayOfWeek) },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 4.dp),&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            containerColor = if (dayOfWeek == Calendar.SUNDAY)&#10;                                MaterialTheme.colorScheme.secondaryContainer&#10;                            else&#10;                                MaterialTheme.colorScheme.primaryContainer&#10;                        )&#10;                    ) {&#10;                        Text(&#10;                            text = dayLabel,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            modifier = Modifier.padding(8.dp)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Debug Actions:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                println(&quot; DEBUG: Checking current database state...&quot;)&#10;                                val currentState = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                                println(&quot; CURRENT STATE: ${currentState.first} days, ${currentState.second} entries, ${currentState.third} sets&quot;)&#10;                            }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.tertiary&#10;                        )&#10;                    ) {&#10;                        Text(&quot; Check DB State&quot;)&#10;                    }&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                println(&quot; DEBUG: Force reset database...&quot;)&#10;                                PPLWorkoutDatabase.forceResetDatabase(context)&#10;                                kotlinx.coroutines.delay(200)&#10;                                val afterState = PPLWorkoutDatabase.verifyDatabaseEmpty()&#10;                                println(&quot; AFTER FORCE RESET: ${afterState.first} days, ${afterState.second} entries, ${afterState.third} sets&quot;)&#10;                                onResetDatabase()&#10;                            }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 2.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.error&#10;                        )&#10;                    ) {&#10;                        Text(&quot; Reset Database&quot;)&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/exercise/SetTimerCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/exercise/SetTimerCard.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.components.exercise&#10;&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.offlinepplworkoutapp.ui.theme.AmberAccent&#10;import com.example.offlinepplworkoutapp.ui.theme.CardBackground&#10;import com.example.offlinepplworkoutapp.ui.theme.PrimaryCoral&#10;import com.example.offlinepplworkoutapp.ui.theme.ProgressEnd&#10;import com.example.offlinepplworkoutapp.ui.theme.ProgressStart&#10;import com.example.offlinepplworkoutapp.ui.theme.SuccessGreen&#10;import com.example.offlinepplworkoutapp.ui.theme.TealSecondary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextPrimary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextSecondary&#10;import com.example.offlinepplworkoutapp.utils.HapticFeedbackHelper&#10;import com.example.offlinepplworkoutapp.utils.rememberHapticFeedback&#10;&#10;@Composable&#10;fun SetTimerCard(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    targetReps: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean = false,&#10;    isActive: Boolean = false,&#10;    isLocked: Boolean = false,&#10;    repsPerformed: Int = 0,&#10;    weightUsed: Float = 0f,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onEditSet: () -&gt; Unit,&#10;    onDeleteSet: (() -&gt; Unit)? = null&#10;) {&#10;    val hapticFeedback = rememberHapticFeedback()&#10;&#10;    // Animation for card elevation based on state&#10;    val animatedElevation by animateDpAsState(&#10;        targetValue = when {&#10;            isCurrentSet -&gt; 12.dp&#10;            isActive -&gt; 6.dp&#10;            else -&gt; 2.dp&#10;        },&#10;        animationSpec = tween(300)&#10;    )&#10;&#10;    // Card colors based on state&#10;    val cardColors = when {&#10;        isCompleted -&gt; CardDefaults.cardColors(&#10;            containerColor = SuccessGreen.copy(alpha = 0.1f)&#10;        )&#10;&#10;        isCurrentSet -&gt; CardDefaults.cardColors(&#10;            containerColor = Color.Transparent&#10;        )&#10;&#10;        isActive -&gt; CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        )&#10;&#10;        isLocked -&gt; CardDefaults.cardColors(&#10;            containerColor = TextSecondary.copy(alpha = 0.05f)&#10;        )&#10;&#10;        else -&gt; CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(animatedElevation, RoundedCornerShape(16.dp))&#10;            .then(&#10;                if (isCurrentSet) {&#10;                    Modifier&#10;                        .border(&#10;                            width = 3.dp,&#10;                            brush = Brush.horizontalGradient(&#10;                                colors = listOf(ProgressStart, ProgressEnd)&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                        .background(&#10;                            brush = Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    ProgressStart.copy(alpha = 0.1f),&#10;                                    ProgressEnd.copy(alpha = 0.05f)&#10;                                )&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                } else {&#10;                    Modifier&#10;                }&#10;            ),&#10;        colors = cardColors,&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            // Set header with status icon and timer&#10;            SetHeaderRow(&#10;                setNumber = setNumber,&#10;                totalSets = totalSets,&#10;                setTimer = setTimer,&#10;                isCurrentSet = isCurrentSet,&#10;                isCompleted = isCompleted,&#10;                isLocked = isLocked,&#10;                onDeleteSet = onDeleteSet&#10;            )&#10;&#10;            // Target reps and performance data&#10;            SetInfoRow(&#10;                targetReps = targetReps,&#10;                repsPerformed = repsPerformed,&#10;                weightUsed = weightUsed,&#10;                isCompleted = isCompleted&#10;            )&#10;&#10;            // Action buttons&#10;            SetActionButtons(&#10;                isCompleted = isCompleted,&#10;                isLocked = isLocked,&#10;                isCurrentSet = isCurrentSet,&#10;                repsPerformed = repsPerformed,&#10;                weightUsed = weightUsed,&#10;                onStartTimer = onStartTimer,&#10;                onStopTimer = onStopTimer,&#10;                onEditSet = onEditSet,&#10;                hapticFeedback = hapticFeedback&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetHeaderRow(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean,&#10;    isLocked: Boolean,&#10;    onDeleteSet: (() -&gt; Unit)?&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            // Set status icon&#10;            SetStatusIcon(&#10;                isCompleted = isCompleted,&#10;                isCurrentSet = isCurrentSet,&#10;                isLocked = isLocked&#10;            )&#10;&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;&#10;            Text(&#10;                text = &quot;Set $setNumber of $totalSets&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = when {&#10;                        isLocked -&gt; TextSecondary.copy(alpha = 0.6f)&#10;                        else -&gt; TextPrimary&#10;                    }&#10;                )&#10;            )&#10;        }&#10;&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            // Delete button for incomplete sets&#10;            if (onDeleteSet != null) {&#10;                IconButton(&#10;                    onClick = onDeleteSet,&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Delete,&#10;                        contentDescription = &quot;Delete set&quot;,&#10;                        tint = PrimaryCoral,&#10;                        modifier = Modifier.size(18.dp)&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;            }&#10;&#10;            // Timer display&#10;            TimerDisplay(&#10;                time = setTimer,&#10;                isActive = isCurrentSet,&#10;                isCompleted = isCompleted&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetStatusIcon(&#10;    isCompleted: Boolean,&#10;    isCurrentSet: Boolean,&#10;    isLocked: Boolean&#10;) {&#10;    when {&#10;        isCompleted -&gt; {&#10;            Icon(&#10;                imageVector = Icons.Default.Check,&#10;                contentDescription = &quot;Completed&quot;,&#10;                tint = SuccessGreen,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;&#10;        isCurrentSet -&gt; {&#10;            Icon(&#10;                imageVector = Icons.Default.PlayArrow,&#10;                contentDescription = &quot;Active&quot;,&#10;                tint = PrimaryCoral,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;&#10;        isLocked -&gt; {&#10;            Icon(&#10;                imageVector = Icons.Default.Lock,&#10;                contentDescription = &quot;Locked&quot;,&#10;                tint = TextSecondary,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;&#10;        else -&gt; {&#10;            Icon(&#10;                imageVector = Icons.Default.DateRange,&#10;                contentDescription = &quot;Ready&quot;,&#10;                tint = TealSecondary,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetInfoRow(&#10;    targetReps: Int,&#10;    repsPerformed: Int,&#10;    weightUsed: Float,&#10;    isCompleted: Boolean&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween&#10;    ) {&#10;        Text(&#10;            text = &quot;Target: $targetReps reps&quot;,&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                color = TextSecondary,&#10;                fontSize = 14.sp&#10;            )&#10;        )&#10;&#10;        // Display performance data when set is completed&#10;        if (isCompleted &amp;&amp; (repsPerformed &gt; 0 || weightUsed &gt; 0f)) {&#10;            Text(&#10;                text = buildString {&#10;                    if (repsPerformed &gt; 0) append(&quot;$repsPerformed reps&quot;)&#10;                    if (repsPerformed &gt; 0 &amp;&amp; weightUsed &gt; 0f) append(&quot; × &quot;)&#10;                    if (weightUsed &gt; 0f) append(&quot;${weightUsed}lbs&quot;)&#10;                },&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    color = PrimaryCoral,&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetActionButtons(&#10;    isCompleted: Boolean,&#10;    isLocked: Boolean,&#10;    isCurrentSet: Boolean,&#10;    repsPerformed: Int,&#10;    weightUsed: Float,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onEditSet: () -&gt; Unit,&#10;    hapticFeedback: HapticFeedbackHelper&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        when {&#10;            isCompleted -&gt; {&#10;                SetCompletedState(&#10;                    repsPerformed = repsPerformed,&#10;                    weightUsed = weightUsed,&#10;                    onEditSet = onEditSet,&#10;                    hapticFeedback = hapticFeedback&#10;                )&#10;            }&#10;&#10;            isLocked -&gt; {&#10;                Text(&#10;                    text = &quot;Complete previous sets first&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        color = TextSecondary,&#10;                        fontStyle = androidx.compose.ui.text.font.FontStyle.Italic&#10;                    ),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            isCurrentSet -&gt; {&#10;                Button(&#10;                    onClick = {&#10;                        hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.SUCCESS)&#10;                        onStopTimer()&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = SuccessGreen&#10;                    ),&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Check,&#10;                        contentDescription = &quot;Stop and Complete&quot;,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&quot;Complete Set&quot;)&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                Button(&#10;                    onClick = {&#10;                        hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.TIMER_START_STOP)&#10;                        onStartTimer()&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = PrimaryCoral&#10;                    ),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    enabled = !isLocked&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Start&quot;,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&quot;Start Set&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetCompletedState(&#10;    repsPerformed: Int,&#10;    weightUsed: Float,&#10;    onEditSet: () -&gt; Unit,&#10;    hapticFeedback: com.example.offlinepplworkoutapp.utils.HapticFeedbackHelper&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.weight(1f),&#10;            verticalArrangement = Arrangement.spacedBy(4.dp)&#10;        ) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Check,&#10;                    contentDescription = &quot;Completed&quot;,&#10;                    tint = SuccessGreen,&#10;                    modifier = Modifier.size(16.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;                Text(&#10;                    text = &quot;Set Completed&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        color = SuccessGreen,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                )&#10;            }&#10;&#10;            // Detailed performance data display&#10;            if (repsPerformed &gt; 0 || weightUsed &gt; 0f) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 4.dp),&#10;                    horizontalArrangement = Arrangement.Start&#10;                ) {&#10;                    if (repsPerformed &gt; 0) {&#10;                        Text(&#10;                            text = &quot;Performed: $repsPerformed reps&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                    if (repsPerformed &gt; 0 &amp;&amp; weightUsed &gt; 0f) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    if (weightUsed &gt; 0f) {&#10;                        Text(&#10;                            text = &quot;Weight: ${weightUsed}lbs&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Edit button for completed sets&#10;        IconButton(&#10;            onClick = @androidx.annotation.RequiresPermission(android.Manifest.permission.VIBRATE) {&#10;                hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.BUTTON_PRESS)&#10;                onEditSet()&#10;            },&#10;            modifier = Modifier.size(40.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Edit,&#10;                contentDescription = &quot;Edit set data&quot;,&#10;                tint = PrimaryCoral,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.components.exercise&#10;&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.RestartAlt&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.offlinepplworkoutapp.ui.theme.AmberAccent&#10;import com.example.offlinepplworkoutapp.ui.theme.CardBackground&#10;import com.example.offlinepplworkoutapp.ui.theme.PrimaryCoral&#10;import com.example.offlinepplworkoutapp.ui.theme.ProgressEnd&#10;import com.example.offlinepplworkoutapp.ui.theme.ProgressStart&#10;import com.example.offlinepplworkoutapp.ui.theme.SuccessGreen&#10;import com.example.offlinepplworkoutapp.ui.theme.TealSecondary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextPrimary&#10;import com.example.offlinepplworkoutapp.ui.theme.TextSecondary&#10;import com.example.offlinepplworkoutapp.utils.HapticFeedbackHelper&#10;import com.example.offlinepplworkoutapp.utils.rememberHapticFeedback&#10;&#10;@Composable&#10;fun SetTimerCard(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    targetReps: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean = false,&#10;    isActive: Boolean = false,&#10;    isLocked: Boolean = false,&#10;    repsPerformed: Int = 0,&#10;    weightUsed: Float = 0f,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onEditSet: () -&gt; Unit,&#10;    onDeleteSet: (() -&gt; Unit)? = null,&#10;    onResetSet: (() -&gt; Unit)? = null // New reset parameter&#10;) {&#10;    val hapticFeedback = rememberHapticFeedback()&#10;&#10;    // Animation for card elevation based on state&#10;    val animatedElevation by animateDpAsState(&#10;        targetValue = when {&#10;            isCurrentSet -&gt; 12.dp&#10;            isActive -&gt; 6.dp&#10;            else -&gt; 2.dp&#10;        },&#10;        animationSpec = tween(300)&#10;    )&#10;&#10;    // Card colors based on state&#10;    val cardColors = when {&#10;        isCompleted -&gt; CardDefaults.cardColors(&#10;            containerColor = SuccessGreen.copy(alpha = 0.1f)&#10;        )&#10;&#10;        isCurrentSet -&gt; CardDefaults.cardColors(&#10;            containerColor = Color.Transparent&#10;        )&#10;&#10;        isActive -&gt; CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        )&#10;&#10;        isLocked -&gt; CardDefaults.cardColors(&#10;            containerColor = TextSecondary.copy(alpha = 0.05f)&#10;        )&#10;&#10;        else -&gt; CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(animatedElevation, RoundedCornerShape(16.dp))&#10;            .then(&#10;                if (isCurrentSet) {&#10;                    Modifier&#10;                        .border(&#10;                            width = 3.dp,&#10;                            brush = Brush.horizontalGradient(&#10;                                colors = listOf(ProgressStart, ProgressEnd)&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                        .background(&#10;                            brush = Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    ProgressStart.copy(alpha = 0.1f),&#10;                                    ProgressEnd.copy(alpha = 0.05f)&#10;                                )&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                } else {&#10;                    Modifier&#10;                }&#10;            ),&#10;        colors = cardColors,&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            // Set header with status icon and timer&#10;            SetHeaderRow(&#10;                setNumber = setNumber,&#10;                totalSets = totalSets,&#10;                setTimer = setTimer,&#10;                isCurrentSet = isCurrentSet,&#10;                isCompleted = isCompleted,&#10;                isLocked = isLocked,&#10;                onDeleteSet = onDeleteSet&#10;            )&#10;&#10;            // Target reps and performance data&#10;            SetInfoRow(&#10;                targetReps = targetReps,&#10;                repsPerformed = repsPerformed,&#10;                weightUsed = weightUsed,&#10;                isCompleted = isCompleted&#10;            )&#10;&#10;            // Action buttons&#10;            SetActionButtons(&#10;                isCompleted = isCompleted,&#10;                isLocked = isLocked,&#10;                isCurrentSet = isCurrentSet,&#10;                repsPerformed = repsPerformed,&#10;                weightUsed = weightUsed,&#10;                onStartTimer = onStartTimer,&#10;                onStopTimer = onStopTimer,&#10;                onEditSet = onEditSet,&#10;                onResetSet = onResetSet, // Pass reset action&#10;                hapticFeedback = hapticFeedback&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetHeaderRow(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean,&#10;    isLocked: Boolean,&#10;    onDeleteSet: (() -&gt; Unit)?&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            // Set status icon&#10;            SetStatusIcon(&#10;                isCompleted = isCompleted,&#10;                isCurrentSet = isCurrentSet,&#10;                isLocked = isLocked&#10;            )&#10;&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;&#10;            Text(&#10;                text = &quot;Set $setNumber of $totalSets&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = when {&#10;                        isLocked -&gt; TextSecondary.copy(alpha = 0.6f)&#10;                        else -&gt; TextPrimary&#10;                    }&#10;                )&#10;            )&#10;        }&#10;&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            // Delete button for incomplete sets&#10;            if (onDeleteSet != null) {&#10;                IconButton(&#10;                    onClick = onDeleteSet,&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Delete,&#10;                        contentDescription = &quot;Delete set&quot;,&#10;                        tint = PrimaryCoral,&#10;                        modifier = Modifier.size(18.dp)&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;            }&#10;&#10;            // Timer display&#10;            TimerDisplay(&#10;                time = setTimer,&#10;                isActive = isCurrentSet,&#10;                isCompleted = isCompleted&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetStatusIcon(&#10;    isCompleted: Boolean,&#10;    isCurrentSet: Boolean,&#10;    isLocked: Boolean&#10;) {&#10;    when {&#10;        isCompleted -&gt; {&#10;            Icon(&#10;                imageVector = Icons.Default.Check,&#10;                contentDescription = &quot;Completed&quot;,&#10;                tint = SuccessGreen,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;&#10;        isCurrentSet -&gt; {&#10;            Icon(&#10;                imageVector = Icons.Default.PlayArrow,&#10;                contentDescription = &quot;Active&quot;,&#10;                tint = PrimaryCoral,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;&#10;        isLocked -&gt; {&#10;            Icon(&#10;                imageVector = Icons.Default.Lock,&#10;                contentDescription = &quot;Locked&quot;,&#10;                tint = TextSecondary,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;&#10;        else -&gt; {&#10;            Icon(&#10;                imageVector = Icons.Default.DateRange,&#10;                contentDescription = &quot;Ready&quot;,&#10;                tint = TealSecondary,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetInfoRow(&#10;    targetReps: Int,&#10;    repsPerformed: Int,&#10;    weightUsed: Float,&#10;    isCompleted: Boolean&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween&#10;    ) {&#10;        Text(&#10;            text = &quot;Target: $targetReps reps&quot;,&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                color = TextSecondary,&#10;                fontSize = 14.sp&#10;            )&#10;        )&#10;&#10;        // Display performance data when set is completed&#10;        if (isCompleted &amp;&amp; (repsPerformed &gt; 0 || weightUsed &gt; 0f)) {&#10;            Text(&#10;                text = buildString {&#10;                    if (repsPerformed &gt; 0) append(&quot;$repsPerformed reps&quot;)&#10;                    if (repsPerformed &gt; 0 &amp;&amp; weightUsed &gt; 0f) append(&quot; × &quot;)&#10;                    if (weightUsed &gt; 0f) append(&quot;${weightUsed}lbs&quot;)&#10;                },&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    color = PrimaryCoral,&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetActionButtons(&#10;    isCompleted: Boolean,&#10;    isLocked: Boolean,&#10;    isCurrentSet: Boolean,&#10;    repsPerformed: Int,&#10;    weightUsed: Float,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onEditSet: () -&gt; Unit,&#10;    onResetSet: (() -&gt; Unit)?, // New reset action&#10;    hapticFeedback: HapticFeedbackHelper&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        when {&#10;            isCompleted -&gt; {&#10;                SetCompletedState(&#10;                    repsPerformed = repsPerformed,&#10;                    weightUsed = weightUsed,&#10;                    onEditSet = onEditSet,&#10;                    hapticFeedback = hapticFeedback,&#10;                    onResetSet = onResetSet // Pass the reset callback&#10;                )&#10;            }&#10;&#10;            isLocked -&gt; {&#10;                Text(&#10;                    text = &quot;Complete previous sets first&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        color = TextSecondary,&#10;                        fontStyle = androidx.compose.ui.text.font.FontStyle.Italic&#10;                    ),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            isCurrentSet -&gt; {&#10;                Button(&#10;                    onClick = {&#10;                        hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.SUCCESS)&#10;                        onStopTimer()&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = SuccessGreen&#10;                    ),&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Check,&#10;                        contentDescription = &quot;Stop and Complete&quot;,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&quot;Complete Set&quot;)&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                Button(&#10;                    onClick = {&#10;                        hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.TIMER_START_STOP)&#10;                        onStartTimer()&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = PrimaryCoral&#10;                    ),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    enabled = !isLocked&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Start&quot;,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&quot;Start Set&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Reset button for incomplete sets&#10;        if (onResetSet != null &amp;&amp; !isCompleted) {&#10;            IconButton(&#10;                onClick = {&#10;                    hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.RESET)&#10;                    onResetSet()&#10;                },&#10;                modifier = Modifier.size(40.dp),&#10;                enabled = !isLocked&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.RestartAlt,&#10;                    contentDescription = &quot;Reset set&quot;,&#10;                    tint = PrimaryCoral,&#10;                    modifier = Modifier.size(20.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SetCompletedState(&#10;    repsPerformed: Int,&#10;    weightUsed: Float,&#10;    onEditSet: () -&gt; Unit,&#10;    hapticFeedback: HapticFeedbackHelper,&#10;    onResetSet: (() -&gt; Unit)? = null  // Add reset parameter&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.weight(1f),&#10;            verticalArrangement = Arrangement.spacedBy(4.dp)&#10;        ) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Check,&#10;                    contentDescription = &quot;Completed&quot;,&#10;                    tint = SuccessGreen,&#10;                    modifier = Modifier.size(16.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;                Text(&#10;                    text = &quot;Set Completed&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        color = SuccessGreen,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                )&#10;            }&#10;&#10;            // Detailed performance data display&#10;            if (repsPerformed &gt; 0 || weightUsed &gt; 0f) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 4.dp),&#10;                    horizontalArrangement = Arrangement.Start&#10;                ) {&#10;                    if (repsPerformed &gt; 0) {&#10;                        Text(&#10;                            text = &quot;Performed: $repsPerformed reps&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                    if (repsPerformed &gt; 0 &amp;&amp; weightUsed &gt; 0f) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    if (weightUsed &gt; 0f) {&#10;                        Text(&#10;                            text = &quot;Weight: ${weightUsed}lbs&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Row for action buttons&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            // Reset button for completed sets&#10;            if (onResetSet != null) {&#10;                IconButton(&#10;                    onClick = {&#10;                        hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.RESET)&#10;                        onResetSet()&#10;                    },&#10;                    modifier = Modifier.size(40.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.RestartAlt,&#10;                        contentDescription = &quot;Reset set&quot;,&#10;                        tint = PrimaryCoral,&#10;                        modifier = Modifier.size(20.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Edit button for completed sets&#10;            IconButton(&#10;                onClick = {&#10;                    hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.BUTTON_PRESS)&#10;                    onEditSet()&#10;                },&#10;                modifier = Modifier.size(40.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Edit,&#10;                    contentDescription = &quot;Edit set data&quot;,&#10;                    tint = PrimaryCoral,&#10;                    modifier = Modifier.size(20.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/navigation/AppNavigation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/navigation/AppNavigation.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.navigation&#10;&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.TrendingUp&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.History&#10;import androidx.compose.material.icons.filled.TrendingUp&#10;import androidx.compose.material.icons.outlined.Home&#10;import androidx.compose.material.icons.outlined.Settings&#10;import androidx.compose.material.icons.outlined.History&#10;import androidx.compose.material.icons.outlined.TrendingUp&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;&#10;/**&#10; * Represents the navigation destinations in the app&#10; */&#10;sealed class Screen(&#10;    val route: String,&#10;    val title: String,&#10;    val selectedIcon: ImageVector,&#10;    val unselectedIcon: ImageVector&#10;) {&#10;    object Home : Screen(&#10;        route = &quot;home&quot;,&#10;        title = &quot;Home&quot;,&#10;        selectedIcon = Icons.Filled.Home,&#10;        unselectedIcon = Icons.Outlined.Home&#10;    )&#10;&#10;    object History : Screen(&#10;        route = &quot;history&quot;,&#10;        title = &quot;History&quot;,&#10;        selectedIcon = Icons.Filled.History,&#10;        unselectedIcon = Icons.Outlined.History&#10;    )&#10;&#10;    object Performance : Screen(&#10;        route = &quot;performance&quot;,&#10;        title = &quot;Performance&quot;,&#10;        selectedIcon = Icons.AutoMirrored.Filled.TrendingUp,&#10;        unselectedIcon = Icons.Outlined.TrendingUp&#10;    )&#10;&#10;    object Settings : Screen(&#10;        route = &quot;settings&quot;,&#10;        title = &quot;Settings&quot;,&#10;        selectedIcon = Icons.Filled.Settings,&#10;        unselectedIcon = Icons.Outlined.Settings&#10;    )&#10;&#10;    companion object {&#10;        val bottomNavItems = listOf(Home, History, Performance, Settings)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.navigation&#10;&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.History&#10;import androidx.compose.material.icons.automirrored.filled.TrendingUp&#10;import androidx.compose.material.icons.outlined.Home&#10;import androidx.compose.material.icons.outlined.Settings&#10;import androidx.compose.material.icons.outlined.History&#10;import androidx.compose.material.icons.automirrored.outlined.TrendingUp&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;&#10;/**&#10; * Represents the navigation destinations in the app&#10; */&#10;sealed class Screen(&#10;    val route: String,&#10;    val title: String,&#10;    val selectedIcon: ImageVector,&#10;    val unselectedIcon: ImageVector&#10;) {&#10;    object Home : Screen(&#10;        route = &quot;home&quot;,&#10;        title = &quot;Home&quot;,&#10;        selectedIcon = Icons.Filled.Home,&#10;        unselectedIcon = Icons.Outlined.Home&#10;    )&#10;&#10;    object History : Screen(&#10;        route = &quot;history&quot;,&#10;        title = &quot;History&quot;,&#10;        selectedIcon = Icons.Filled.History,&#10;        unselectedIcon = Icons.Outlined.History&#10;    )&#10;&#10;    object Performance : Screen(&#10;        route = &quot;performance&quot;,&#10;        title = &quot;Performance&quot;,&#10;        selectedIcon = Icons.AutoMirrored.Filled.TrendingUp,&#10;        unselectedIcon = Icons.AutoMirrored.Outlined.TrendingUp&#10;    )&#10;&#10;    object Settings : Screen(&#10;        route = &quot;settings&quot;,&#10;        title = &quot;Settings&quot;,&#10;        selectedIcon = Icons.Filled.Settings,&#10;        unselectedIcon = Icons.Outlined.Settings&#10;    )&#10;&#10;    companion object {&#10;        val bottomNavItems = listOf(Home, History, Performance, Settings)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/AppNavigationContainer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/AppNavigationContainer.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.navigation.NavController&#10;import androidx.navigation.NavDestination.Companion.hierarchy&#10;import androidx.navigation.NavGraph.Companion.findStartDestination&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.offlinepplworkoutapp.R&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.navigation.Screen&#10;&#10;@Composable&#10;fun AppNavigationContainer(repository: WorkoutRepository) {&#10;    val navController = rememberNavController()&#10;    &#10;    Scaffold(&#10;        modifier = Modifier.fillMaxSize(),&#10;        bottomBar = {&#10;            NavigationBar(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ) {&#10;                val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;                val currentDestination = navBackStackEntry?.destination&#10;                &#10;                Screen.bottomNavItems.forEach { screen -&gt;&#10;                    val selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true&#10;                    &#10;                    NavigationBarItem(&#10;                        icon = { &#10;                            Icon(&#10;                                imageVector = if (selected) screen.selectedIcon else screen.unselectedIcon,&#10;                                contentDescription = screen.title&#10;                            ) &#10;                        },&#10;                        label = { Text(screen.title) },&#10;                        selected = selected,&#10;                        onClick = {&#10;                            navController.navigate(screen.route) {&#10;                                // Pop up to the start destination of the graph to avoid building&#10;                                // a large stack of destinations on the back stack&#10;                                popUpTo(navController.graph.findStartDestination().id) {&#10;                                    saveState = true&#10;                                }&#10;                                // Avoid multiple copies of the same destination when reselecting&#10;                                launchSingleTop = true&#10;                                // Restore state when reselecting a previously selected item&#10;                                restoreState = true&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = Screen.Home.route,&#10;            modifier = Modifier.padding(innerPadding)&#10;        ) {&#10;            composable(Screen.Home.route) {&#10;                HomeScreen(repository)&#10;            }&#10;            composable(Screen.History.route) {&#10;                HistoryScreen()&#10;            }&#10;            composable(Screen.Performance.route) {&#10;                PerformanceScreen()&#10;            }&#10;            composable(Screen.Settings.route) {&#10;                SettingsScreen()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.runtime.Composable&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;&#10;@Composable&#10;fun HomeScreen(repository: WorkoutRepository) {&#10;    // This simply wraps the existing MainScreen&#10;    MainScreen(repository = repository)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/MainScreenContent.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/MainScreenContent.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import com.example.offlinepplworkoutapp.R&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.components.DebugDaySelector&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModel&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;&#10;@Composable&#10;fun MainScreenContent(&#10;    viewModel: DailyWorkoutViewModel,&#10;    showDebugMenu: Boolean,&#10;    showResetConfirmation: Boolean,&#10;    showTemplateSelection: Boolean,&#10;    onShowDebugMenu: (Boolean) -&gt; Unit,&#10;    onShowResetConfirmation: (Boolean) -&gt; Unit,&#10;    onShowTemplateSelection: (Boolean) -&gt; Unit,&#10;    onNavigateToExerciseDetail: (WorkoutEntryWithExercise) -&gt; Unit,&#10;    repository: WorkoutRepository&#10;) {&#10;    val workoutEntries by viewModel.todaysWorkout.collectAsState(initial = emptyList())&#10;    val currentDate by viewModel.currentDate.collectAsState(initial = &quot;&quot;)&#10;    // Use a getter function for the workout type&#10;    val workoutType = viewModel.getWorkoutTypeName()&#10;    val isLoading by viewModel.isLoading.collectAsState(initial = false)&#10;    // Check if it's a rest day by comparing workout type&#10;    val isRestDay = workoutType == &quot;Rest Day&quot;&#10;    val coroutineScope = rememberCoroutineScope()&#10;    var selectedExercise by remember { mutableStateOf&lt;WorkoutEntryWithExercise?&gt;(null) }&#10;&#10;    LaunchedEffect(selectedExercise) {&#10;        if (selectedExercise != null) {&#10;            onNavigateToExerciseDetail(selectedExercise!!)&#10;        }&#10;    }&#10;&#10;    if (showDebugMenu) {&#10;        DebugDaySelector(&#10;            onDaySelected = { day -&gt;&#10;                viewModel.setDebugDate(day.toString())&#10;                onShowDebugMenu(false)&#10;            },&#10;            onDismiss = { onShowDebugMenu(false) },&#10;            onResetDatabase = {&#10;                onShowResetConfirmation(true)&#10;                onShowDebugMenu(false)&#10;            }&#10;        )&#10;    }&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Top bar with date and workout type&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.primaryContainer)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = currentDate,&#10;                    style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold),&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = workoutType,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;&#10;                // Show a &quot;Create Template&quot; button if no workout is available&#10;                if (workoutEntries.isEmpty() &amp;&amp; !isLoading &amp;&amp; !isRestDay) {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Button(&#10;                        onClick = { onShowTemplateSelection(true) }&#10;                    ) {&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Start&quot;&#10;                            )&#10;                            Text(&#10;                                text = &quot;Select Workout Template&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Content section with workout exercises or rest day message&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(8.dp),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            when {&#10;                isLoading -&gt; {&#10;                    CircularProgressIndicator()&#10;                }&#10;                isRestDay -&gt; {&#10;                    // Show rest day image and message&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.rest_day),&#10;                            contentDescription = &quot;Rest day&quot;,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentScale = ContentScale.Crop,&#10;                            alpha = 0.3f&#10;                        )&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .padding(16.dp)&#10;                                .align(Alignment.Center),&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)&#10;                            )&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier&#10;                                    .padding(24.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;REST DAY&quot;,&#10;                                    style = MaterialTheme.typography.headlineLarge.copy(&#10;                                        fontWeight = FontWeight.Bold&#10;                                    ),&#10;                                    color = MaterialTheme.colorScheme.primary&#10;                                )&#10;                                Spacer(modifier = Modifier.height(16.dp))&#10;                                Text(&#10;                                    text = &quot;Take time to recover and prepare for your next workout.&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge,&#10;                                    textAlign = TextAlign.Center&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                workoutEntries.isEmpty() -&gt; {&#10;                    // Show message when no workout is available (but it's not a rest day)&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        modifier = Modifier.padding(16.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;No workout available for today.&quot;,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Button(&#10;                            onClick = { onShowTemplateSelection(true) }&#10;                        ) {&#10;                            Text(text = &quot;Select a Workout Template&quot;)&#10;                        }&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    // Show workout exercises&#10;                    LazyColumn {&#10;                        items(workoutEntries) { entry -&gt;&#10;                            val secondsSpent = entry.totalSecondsSpent ?: 0&#10;                            val timeDisplay = when {&#10;                                secondsSpent &lt; 60 -&gt; &quot;${secondsSpent}s&quot;&#10;                                else -&gt; {&#10;                                    val minutes = secondsSpent / 60&#10;                                    val remainingSeconds = secondsSpent % 60&#10;                                    if (remainingSeconds == 0) &quot;${minutes}m&quot; else &quot;${minutes}m ${remainingSeconds}s&quot;&#10;                                }&#10;                            }&#10;&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(vertical = 4.dp)&#10;                                    .clickable {&#10;                                        selectedExercise = entry&#10;                                    },&#10;                                colors = CardDefaults.cardColors(&#10;                                    containerColor = if (entry.isCompleted)&#10;                                        MaterialTheme.colorScheme.secondaryContainer&#10;                                    else&#10;                                        MaterialTheme.colorScheme.surface&#10;                                )&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(16.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Column(modifier = Modifier.weight(1f)) {&#10;                                        Text(&#10;                                            text = entry.exerciseName,&#10;                                            style = MaterialTheme.typography.titleMedium,&#10;                                            color = if (entry.isCompleted)&#10;                                                MaterialTheme.colorScheme.onSecondaryContainer&#10;                                            else&#10;                                                MaterialTheme.colorScheme.onSurface&#10;                                        )&#10;                                        Text(&#10;                                            text = &quot;${entry.sets} sets × ${entry.reps} reps&quot;,&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            color = if (entry.isCompleted)&#10;                                                MaterialTheme.colorScheme.onSecondaryContainer&#10;                                            else&#10;                                                MaterialTheme.colorScheme.onSurfaceVariant&#10;                                        )&#10;&#10;                                        // Display time spent&#10;                                        if (entry.totalSecondsSpent &gt; 0) {&#10;                                            Text(&#10;                                                text = &quot;Time: $timeDisplay&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                color = if (entry.isCompleted)&#10;                                                    MaterialTheme.colorScheme.onSecondaryContainer&#10;                                                else&#10;                                                    MaterialTheme.colorScheme.onSurfaceVariant&#10;                                            )&#10;                                        }&#10;                                    }&#10;&#10;                                    if (entry.isCompleted) {&#10;                                        Text(&#10;                                            text = &quot;✓&quot;,&#10;                                            style = MaterialTheme.typography.titleLarge,&#10;                                            color = MaterialTheme.colorScheme.primary&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/NavigationScreens.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/NavigationScreens.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;&#10;@Composable&#10;fun HistoryScreen() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Workout History\n\nComing Soon in Phase 3.2&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PerformanceScreen() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Performance Analytics\n\nComing Soon in Phase 3.2.7&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SettingsScreen() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Settings\n\nComing Soon&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center,&#10;            color = MaterialTheme.colorScheme.primary&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/PlaceholderScreens.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/PlaceholderScreens.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;&#10;@Composable&#10;fun HistoryScreen(repository: WorkoutRepository) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize().padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Workout History\n\nComing Soon&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PerformanceScreen(repository: WorkoutRepository) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize().padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Performance Analytics\n\nComing Soon&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SettingsScreen() {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize().padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Settings\n\nComing Soon&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/TemplateSelectionScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/TemplateSelectionScreen.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModelFactory&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TemplateSelectionScreen(&#10;    repository: WorkoutRepository,&#10;    selectedDate: String,&#10;    onTemplateSelected: (WorkoutTemplate) -&gt; Unit,&#10;    onBackClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val viewModel: DailyWorkoutViewModel = viewModel(&#10;        factory = DailyWorkoutViewModelFactory(repository)&#10;    )&#10;&#10;    val availableTemplates by viewModel.availableTemplates.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;&#10;    // Load templates when screen opens&#10;    LaunchedEffect(Unit) {&#10;        // Load templates using the public method - since loadAvailableTemplates() is private,&#10;        // the templates should already be loaded in the ViewModel init&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Choose Your Workout&quot;,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface,&#10;                    titleContentColor = MaterialTheme.colorScheme.onSurface&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Date display&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = &quot;Workout for $selectedDate&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp)&#10;                )&#10;            }&#10;&#10;            if (isLoading) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            } else if (availableTemplates.isEmpty()) {&#10;                EmptyTemplateState()&#10;            } else {&#10;                LazyColumn(&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    item {&#10;                        Text(&#10;                            text = &quot;Available Workout Templates&quot;,&#10;                            style = MaterialTheme.typography.titleLarge,&#10;                            fontWeight = FontWeight.Bold,&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;&#10;                    items(availableTemplates) { template -&gt;&#10;                        TemplateCard(&#10;                            template = template,&#10;                            onClick = { onTemplateSelected(template) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TemplateCard(&#10;    template: WorkoutTemplate,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() },&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Template header&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = template.name,&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;&#10;                    Text(&#10;                        text = template.category,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        color = getCategoryColor(template.category),&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;&#10;                // Difficulty indicator&#10;                DifficultyChip(difficulty = template.difficulty)&#10;            }&#10;&#10;            // Template description&#10;            if (template.description.isNotBlank()) {&#10;                Text(&#10;                    text = template.description,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;&#10;            // Template metadata&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(top = 12.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                // Estimated duration (using a default value since estimatedDurationMinutes doesn't exist)&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Duration&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;45-60 min&quot;, // Default estimated duration&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(start = 4.dp)&#10;                    )&#10;                }&#10;&#10;                // Exercise count&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Star,&#10;                        contentDescription = &quot;Exercises&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;6 exercises&quot;, // Default exercise count&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(start = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Last used info&#10;            if (template.lastUsedDate != null) {&#10;                Text(&#10;                    text = &quot;Last used: ${template.lastUsedDate}&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DifficultyChip(&#10;    difficulty: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val (color, text) = when (difficulty.lowercase()) {&#10;        &quot;beginner&quot; -&gt; Pair(Color(0xFF4CAF50), &quot;Beginner&quot;)&#10;        &quot;intermediate&quot; -&gt; Pair(Color(0xFFFF9800), &quot;Intermediate&quot;)&#10;        &quot;advanced&quot; -&gt; Pair(Color(0xFFF44336), &quot;Advanced&quot;)&#10;        else -&gt; Pair(MaterialTheme.colorScheme.primary, difficulty)&#10;    }&#10;&#10;    Surface(&#10;        modifier = modifier,&#10;        color = color.copy(alpha = 0.1f),&#10;        shape = MaterialTheme.shapes.small&#10;    ) {&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Star,&#10;                contentDescription = &quot;Difficulty&quot;,&#10;                tint = color,&#10;                modifier = Modifier.size(12.dp)&#10;            )&#10;            Text(&#10;                text = text,&#10;                style = MaterialTheme.typography.labelSmall,&#10;                color = color,&#10;                fontWeight = FontWeight.Medium,&#10;                modifier = Modifier.padding(start = 4.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmptyTemplateState() {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Star,&#10;            contentDescription = &quot;No Templates&quot;,&#10;            tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.size(64.dp)&#10;        )&#10;&#10;        Text(&#10;            text = &quot;No Templates Available&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.padding(top = 16.dp)&#10;        )&#10;&#10;        Text(&#10;            text = &quot;Templates are being loaded. Please wait...&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(vertical = 8.dp, horizontal = 32.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun getCategoryColor(category: String): Color {&#10;    return when (category.lowercase()) {&#10;        &quot;push&quot; -&gt; Color(0xFFE57373) // Light red&#10;        &quot;pull&quot; -&gt; Color(0xFF64B5F6) // Light blue&#10;        &quot;legs&quot; -&gt; Color(0xFF81C784) // Light green&#10;        else -&gt; MaterialTheme.colorScheme.primary&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModelFactory&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TemplateSelectionScreen(&#10;    repository: WorkoutRepository,&#10;    selectedDate: String,&#10;    onTemplateSelected: (WorkoutTemplate) -&gt; Unit,&#10;    onBackClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val viewModel: DailyWorkoutViewModel = viewModel(&#10;        factory = DailyWorkoutViewModelFactory(repository)&#10;    )&#10;&#10;    val availableTemplates by viewModel.availableTemplates.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;&#10;    // Load templates when screen opens&#10;    LaunchedEffect(Unit) {&#10;        // Load templates using the public method - since loadAvailableTemplates() is private,&#10;        // the templates should already be loaded in the ViewModel init&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Choose Your Workout&quot;,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface,&#10;                    titleContentColor = MaterialTheme.colorScheme.onSurface&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Date display&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = &quot;Workout for $selectedDate&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp)&#10;                )&#10;            }&#10;&#10;            if (isLoading) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            } else if (availableTemplates.isEmpty()) {&#10;                EmptyTemplateState()&#10;            } else {&#10;                LazyColumn(&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    item {&#10;                        Text(&#10;                            text = &quot;Available Workout Templates&quot;,&#10;                            style = MaterialTheme.typography.titleLarge,&#10;                            fontWeight = FontWeight.Bold,&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;&#10;                    items(availableTemplates) { template -&gt;&#10;                        TemplateCard(&#10;                            template = template,&#10;                            onClick = { onTemplateSelected(template) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TemplateCard(&#10;    template: WorkoutTemplate,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() },&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Template header&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = template.name,&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;&#10;                    Text(&#10;                        text = template.category,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        color = getCategoryColor(template.category),&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;&#10;                // Difficulty indicator&#10;                DifficultyChip(difficulty = template.difficulty)&#10;            }&#10;&#10;            // Template description&#10;            if (template.description.isNotBlank()) {&#10;                Text(&#10;                    text = template.description,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;&#10;            // Template metadata&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(top = 12.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                // Estimated duration (using a default value since estimatedDurationMinutes doesn't exist)&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Duration&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;45-60 min&quot;, // Default estimated duration&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(start = 4.dp)&#10;                    )&#10;                }&#10;&#10;                // Exercise count&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Star,&#10;                        contentDescription = &quot;Exercises&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;6 exercises&quot;, // Default exercise count&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(start = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Last used info&#10;            if (template.lastUsedDate.isNotEmpty()) {&#10;                Text(&#10;                    text = &quot;Last used: ${template.lastUsedDate}&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DifficultyChip(&#10;    difficulty: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val (color, text) = when (difficulty.lowercase()) {&#10;        &quot;beginner&quot; -&gt; Pair(Color(0xFF4CAF50), &quot;Beginner&quot;)&#10;        &quot;intermediate&quot; -&gt; Pair(Color(0xFFFF9800), &quot;Intermediate&quot;)&#10;        &quot;advanced&quot; -&gt; Pair(Color(0xFFF44336), &quot;Advanced&quot;)&#10;        else -&gt; Pair(MaterialTheme.colorScheme.primary, difficulty)&#10;    }&#10;&#10;    Surface(&#10;        modifier = modifier,&#10;        color = color.copy(alpha = 0.1f),&#10;        shape = MaterialTheme.shapes.small&#10;    ) {&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Star,&#10;                contentDescription = &quot;Difficulty&quot;,&#10;                tint = color,&#10;                modifier = Modifier.size(12.dp)&#10;            )&#10;            Text(&#10;                text = text,&#10;                style = MaterialTheme.typography.labelSmall,&#10;                color = color,&#10;                fontWeight = FontWeight.Medium,&#10;                modifier = Modifier.padding(start = 4.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmptyTemplateState() {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Star,&#10;            contentDescription = &quot;No Templates&quot;,&#10;            tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.size(64.dp)&#10;        )&#10;&#10;        Text(&#10;            text = &quot;No Templates Available&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.padding(top = 16.dp)&#10;        )&#10;&#10;        Text(&#10;            text = &quot;Templates are being loaded. Please wait...&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(vertical = 8.dp, horizontal = 32.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun getCategoryColor(category: String): Color {&#10;    return when (category.lowercase()) {&#10;        &quot;push&quot; -&gt; Color(0xFFE57373) // Light red&#10;        &quot;pull&quot; -&gt; Color(0xFF64B5F6) // Light blue&#10;        &quot;legs&quot; -&gt; Color(0xFF81C784) // Light green&#10;        else -&gt; MaterialTheme.colorScheme.primary&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/exercisedetails/ExerciseDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/exercisedetails/ExerciseDetailScreen.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.screens.exercisedetails&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.components.SetDataEntryDialog&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.AddSetButton&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.ExerciseCompletionCard&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.ExerciseDetailHeader&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.RestTimerCard&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.SetTimerCard&#10;import com.example.offlinepplworkoutapp.ui.theme.BackgroundLight&#10;import com.example.offlinepplworkoutapp.utils.ExerciseDetailUtils.formatTime&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModelFactory&#10;import com.example.offlinepplworkoutapp.utils.HapticFeedbackHelper&#10;import com.example.offlinepplworkoutapp.utils.NotificationHelper&#10;import com.example.offlinepplworkoutapp.utils.rememberHapticFeedback&#10;&#10;@Composable&#10;fun ExerciseDetailScreen(&#10;    workoutEntry: WorkoutEntryWithExercise,&#10;    repository: WorkoutRepository,&#10;    onBackClick: () -&gt; Unit,&#10;    onSaveChanges: (sets: Int, reps: Int, isCompleted: Boolean) -&gt; Unit&#10;) {&#10;    // ViewModel setup with unique key for each exercise&#10;    val viewModel: ExerciseDetailViewModel = viewModel(&#10;        key = &quot;exercise_${workoutEntry.id}&quot;,&#10;        factory = ExerciseDetailViewModelFactory(workoutEntry, repository)&#10;    )&#10;&#10;    // Collect state from ViewModel&#10;    val setTimers by viewModel.setTimers.collectAsState()&#10;    val currentRunningSet by viewModel.currentRunningSet.collectAsState()&#10;    val totalExerciseTime by viewModel.totalExerciseTime.collectAsState()&#10;    val completedSets by viewModel.completedSets.collectAsState()&#10;    val isExerciseCompleted by viewModel.isExerciseCompleted.collectAsState()&#10;    val restTimer by viewModel.restTimer.collectAsState()&#10;    val isRestActive by viewModel.isRestActive.collectAsState()&#10;    val restMinuteMilestoneReached by viewModel.restMinuteMilestoneReached.collectAsState()&#10;    val showSetDataDialog by viewModel.showSetDataDialog.collectAsState()&#10;    val pendingSetData by viewModel.pendingSetData.collectAsState()&#10;&#10;    // Setup notifications and haptic feedback&#10;    val context = LocalContext.current&#10;    val notificationHelper = remember { NotificationHelper(context) }&#10;    val hapticFeedback = rememberHapticFeedback()&#10;    val originalCompletionStatus = remember { workoutEntry.isCompleted }&#10;&#10;    // Handle rest timer milestone notifications&#10;    LaunchedEffect(restMinuteMilestoneReached) @androidx.annotation.RequiresPermission(android.Manifest.permission.VIBRATE) {&#10;        if (restMinuteMilestoneReached &amp;&amp; isRestActive) {&#10;            notificationHelper.showRestTimerNotification(workoutEntry.exerciseName)&#10;            hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.SUCCESS)&#10;        }&#10;    }&#10;&#10;    // Cancel notifications when rest timer stops&#10;    LaunchedEffect(isRestActive) {&#10;        if (!isRestActive) {&#10;            notificationHelper.cancelRestTimerNotification()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            ExerciseDetailHeader(&#10;                exerciseName = workoutEntry.exerciseName,&#10;                completedSets = completedSets,&#10;                totalSets = setTimers.size,&#10;                totalTime = totalExerciseTime,&#10;                onBackClick = {&#10;                    val shouldMarkCompleted =&#10;                        isExerciseCompleted &amp;&amp; completedSets == workoutEntry.sets&#10;                    if (shouldMarkCompleted != originalCompletionStatus) {&#10;                        onSaveChanges(workoutEntry.sets, workoutEntry.reps, shouldMarkCompleted)&#10;                    }&#10;                    onBackClick()&#10;                }&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(BackgroundLight)&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Rest timer display&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isRestActive,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    RestTimerCard(&#10;                        restTime = restTimer / 1000,&#10;                        isActive = isRestActive&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Exercise completion status&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isExerciseCompleted,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    ExerciseCompletionCard()&#10;                }&#10;            }&#10;&#10;            // Set timer cards&#10;            itemsIndexed(setTimers) { index, setTimer -&gt;&#10;                val activeSetIndex by viewModel.activeSetIndex.collectAsState()&#10;                val setData by viewModel.getSetData(index).collectAsState(initial = null)&#10;&#10;                SetTimerCard(&#10;                    setNumber = index + 1,&#10;                    totalSets = setTimers.size,&#10;                    targetReps = workoutEntry.reps,&#10;                    setTimer = setTimer.elapsedTime / 1000,&#10;                    isCurrentSet = currentRunningSet == index,&#10;                    isCompleted = setTimer.isCompleted,&#10;                    isActive = index == activeSetIndex,&#10;                    isLocked = index &gt; activeSetIndex &amp;&amp; !setTimer.isCompleted,&#10;                    repsPerformed = setData?.repsPerformed ?: 0,&#10;                    weightUsed = setData?.weightUsed ?: 0f,&#10;                    onStartTimer = { viewModel.startSetTimer(index) },&#10;                    onStopTimer = { viewModel.stopSetTimer(index) },&#10;                    onEditSet = { viewModel.editSetData(index) },&#10;                    onDeleteSet = if (!setTimer.isCompleted &amp;&amp; setTimers.size &gt; 1) {&#10;                        { viewModel.removeSpecificSet(index) }&#10;                    } else null&#10;                )&#10;            }&#10;&#10;            // Add set button&#10;            item {&#10;                val canAddSet = setTimers.size &lt; 8&#10;                if (canAddSet) {&#10;                    AddSetButton(&#10;                        onAddSet = { viewModel.addSetWithReps() },&#10;                        canAddSet = canAddSet&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Set data entry dialog&#10;    if (showSetDataDialog) {&#10;        pendingSetData?.let { (setIndex, _) -&gt;&#10;            val setData by viewModel.getSetData(setIndex).collectAsState(initial = null)&#10;            val currentSetData = setData&#10;            val isEditMode = currentSetData != null &amp;&amp; currentSetData.isCompleted&#10;&#10;            SetDataEntryDialog(&#10;                setNumber = setIndex + 1,&#10;                exerciseName = workoutEntry.exerciseName,&#10;                onDataEntered = { performanceData -&gt;&#10;                    viewModel.submitSetPerformanceData(&#10;                        repsPerformed = performanceData.repsPerformed,&#10;                        weightUsed = performanceData.weightUsed&#10;                    )&#10;                },&#10;                onCancel = if (isEditMode) {&#10;                    { viewModel.dismissSetDataDialog() }&#10;                } else null,&#10;                isRestTimerRunning = isRestActive &amp;&amp; !isEditMode,&#10;                restTimeFormatted = formatTime(restTimer / 1000),&#10;                isEditMode = isEditMode,&#10;                initialReps = currentSetData?.repsPerformed ?: 0,&#10;                initialWeight = currentSetData?.weightUsed ?: 0f&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens.exercisedetails&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.components.SetDataEntryDialog&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.AddSetButton&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.ExerciseCompletionCard&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.ExerciseDetailHeader&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.RestTimerCard&#10;import com.example.offlinepplworkoutapp.ui.components.exercise.SetTimerCard&#10;import com.example.offlinepplworkoutapp.ui.theme.BackgroundLight&#10;import com.example.offlinepplworkoutapp.utils.ExerciseDetailUtils.formatTime&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModelFactory&#10;import com.example.offlinepplworkoutapp.utils.HapticFeedbackHelper&#10;import com.example.offlinepplworkoutapp.utils.NotificationHelper&#10;import com.example.offlinepplworkoutapp.utils.rememberHapticFeedback&#10;&#10;@Composable&#10;fun ExerciseDetailScreen(&#10;    workoutEntry: WorkoutEntryWithExercise,&#10;    repository: WorkoutRepository,&#10;    onBackClick: () -&gt; Unit,&#10;    onSaveChanges: (sets: Int, reps: Int, isCompleted: Boolean) -&gt; Unit&#10;) {&#10;    // ViewModel setup with unique key for each exercise&#10;    val viewModel: ExerciseDetailViewModel = viewModel(&#10;        key = &quot;exercise_${workoutEntry.id}&quot;,&#10;        factory = ExerciseDetailViewModelFactory(workoutEntry, repository)&#10;    )&#10;&#10;    // Collect state from ViewModel&#10;    val setTimers by viewModel.setTimers.collectAsState()&#10;    val currentRunningSet by viewModel.currentRunningSet.collectAsState()&#10;    val totalExerciseTime by viewModel.totalExerciseTime.collectAsState()&#10;    val completedSets by viewModel.completedSets.collectAsState()&#10;    val isExerciseCompleted by viewModel.isExerciseCompleted.collectAsState()&#10;    val restTimer by viewModel.restTimer.collectAsState()&#10;    val isRestActive by viewModel.isRestActive.collectAsState()&#10;    val restMinuteMilestoneReached by viewModel.restMinuteMilestoneReached.collectAsState()&#10;    val showSetDataDialog by viewModel.showSetDataDialog.collectAsState()&#10;    val pendingSetData by viewModel.pendingSetData.collectAsState()&#10;&#10;    // Setup notifications and haptic feedback&#10;    val context = LocalContext.current&#10;    val notificationHelper = remember { NotificationHelper(context) }&#10;    val hapticFeedback = rememberHapticFeedback()&#10;    val originalCompletionStatus = remember { workoutEntry.isCompleted }&#10;&#10;    // Handle rest timer milestone notifications&#10;    LaunchedEffect(restMinuteMilestoneReached) @androidx.annotation.RequiresPermission(android.Manifest.permission.VIBRATE) {&#10;        if (restMinuteMilestoneReached &amp;&amp; isRestActive) {&#10;            notificationHelper.showRestTimerNotification(workoutEntry.exerciseName)&#10;            hapticFeedback.performHapticFeedback(HapticFeedbackHelper.FeedbackType.SUCCESS)&#10;        }&#10;    }&#10;&#10;    // Cancel notifications when rest timer stops&#10;    LaunchedEffect(isRestActive) {&#10;        if (!isRestActive) {&#10;            notificationHelper.cancelRestTimerNotification()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            ExerciseDetailHeader(&#10;                exerciseName = workoutEntry.exerciseName,&#10;                completedSets = completedSets,&#10;                totalSets = setTimers.size,&#10;                totalTime = totalExerciseTime,&#10;                onBackClick = {&#10;                    val shouldMarkCompleted =&#10;                        isExerciseCompleted &amp;&amp; completedSets == workoutEntry.sets&#10;                    if (shouldMarkCompleted != originalCompletionStatus) {&#10;                        onSaveChanges(workoutEntry.sets, workoutEntry.reps, shouldMarkCompleted)&#10;                    }&#10;                    onBackClick()&#10;                }&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(BackgroundLight)&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Rest timer display&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isRestActive,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    RestTimerCard(&#10;                        restTime = restTimer / 1000,&#10;                        isActive = isRestActive&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Exercise completion status&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isExerciseCompleted,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    ExerciseCompletionCard()&#10;                }&#10;            }&#10;&#10;            // Set timer cards&#10;            itemsIndexed(setTimers) { index, setTimer -&gt;&#10;                val activeSetIndex by viewModel.activeSetIndex.collectAsState()&#10;                val setData by viewModel.getSetData(index).collectAsState(initial = null)&#10;&#10;                SetTimerCard(&#10;                    setNumber = index + 1,&#10;                    totalSets = setTimers.size,&#10;                    targetReps = workoutEntry.reps,&#10;                    setTimer = setTimer.elapsedTime / 1000,&#10;                    isCurrentSet = currentRunningSet == index,&#10;                    isCompleted = setTimer.isCompleted,&#10;                    isActive = index == activeSetIndex,&#10;                    isLocked = index &gt; activeSetIndex &amp;&amp; !setTimer.isCompleted,&#10;                    repsPerformed = setData?.repsPerformed ?: 0,&#10;                    weightUsed = setData?.weightUsed ?: 0f,&#10;                    onStartTimer = { viewModel.startSetTimer(index) },&#10;                    onStopTimer = { viewModel.stopSetTimer(index) },&#10;                    onEditSet = { viewModel.editSetData(index) },&#10;                    onDeleteSet = if (!setTimer.isCompleted &amp;&amp; setTimers.size &gt; 1) {&#10;                        { viewModel.removeSpecificSet(index) }&#10;                    } else null,&#10;                    onResetSet = if (setTimer.isCompleted) {&#10;                        { viewModel.resetSet(index) }&#10;                    } else null&#10;                )&#10;            }&#10;&#10;            // Add set button&#10;            item {&#10;                val canAddSet = setTimers.size &lt; 8&#10;                if (canAddSet) {&#10;                    AddSetButton(&#10;                        onAddSet = { viewModel.addSetWithReps() },&#10;                        canAddSet = canAddSet&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Set data entry dialog&#10;    if (showSetDataDialog) {&#10;        pendingSetData?.let { (setIndex, _) -&gt;&#10;            val setData by viewModel.getSetData(setIndex).collectAsState(initial = null)&#10;            val currentSetData = setData&#10;            val isEditMode = currentSetData != null &amp;&amp; currentSetData.isCompleted&#10;&#10;            SetDataEntryDialog(&#10;                setNumber = setIndex + 1,&#10;                exerciseName = workoutEntry.exerciseName,&#10;                onDataEntered = { performanceData -&gt;&#10;                    viewModel.submitSetPerformanceData(&#10;                        repsPerformed = performanceData.repsPerformed,&#10;                        weightUsed = performanceData.weightUsed&#10;                    )&#10;                },&#10;                onCancel = if (isEditMode) {&#10;                    { viewModel.dismissSetDataDialog() }&#10;                } else null,&#10;                isRestTimerRunning = isRestActive &amp;&amp; !isEditMode,&#10;                restTimeFormatted = formatTime(restTimer / 1000),&#10;                isEditMode = isEditMode,&#10;                initialReps = currentSetData?.repsPerformed ?: 0,&#10;                initialWeight = currentSetData?.weightUsed ?: 0f&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/viewmodel/ExerciseDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/viewmodel/ExerciseDetailViewModel.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class SetTimer(&#10;    val setNumber: Int,&#10;    val elapsedTime: Long = 0L,&#10;    val isRunning: Boolean = false,&#10;    val isCompleted: Boolean = false,&#10;    val startTime: Long = 0L&#10;)&#10;&#10;class ExerciseDetailViewModel(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModel() {&#10;&#10;    // Load actual sets from database instead of creating in memory&#10;    private val _setTimers = MutableStateFlow&lt;List&lt;SetTimer&gt;&gt;(emptyList())&#10;    val setTimers: StateFlow&lt;List&lt;SetTimer&gt;&gt; = _setTimers.asStateFlow()&#10;&#10;    private val _currentRunningSet = MutableStateFlow&lt;Int?&gt;(null)&#10;    val currentRunningSet: StateFlow&lt;Int?&gt; = _currentRunningSet.asStateFlow()&#10;&#10;    private val _activeSetIndex = MutableStateFlow&lt;Int&gt;(0)&#10;    val activeSetIndex: StateFlow&lt;Int&gt; = _activeSetIndex.asStateFlow()&#10;&#10;    private val _totalExerciseTime = MutableStateFlow(0L)&#10;    val totalExerciseTime: StateFlow&lt;Long&gt; = _totalExerciseTime.asStateFlow()&#10;&#10;    private val _completedSets = MutableStateFlow(0)&#10;    val completedSets: StateFlow&lt;Int&gt; = _completedSets.asStateFlow()&#10;&#10;    private val _isExerciseCompleted = MutableStateFlow(false)&#10;    val isExerciseCompleted: StateFlow&lt;Boolean&gt; = _isExerciseCompleted.asStateFlow()&#10;&#10;    //  FIXED: Enhanced rest timer functionality with proper time tracking&#10;    private val _restTimer = MutableStateFlow(0L)&#10;    val restTimer: StateFlow&lt;Long&gt; = _restTimer.asStateFlow()&#10;&#10;    private val _isRestActive = MutableStateFlow(false)&#10;    val isRestActive: StateFlow&lt;Boolean&gt; = _isRestActive.asStateFlow()&#10;&#10;    //  NEW: Track accumulated rest time for total exercise time calculation&#10;    private val _totalRestTime = MutableStateFlow(0L)&#10;    val totalRestTime: StateFlow&lt;Long&gt; = _totalRestTime.asStateFlow()&#10;&#10;    //  NEW: Phase 2.1.2 - Set data entry dialog state&#10;    private val _showSetDataDialog = MutableStateFlow(false)&#10;    val showSetDataDialog: StateFlow&lt;Boolean&gt; = _showSetDataDialog.asStateFlow()&#10;&#10;    private val _pendingSetData = MutableStateFlow&lt;Pair&lt;Int, Int&gt;?&gt;(null) // (setIndex, setId)&#10;    val pendingSetData: StateFlow&lt;Pair&lt;Int, Int&gt;?&gt; = _pendingSetData.asStateFlow()&#10;&#10;    //  NEW: State flow to signal when 1-minute rest milestone is reached&#10;    private val _restMinuteMilestoneReached = MutableStateFlow(false)&#10;    val restMinuteMilestoneReached: StateFlow&lt;Boolean&gt; = _restMinuteMilestoneReached.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var restTimerJob: Job? = null&#10;    private var currentSetId: Int? = null&#10;&#10;    init {&#10;        loadSetsFromDatabase()&#10;    }&#10;&#10;    private fun loadSetsFromDatabase() {&#10;        viewModelScope.launch {&#10;            println(&quot; DETAIL VM: Loading sets for workout entry ID: ${workoutEntry.id}&quot;)&#10;            println(&quot; DETAIL VM: Exercise: '${workoutEntry.exerciseName}' (Exercise ID: ${workoutEntry.exerciseId})&quot;)&#10;&#10;            // First, ensure sets exist in database&#10;            val existingSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            println(&quot; DETAIL VM: Found ${existingSets.size} existing sets in database&quot;)&#10;&#10;            if (existingSets.isEmpty()) {&#10;                println(&quot; DETAIL VM: No sets found, creating ${workoutEntry.sets} sets&quot;)&#10;                // Create sets in database if they don't exist&#10;                repository.createSetsForWorkoutEntry(workoutEntry.id, workoutEntry.sets)&#10;                println(&quot; DETAIL VM: Sets created, reloading...&quot;)&#10;            } else {&#10;                println(&quot; DETAIL VM: Sets already exist:&quot;)&#10;                existingSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;            }&#10;&#10;            // Now load sets from database and observe changes&#10;            repository.getSetsForWorkoutEntry(workoutEntry.id).collect { dbSets -&gt;&#10;                println(&quot; DETAIL VM: Received ${dbSets.size} sets from Flow for WorkoutEntry ID: ${workoutEntry.id}&quot;)&#10;                dbSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Flow Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s, repsPerformed=${set.repsPerformed}&quot;)&#10;                }&#10;&#10;                val setTimers = dbSets.map { setEntry -&gt;&#10;                    SetTimer(&#10;                        setNumber = setEntry.setNumber,&#10;                        elapsedTime = (setEntry.elapsedTimeSeconds * 1000).toLong(),&#10;                        isRunning = false, // Never restore running state from DB&#10;                        isCompleted = setEntry.isCompleted,&#10;                        startTime = 0L&#10;                    )&#10;                }&#10;&#10;                println(&quot; DETAIL VM: Created ${setTimers.size} SetTimer objects for '${workoutEntry.exerciseName}'&quot;)&#10;                _setTimers.value = setTimers&#10;                _completedSets.value = dbSets.count { it.isCompleted }&#10;                _isExerciseCompleted.value = dbSets.all { it.isCompleted } &amp;&amp; dbSets.isNotEmpty()&#10;&#10;                //  FIX: Set the active set index to the first incomplete set&#10;                val firstIncompleteSetIndex = setTimers.indexOfFirst { !it.isCompleted }&#10;                _activeSetIndex.value =&#10;                    if (firstIncompleteSetIndex != -1) firstIncompleteSetIndex else 0&#10;                println(&quot; DETAIL VM: Set active set index to: ${_activeSetIndex.value}&quot;)&#10;&#10;                updateTotalExerciseTime()&#10;&#10;                println(&quot; DETAIL VM: State updated for '${workoutEntry.exerciseName}' - completedSets: ${_completedSets.value}, isCompleted: ${_isExerciseCompleted.value}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startSetTimer(setIndex: Int) {&#10;        println(&quot; REST DEBUG: startSetTimer called for set ${setIndex + 1}&quot;)&#10;&#10;        // Stop any currently running timer&#10;        stopAllTimers()&#10;&#10;        //  NEW: Stop rest timer when starting a new set&#10;        println(&quot; REST DEBUG: Stopping rest timer before starting new set&quot;)&#10;        stopRestTimer()&#10;&#10;        // Start timer for this set&#10;        val currentTime = System.currentTimeMillis()&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        updatedTimers[setIndex] = updatedTimers[setIndex].copy(&#10;            isRunning = true,&#10;            startTime = currentTime&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = setIndex&#10;&#10;        println(&quot; REST DEBUG: Set ${setIndex + 1} timer started at $currentTime&quot;)&#10;&#10;        // Store the database set ID for persistence&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            currentSetId = dbSets.getOrNull(setIndex)?.id&#10;        }&#10;&#10;        // Start the timer coroutine&#10;        timerJob = viewModelScope.launch {&#10;            while (_setTimers.value.getOrNull(setIndex)?.isRunning == true) {&#10;                delay(1000) // Update every second&#10;                updateTimerForSet(setIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopSetTimer(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        if (timer.isRunning) {&#10;            //  FIXED: Use current elapsed time directly, don't double-count&#10;            val finalElapsedTime = System.currentTimeMillis() - timer.startTime&#10;&#10;            println(&quot; STOP TIMER DEBUG: Set ${setIndex + 1}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: timer.elapsedTime = ${timer.elapsedTime}ms&quot;)&#10;            println(&quot; STOP TIMER DEBUG: startTime = ${timer.startTime}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: currentTime = ${System.currentTimeMillis()}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: calculated elapsed = ${finalElapsedTime}ms (${finalElapsedTime / 1000}s)&quot;)&#10;&#10;            updatedTimers[setIndex] = timer.copy(&#10;                isRunning = false,&#10;                elapsedTime = finalElapsedTime&#10;                //  CHANGED: Don't mark as completed here - wait for user data entry&#10;            )&#10;            _setTimers.value = updatedTimers&#10;            _currentRunningSet.value = null&#10;            timerJob?.cancel()&#10;&#10;            //  NEW: Phase 2.1.2 - Show data entry dialog instead of immediate completion&#10;            currentSetId?.let { setId -&gt;&#10;                println(&quot; DIALOG: Showing set data entry dialog for set ${setIndex + 1}&quot;)&#10;                _pendingSetData.value = Pair(setIndex, setId)&#10;                _showSetDataDialog.value = true&#10;&#10;                //  IMPORTANT: Start rest timer while user enters data&#10;                startRestTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Handle set performance data submission&#10;    fun submitSetPerformanceData(repsPerformed: Int, weightUsed: Float) {&#10;        val pendingData = _pendingSetData.value ?: return&#10;        val (setIndex, setId) = pendingData&#10;&#10;        println(&quot; DIALOG: Submitting performance data - Set ${setIndex + 1}, Reps: $repsPerformed, Weight: $weightUsed&quot;)&#10;&#10;        viewModelScope.launch {&#10;            // Get the timer data for this set&#10;            val timer = _setTimers.value.getOrNull(setIndex)&#10;            val elapsedTimeSeconds = ((timer?.elapsedTime ?: 0L) / 1000).toInt()&#10;&#10;            // Update database with completion and performance data&#10;            repository.updateSetProgressWithPerformanceData(&#10;                setId = setId,&#10;                isCompleted = true,&#10;                elapsedTimeSeconds = elapsedTimeSeconds,&#10;                repsPerformed = repsPerformed,&#10;                weightUsed = weightUsed&#10;            )&#10;&#10;            // Update local state to mark set as completed&#10;            val updatedTimers = _setTimers.value.toMutableList()&#10;            updatedTimers[setIndex] = updatedTimers[setIndex].copy(isCompleted = true)&#10;            _setTimers.value = updatedTimers&#10;&#10;            // Update exercise completion status&#10;            repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;&#10;            // Update local completed sets count&#10;            val completedCount = _setTimers.value.count { it.isCompleted }&#10;            _completedSets.value = completedCount&#10;&#10;            // Check if all sets are completed&#10;            if (completedCount == workoutEntry.sets) {&#10;                _isExerciseCompleted.value = true&#10;                // Stop rest timer if all sets are completed&#10;                stopRestTimer()&#10;            } else {&#10;                // Advance to next set - find the first incomplete set&#10;                val nextIncompleteSetIndex = _setTimers.value.indexOfFirst { !it.isCompleted }&#10;                if (nextIncompleteSetIndex != -1) {&#10;                    _activeSetIndex.value = nextIncompleteSetIndex&#10;                    println(&quot; DETAIL VM: Advanced to next set index: $nextIncompleteSetIndex&quot;)&#10;                }&#10;            }&#10;&#10;            // Update total time calculation&#10;            updateTotalExerciseTime()&#10;&#10;            // Hide dialog and clear pending data&#10;            _showSetDataDialog.value = false&#10;            _pendingSetData.value = null&#10;&#10;            println(&quot; DIALOG: Set performance data saved successfully&quot;)&#10;        }&#10;    }&#10;&#10;    //  NEW: 2.2.1 - Edit set data functionality&#10;    fun editSetData(setIndex: Int) {&#10;        println(&quot; EDIT: editSetData called for set ${setIndex + 1}&quot;)&#10;&#10;        viewModelScope.launch {&#10;            val sets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            val setToEdit = sets.getOrNull(setIndex)&#10;&#10;            if (setToEdit != null &amp;&amp; setToEdit.isCompleted) {&#10;                println(&quot; EDIT: Opening edit dialog for completed set ${setIndex + 1}&quot;)&#10;                _pendingSetData.value = Pair(setIndex, setToEdit.id)&#10;                _showSetDataDialog.value = true&#10;            } else {&#10;                println(&quot; EDIT: Cannot edit set ${setIndex + 1} - not completed or not found&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Enhanced dialog state management for editing&#10;    fun dismissSetDataDialog() {&#10;        println(&quot; DIALOG: Dismissing set data dialog&quot;)&#10;        _showSetDataDialog.value = false&#10;        _pendingSetData.value = null&#10;    }&#10;&#10;    // Get set data for UI display&#10;    fun getSetData(setIndex: Int) = repository.getSetByIndex(workoutEntry.id, setIndex + 1)&#10;&#10;    //  NEW: 2.2.2 - Dynamic Set Management Functions&#10;&#10;    //  NEW: Enhanced set management methods&#10;    fun removeSpecificSet(setIndex: Int) {&#10;        println(&quot; SET MGMT: removeSpecificSet() called for index $setIndex&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;&#10;                if (setIndex &lt; currentSets.size) {&#10;                    val setToRemove = currentSets[setIndex]&#10;&#10;                    // Can only remove incomplete sets and must have more than 1 set&#10;                    if (!setToRemove.isCompleted &amp;&amp; currentSets.size &gt; 1) {&#10;                        println(&quot; SET MGMT: Removing set #${setToRemove.setNumber} (ID: ${setToRemove.id})&quot;)&#10;&#10;                        // Stop any running timer for this set&#10;                        if (_currentRunningSet.value == setIndex) {&#10;                            stopAllTimers()&#10;                        }&#10;&#10;                        // Remove set from database&#10;                        repository.removeSetFromWorkoutEntry(setToRemove.id)&#10;&#10;                        // Update active set index if needed&#10;                        val newSetCount = currentSets.size - 1&#10;                        if (_activeSetIndex.value &gt;= newSetCount) {&#10;                            _activeSetIndex.value = maxOf(0, newSetCount - 1)&#10;                        }&#10;&#10;                        println(&quot; SET MGMT: Successfully removed set at index $setIndex&quot;)&#10;                    } else {&#10;                        println(&quot; SET MGMT ERROR: Cannot remove set - either completed or minimum count reached&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot; SET MGMT ERROR: Failed to remove specific set - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addSetWithReps() {&#10;        println(&quot; SET MGMT: addSetWithReps() called&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;                val newSetNumber = currentSets.size + 1&#10;&#10;                if (currentSets.size &lt; 8) { // Max 8 sets per exercise&#10;                    println(&quot; SET MGMT: Adding set #$newSetNumber&quot;)&#10;&#10;                    // Add new set to database - we don't need to pass targetReps since&#10;                    // the target reps value comes from the parent workout entry&#10;                    repository.addSetToWorkoutEntry(workoutEntry.id, newSetNumber)&#10;&#10;                    println(&quot; SET MGMT: Successfully added set #$newSetNumber&quot;)&#10;                } else {&#10;                    println(&quot; SET MGMT ERROR: Cannot add set - maximum 8 sets reached&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot; SET MGMT ERROR: Failed to add set - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        restTimerJob?.cancel() //  NEW: Clean up rest timer job&#10;    }&#10;&#10;    private fun stopAllTimers() {&#10;        timerJob?.cancel()&#10;        val updatedTimers = _setTimers.value.map { timer -&gt;&#10;            timer.copy(isRunning = false)&#10;        }&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;    }&#10;&#10;    private fun updateTimerForSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers[setIndex]&#10;&#10;        if (timer.isRunning) {&#10;            val currentTime = System.currentTimeMillis()&#10;            //  FIXED: Don't add previous elapsedTime - just calculate from start&#10;            val elapsed = currentTime - timer.startTime&#10;            updatedTimers[setIndex] = timer.copy(elapsedTime = elapsed)&#10;            _setTimers.value = updatedTimers&#10;&#10;            //  REMOVED: Don't update total time during live timer updates&#10;            // updateTotalExerciseTime() // This was causing live updates in top bar&#10;&#10;            //  ADDED: Force UI recomposition for live stopwatch display&#10;            println(&quot;⏱️ TIMER: Set ${setIndex + 1} - ${elapsed / 1000}s (Live)&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateTotalExerciseTime() {&#10;        //  FIXED: Only count completed sets for total time, not running timers&#10;        val completedSets = _setTimers.value.filter { it.isCompleted }&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Calculating total exercise time...&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Found ${completedSets.size} completed sets:&quot;)&#10;&#10;        completedSets.forEachIndexed { index, set -&gt;&#10;            println(&quot; TOTAL TIME DEBUG: Set ${index + 1}: ${set.elapsedTime}ms (${set.elapsedTime / 1000}s)&quot;)&#10;        }&#10;&#10;        val setTime = completedSets.sumOf { it.elapsedTime }&#10;&#10;        //  NEW: Include accumulated rest time in total&#10;        val restTime = _totalRestTime.value&#10;        val totalTime = setTime + restTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Sum of all completed sets: ${setTime}ms (${setTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Total accumulated rest time: ${restTime}ms (${restTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Combined total time: ${totalTime}ms (${totalTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Setting _totalExerciseTime to: ${totalTime}&quot;)&#10;&#10;        _totalExerciseTime.value = totalTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: _totalExerciseTime.value is now: ${_totalExerciseTime.value}&quot;)&#10;&#10;        //  NEW: Update totalSecondsSpent in WorkoutEntry database record&#10;        val totalSeconds = (totalTime / 1000).toInt()&#10;        viewModelScope.launch {&#10;            println(&quot; TOTAL TIME DEBUG: Updating WorkoutEntry.totalSecondsSpent to ${totalSeconds}s&quot;)&#10;            repository.updateExerciseTime(workoutEntry.id, totalSeconds)&#10;            println(&quot; TOTAL TIME DEBUG: Database updated with new exercise time&quot;)&#10;        }&#10;    }&#10;&#10;    //  NEW: Rest timer functionality&#10;    private fun startRestTimer() {&#10;        println(&quot; REST DEBUG: startRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        // Don't start a new rest timer if one is already active&#10;        if (_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer already active, skipping start&quot;)&#10;            return&#10;        }&#10;&#10;        // Reset milestone flag when starting a new rest timer&#10;        _restMinuteMilestoneReached.value = false&#10;        println(&quot; REST DEBUG: Reset milestone notification flag&quot;)&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to true&quot;)&#10;        _isRestActive.value = true&#10;        val restStartTime = System.currentTimeMillis()&#10;        println(&quot; REST DEBUG: Rest timer start time: $restStartTime&quot;)&#10;&#10;        // Start the rest timer job&#10;        restTimerJob = viewModelScope.launch {&#10;            var elapsedRestTime = 0L&#10;            println(&quot; REST DEBUG: Rest timer coroutine started&quot;)&#10;&#10;            while (_isRestActive.value) {&#10;                delay(1000) // Update every second&#10;                elapsedRestTime += 1000&#10;                _restTimer.value = elapsedRestTime&#10;&#10;                //  NEW: Trigger milestone notification at 1 minute&#10;                if (elapsedRestTime &gt;= 60000 &amp;&amp; !_restMinuteMilestoneReached.value) {&#10;                    _restMinuteMilestoneReached.value = true&#10;                    println(&quot; REST MILESTONE: 1 minute of rest reached&quot;)&#10;                }&#10;&#10;                println(&quot;⏱️ REST TIMER: ${elapsedRestTime / 1000}s (Live) - _restTimer.value = ${_restTimer.value}&quot;)&#10;            }&#10;            println(&quot; REST DEBUG: Rest timer coroutine ended&quot;)&#10;        }&#10;&#10;        println(&quot; REST TIMER STARTED - Job created: ${restTimerJob != null}&quot;)&#10;    }&#10;&#10;    private fun stopRestTimer() {&#10;        println(&quot; REST DEBUG: stopRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        if (!_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer not active, nothing to stop&quot;)&#10;            return&#10;        }&#10;&#10;        //  CRITICAL FIX: Capture rest time before stopping&#10;        val completedRestTime = _restTimer.value&#10;        println(&quot; REST DEBUG: Capturing rest time: ${completedRestTime}ms (${completedRestTime / 1000}s)&quot;)&#10;&#10;        //  NEW: Add to total rest time accumulator&#10;        _totalRestTime.value += completedRestTime&#10;        println(&quot; REST DEBUG: Added ${completedRestTime}ms to total rest time&quot;)&#10;        println(&quot; REST DEBUG: Total accumulated rest time is now: ${_totalRestTime.value}ms (${_totalRestTime.value / 1000}s)&quot;)&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to false&quot;)&#10;        _isRestActive.value = false&#10;&#10;        println(&quot; REST DEBUG: Cancelling rest timer job&quot;)&#10;        restTimerJob?.cancel()&#10;        restTimerJob = null&#10;&#10;        // Reset rest timer value (but keep the accumulated total)&#10;        val previousValue = _restTimer.value&#10;        _restTimer.value = 0L&#10;        println(&quot; REST DEBUG: Reset _restTimer from ${previousValue}ms to ${_restTimer.value}ms&quot;)&#10;&#10;        //  NEW: Update total exercise time with new rest time&#10;        updateTotalExerciseTime()&#10;&#10;        println(&quot;⏹️ REST TIMER STOPPED - Rest time captured and added to total&quot;)&#10;    }&#10;}&#10;&#10;class ExerciseDetailViewModelFactory(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ExerciseDetailViewModel::class.java)) {&#10;            return ExerciseDetailViewModel(workoutEntry, repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class SetTimer(&#10;    val setNumber: Int,&#10;    val elapsedTime: Long = 0L,&#10;    val isRunning: Boolean = false,&#10;    val isCompleted: Boolean = false,&#10;    val startTime: Long = 0L&#10;)&#10;&#10;class ExerciseDetailViewModel(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModel() {&#10;&#10;    // Load actual sets from database instead of creating in memory&#10;    private val _setTimers = MutableStateFlow&lt;List&lt;SetTimer&gt;&gt;(emptyList())&#10;    val setTimers: StateFlow&lt;List&lt;SetTimer&gt;&gt; = _setTimers.asStateFlow()&#10;&#10;    private val _currentRunningSet = MutableStateFlow&lt;Int?&gt;(null)&#10;    val currentRunningSet: StateFlow&lt;Int?&gt; = _currentRunningSet.asStateFlow()&#10;&#10;    private val _activeSetIndex = MutableStateFlow&lt;Int&gt;(0)&#10;    val activeSetIndex: StateFlow&lt;Int&gt; = _activeSetIndex.asStateFlow()&#10;&#10;    private val _totalExerciseTime = MutableStateFlow(0L)&#10;    val totalExerciseTime: StateFlow&lt;Long&gt; = _totalExerciseTime.asStateFlow()&#10;&#10;    private val _completedSets = MutableStateFlow(0)&#10;    val completedSets: StateFlow&lt;Int&gt; = _completedSets.asStateFlow()&#10;&#10;    private val _isExerciseCompleted = MutableStateFlow(false)&#10;    val isExerciseCompleted: StateFlow&lt;Boolean&gt; = _isExerciseCompleted.asStateFlow()&#10;&#10;    //  FIXED: Enhanced rest timer functionality with proper time tracking&#10;    private val _restTimer = MutableStateFlow(0L)&#10;    val restTimer: StateFlow&lt;Long&gt; = _restTimer.asStateFlow()&#10;&#10;    private val _isRestActive = MutableStateFlow(false)&#10;    val isRestActive: StateFlow&lt;Boolean&gt; = _isRestActive.asStateFlow()&#10;&#10;    //  NEW: Track accumulated rest time for total exercise time calculation&#10;    private val _totalRestTime = MutableStateFlow(0L)&#10;    val totalRestTime: StateFlow&lt;Long&gt; = _totalRestTime.asStateFlow()&#10;&#10;    //  NEW: Phase 2.1.2 - Set data entry dialog state&#10;    private val _showSetDataDialog = MutableStateFlow(false)&#10;    val showSetDataDialog: StateFlow&lt;Boolean&gt; = _showSetDataDialog.asStateFlow()&#10;&#10;    private val _pendingSetData = MutableStateFlow&lt;Pair&lt;Int, Int&gt;?&gt;(null) // (setIndex, setId)&#10;    val pendingSetData: StateFlow&lt;Pair&lt;Int, Int&gt;?&gt; = _pendingSetData.asStateFlow()&#10;&#10;    //  NEW: State flow to signal when 1-minute rest milestone is reached&#10;    private val _restMinuteMilestoneReached = MutableStateFlow(false)&#10;    val restMinuteMilestoneReached: StateFlow&lt;Boolean&gt; = _restMinuteMilestoneReached.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var restTimerJob: Job? = null&#10;    private var currentSetId: Int? = null&#10;&#10;    init {&#10;        loadSetsFromDatabase()&#10;    }&#10;&#10;    private fun loadSetsFromDatabase() {&#10;        viewModelScope.launch {&#10;            println(&quot; DETAIL VM: Loading sets for workout entry ID: ${workoutEntry.id}&quot;)&#10;            println(&quot; DETAIL VM: Exercise: '${workoutEntry.exerciseName}' (Exercise ID: ${workoutEntry.exerciseId})&quot;)&#10;&#10;            // First, ensure sets exist in database&#10;            val existingSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            println(&quot; DETAIL VM: Found ${existingSets.size} existing sets in database&quot;)&#10;&#10;            if (existingSets.isEmpty()) {&#10;                println(&quot; DETAIL VM: No sets found, creating ${workoutEntry.sets} sets&quot;)&#10;                // Create sets in database if they don't exist&#10;                repository.createSetsForWorkoutEntry(workoutEntry.id, workoutEntry.sets)&#10;                println(&quot; DETAIL VM: Sets created, reloading...&quot;)&#10;            } else {&#10;                println(&quot; DETAIL VM: Sets already exist:&quot;)&#10;                existingSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;            }&#10;&#10;            // Now load sets from database and observe changes&#10;            repository.getSetsForWorkoutEntry(workoutEntry.id).collect { dbSets -&gt;&#10;                println(&quot; DETAIL VM: Received ${dbSets.size} sets from Flow for WorkoutEntry ID: ${workoutEntry.id}&quot;)&#10;                dbSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Flow Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s, repsPerformed=${set.repsPerformed}&quot;)&#10;                }&#10;&#10;                val setTimers = dbSets.map { setEntry -&gt;&#10;                    SetTimer(&#10;                        setNumber = setEntry.setNumber,&#10;                        elapsedTime = (setEntry.elapsedTimeSeconds * 1000).toLong(),&#10;                        isRunning = false, // Never restore running state from DB&#10;                        isCompleted = setEntry.isCompleted,&#10;                        startTime = 0L&#10;                    )&#10;                }&#10;&#10;                println(&quot; DETAIL VM: Created ${setTimers.size} SetTimer objects for '${workoutEntry.exerciseName}'&quot;)&#10;                _setTimers.value = setTimers&#10;                _completedSets.value = dbSets.count { it.isCompleted }&#10;                _isExerciseCompleted.value = dbSets.all { it.isCompleted } &amp;&amp; dbSets.isNotEmpty()&#10;&#10;                //  FIX: Set the active set index to the first incomplete set&#10;                val firstIncompleteSetIndex = setTimers.indexOfFirst { !it.isCompleted }&#10;                _activeSetIndex.value =&#10;                    if (firstIncompleteSetIndex != -1) firstIncompleteSetIndex else 0&#10;                println(&quot; DETAIL VM: Set active set index to: ${_activeSetIndex.value}&quot;)&#10;&#10;                updateTotalExerciseTime()&#10;&#10;                println(&quot; DETAIL VM: State updated for '${workoutEntry.exerciseName}' - completedSets: ${_completedSets.value}, isCompleted: ${_isExerciseCompleted.value}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startSetTimer(setIndex: Int) {&#10;        println(&quot; REST DEBUG: startSetTimer called for set ${setIndex + 1}&quot;)&#10;&#10;        // Stop any currently running timer&#10;        stopAllTimers()&#10;&#10;        //  NEW: Stop rest timer when starting a new set&#10;        println(&quot; REST DEBUG: Stopping rest timer before starting new set&quot;)&#10;        stopRestTimer()&#10;&#10;        // Start timer for this set&#10;        val currentTime = System.currentTimeMillis()&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        updatedTimers[setIndex] = updatedTimers[setIndex].copy(&#10;            isRunning = true,&#10;            startTime = currentTime&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = setIndex&#10;&#10;        println(&quot; REST DEBUG: Set ${setIndex + 1} timer started at $currentTime&quot;)&#10;&#10;        // Store the database set ID for persistence&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            currentSetId = dbSets.getOrNull(setIndex)?.id&#10;        }&#10;&#10;        // Start the timer coroutine&#10;        timerJob = viewModelScope.launch {&#10;            while (_setTimers.value.getOrNull(setIndex)?.isRunning == true) {&#10;                delay(1000) // Update every second&#10;                updateTimerForSet(setIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopSetTimer(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        if (timer.isRunning) {&#10;            //  FIXED: Use current elapsed time directly, don't double-count&#10;            val finalElapsedTime = System.currentTimeMillis() - timer.startTime&#10;&#10;            println(&quot; STOP TIMER DEBUG: Set ${setIndex + 1}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: timer.elapsedTime = ${timer.elapsedTime}ms&quot;)&#10;            println(&quot; STOP TIMER DEBUG: startTime = ${timer.startTime}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: currentTime = ${System.currentTimeMillis()}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: calculated elapsed = ${finalElapsedTime}ms (${finalElapsedTime / 1000}s)&quot;)&#10;&#10;            updatedTimers[setIndex] = timer.copy(&#10;                isRunning = false,&#10;                elapsedTime = finalElapsedTime&#10;                //  CHANGED: Don't mark as completed here - wait for user data entry&#10;            )&#10;            _setTimers.value = updatedTimers&#10;            _currentRunningSet.value = null&#10;            timerJob?.cancel()&#10;&#10;            //  NEW: Phase 2.1.2 - Show data entry dialog instead of immediate completion&#10;            currentSetId?.let { setId -&gt;&#10;                println(&quot; DIALOG: Showing set data entry dialog for set ${setIndex + 1}&quot;)&#10;                _pendingSetData.value = Pair(setIndex, setId)&#10;                _showSetDataDialog.value = true&#10;&#10;                //  IMPORTANT: Start rest timer while user enters data&#10;                startRestTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Handle set performance data submission&#10;    fun submitSetPerformanceData(repsPerformed: Int, weightUsed: Float) {&#10;        val pendingData = _pendingSetData.value ?: return&#10;        val (setIndex, setId) = pendingData&#10;&#10;        println(&quot; DIALOG: Submitting performance data - Set ${setIndex + 1}, Reps: $repsPerformed, Weight: $weightUsed&quot;)&#10;&#10;        viewModelScope.launch {&#10;            // Get the timer data for this set&#10;            val timer = _setTimers.value.getOrNull(setIndex)&#10;            val elapsedTimeSeconds = ((timer?.elapsedTime ?: 0L) / 1000).toInt()&#10;&#10;            // Update database with completion and performance data&#10;            repository.updateSetProgressWithPerformanceData(&#10;                setId = setId,&#10;                isCompleted = true,&#10;                elapsedTimeSeconds = elapsedTimeSeconds,&#10;                repsPerformed = repsPerformed,&#10;                weightUsed = weightUsed&#10;            )&#10;&#10;            // Update local state to mark set as completed&#10;            val updatedTimers = _setTimers.value.toMutableList()&#10;            updatedTimers[setIndex] = updatedTimers[setIndex].copy(isCompleted = true)&#10;            _setTimers.value = updatedTimers&#10;&#10;            // Update exercise completion status&#10;            repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;&#10;            // Update local completed sets count&#10;            val completedCount = _setTimers.value.count { it.isCompleted }&#10;            _completedSets.value = completedCount&#10;&#10;            // Check if all sets are completed&#10;            if (completedCount == workoutEntry.sets) {&#10;                _isExerciseCompleted.value = true&#10;                // Stop rest timer if all sets are completed&#10;                stopRestTimer()&#10;            } else {&#10;                // Advance to next set - find the first incomplete set&#10;                val nextIncompleteSetIndex = _setTimers.value.indexOfFirst { !it.isCompleted }&#10;                if (nextIncompleteSetIndex != -1) {&#10;                    _activeSetIndex.value = nextIncompleteSetIndex&#10;                    println(&quot; DETAIL VM: Advanced to next set index: $nextIncompleteSetIndex&quot;)&#10;                }&#10;            }&#10;&#10;            // Update total time calculation&#10;            updateTotalExerciseTime()&#10;&#10;            // Hide dialog and clear pending data&#10;            _showSetDataDialog.value = false&#10;            _pendingSetData.value = null&#10;&#10;            println(&quot; DIALOG: Set performance data saved successfully&quot;)&#10;        }&#10;    }&#10;&#10;    //  NEW: 2.2.1 - Edit set data functionality&#10;    fun editSetData(setIndex: Int) {&#10;        println(&quot; EDIT: editSetData called for set ${setIndex + 1}&quot;)&#10;&#10;        viewModelScope.launch {&#10;            val sets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            val setToEdit = sets.getOrNull(setIndex)&#10;&#10;            if (setToEdit != null &amp;&amp; setToEdit.isCompleted) {&#10;                println(&quot; EDIT: Opening edit dialog for completed set ${setIndex + 1}&quot;)&#10;                _pendingSetData.value = Pair(setIndex, setToEdit.id)&#10;                _showSetDataDialog.value = true&#10;            } else {&#10;                println(&quot; EDIT: Cannot edit set ${setIndex + 1} - not completed or not found&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Enhanced dialog state management for editing&#10;    fun dismissSetDataDialog() {&#10;        println(&quot; DIALOG: Dismissing set data dialog&quot;)&#10;        _showSetDataDialog.value = false&#10;        _pendingSetData.value = null&#10;    }&#10;&#10;    // Get set data for UI display&#10;    fun getSetData(setIndex: Int) = repository.getSetByIndex(workoutEntry.id, setIndex + 1)&#10;&#10;    //  NEW: 2.2.2 - Dynamic Set Management Functions&#10;&#10;    //  NEW: Enhanced set management methods&#10;    fun removeSpecificSet(setIndex: Int) {&#10;        println(&quot; SET MGMT: removeSpecificSet() called for index $setIndex&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;&#10;                if (setIndex &lt; currentSets.size) {&#10;                    val setToRemove = currentSets[setIndex]&#10;&#10;                    // Can only remove incomplete sets and must have more than 1 set&#10;                    if (!setToRemove.isCompleted &amp;&amp; currentSets.size &gt; 1) {&#10;                        println(&quot; SET MGMT: Removing set #${setToRemove.setNumber} (ID: ${setToRemove.id})&quot;)&#10;&#10;                        // Stop any running timer for this set&#10;                        if (_currentRunningSet.value == setIndex) {&#10;                            stopAllTimers()&#10;                        }&#10;&#10;                        // Remove set from database&#10;                        repository.removeSetFromWorkoutEntry(setToRemove.id)&#10;&#10;                        // Update active set index if needed&#10;                        val newSetCount = currentSets.size - 1&#10;                        if (_activeSetIndex.value &gt;= newSetCount) {&#10;                            _activeSetIndex.value = maxOf(0, newSetCount - 1)&#10;                        }&#10;&#10;                        println(&quot; SET MGMT: Successfully removed set at index $setIndex&quot;)&#10;                    } else {&#10;                        println(&quot; SET MGMT ERROR: Cannot remove set - either completed or minimum count reached&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot; SET MGMT ERROR: Failed to remove specific set - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addSetWithReps() {&#10;        println(&quot; SET MGMT: addSetWithReps() called&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;                val newSetNumber = currentSets.size + 1&#10;&#10;                if (currentSets.size &lt; 8) { // Max 8 sets per exercise&#10;                    println(&quot; SET MGMT: Adding set #$newSetNumber&quot;)&#10;&#10;                    // Add new set to database - we don't need to pass targetReps since&#10;                    // the target reps value comes from the parent workout entry&#10;                    repository.addSetToWorkoutEntry(workoutEntry.id, newSetNumber)&#10;&#10;                    println(&quot; SET MGMT: Successfully added set #$newSetNumber&quot;)&#10;                } else {&#10;                    println(&quot; SET MGMT ERROR: Cannot add set - maximum 8 sets reached&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot; SET MGMT ERROR: Failed to add set - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    //  NEW: Reset a completed set&#10;    fun resetSet(setIndex: Int) {&#10;        println(&quot; RESET: resetSet() called for index $setIndex&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;&#10;                if (setIndex &lt; currentSets.size) {&#10;                    val setToReset = currentSets[setIndex]&#10;&#10;                    if (setToReset.isCompleted) {&#10;                        println(&quot; RESET: Resetting set #${setToReset.setNumber} (ID: ${setToReset.id})&quot;)&#10;&#10;                        // Reset set in database - clear completion status and performance data&#10;                        repository.updateSetProgressWithPerformanceData(&#10;                            setId = setToReset.id,&#10;                            isCompleted = false,&#10;                            elapsedTimeSeconds = 0,&#10;                            completedAt = null,&#10;                            repsPerformed = 0,  // Changed from null to 0&#10;                            weightUsed = 0f     // Changed from null to 0f&#10;                        )&#10;&#10;                        // Update local state&#10;                        val updatedTimers = _setTimers.value.toMutableList()&#10;                        updatedTimers[setIndex] = updatedTimers[setIndex].copy(&#10;                            isCompleted = false,&#10;                            elapsedTime = 0L&#10;                        )&#10;                        _setTimers.value = updatedTimers&#10;&#10;                        // Update completed sets count&#10;                        _completedSets.value = _completedSets.value - 1&#10;&#10;                        // Update exercise completion status&#10;                        repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;                        _isExerciseCompleted.value = false&#10;&#10;                        // Update active set index if needed&#10;                        if (_activeSetIndex.value &gt; setIndex) {&#10;                            _activeSetIndex.value = setIndex&#10;                        }&#10;&#10;                        // Update total exercise time&#10;                        updateTotalExerciseTime()&#10;&#10;                        println(&quot; RESET: Successfully reset set at index $setIndex&quot;)&#10;                    } else {&#10;                        println(&quot; RESET ERROR: Cannot reset set - not completed&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot; RESET ERROR: Failed to reset set - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        restTimerJob?.cancel() //  NEW: Clean up rest timer job&#10;    }&#10;&#10;    private fun stopAllTimers() {&#10;        timerJob?.cancel()&#10;        val updatedTimers = _setTimers.value.map { timer -&gt;&#10;            timer.copy(isRunning = false)&#10;        }&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;    }&#10;&#10;    private fun updateTimerForSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers[setIndex]&#10;&#10;        if (timer.isRunning) {&#10;            val currentTime = System.currentTimeMillis()&#10;            //  FIXED: Don't add previous elapsedTime - just calculate from start&#10;            val elapsed = currentTime - timer.startTime&#10;            updatedTimers[setIndex] = timer.copy(elapsedTime = elapsed)&#10;            _setTimers.value = updatedTimers&#10;&#10;            //  REMOVED: Don't update total time during live timer updates&#10;            // updateTotalExerciseTime() // This was causing live updates in top bar&#10;&#10;            //  ADDED: Force UI recomposition for live stopwatch display&#10;            println(&quot;⏱️ TIMER: Set ${setIndex + 1} - ${elapsed / 1000}s (Live)&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateTotalExerciseTime() {&#10;        //  FIXED: Only count completed sets for total time, not running timers&#10;        val completedSets = _setTimers.value.filter { it.isCompleted }&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Calculating total exercise time...&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Found ${completedSets.size} completed sets:&quot;)&#10;&#10;        completedSets.forEachIndexed { index, set -&gt;&#10;            println(&quot; TOTAL TIME DEBUG: Set ${index + 1}: ${set.elapsedTime}ms (${set.elapsedTime / 1000}s)&quot;)&#10;        }&#10;&#10;        val setTime = completedSets.sumOf { it.elapsedTime }&#10;&#10;        //  NEW: Include accumulated rest time in total&#10;        val restTime = _totalRestTime.value&#10;        val totalTime = setTime + restTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Sum of all completed sets: ${setTime}ms (${setTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Total accumulated rest time: ${restTime}ms (${restTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Combined total time: ${totalTime}ms (${totalTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Setting _totalExerciseTime to: ${totalTime}&quot;)&#10;&#10;        _totalExerciseTime.value = totalTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: _totalExerciseTime.value is now: ${_totalExerciseTime.value}&quot;)&#10;&#10;        //  NEW: Update totalSecondsSpent in WorkoutEntry database record&#10;        val totalSeconds = (totalTime / 1000).toInt()&#10;        viewModelScope.launch {&#10;            println(&quot; TOTAL TIME DEBUG: Updating WorkoutEntry.totalSecondsSpent to ${totalSeconds}s&quot;)&#10;            repository.updateExerciseTime(workoutEntry.id, totalSeconds)&#10;            println(&quot; TOTAL TIME DEBUG: Database updated with new exercise time&quot;)&#10;        }&#10;    }&#10;&#10;    //  NEW: Rest timer functionality&#10;    private fun startRestTimer() {&#10;        println(&quot; REST DEBUG: startRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        // Don't start a new rest timer if one is already active&#10;        if (_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer already active, skipping start&quot;)&#10;            return&#10;        }&#10;&#10;        // Reset milestone flag when starting a new rest timer&#10;        _restMinuteMilestoneReached.value = false&#10;        println(&quot; REST DEBUG: Reset milestone notification flag&quot;)&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to true&quot;)&#10;        _isRestActive.value = true&#10;        val restStartTime = System.currentTimeMillis()&#10;        println(&quot; REST DEBUG: Rest timer start time: $restStartTime&quot;)&#10;&#10;        // Start the rest timer job&#10;        restTimerJob = viewModelScope.launch {&#10;            var elapsedRestTime = 0L&#10;            println(&quot; REST DEBUG: Rest timer coroutine started&quot;)&#10;&#10;            while (_isRestActive.value) {&#10;                delay(1000) // Update every second&#10;                elapsedRestTime += 1000&#10;                _restTimer.value = elapsedRestTime&#10;&#10;                //  NEW: Trigger milestone notification at 1 minute&#10;                if (elapsedRestTime &gt;= 60000 &amp;&amp; !_restMinuteMilestoneReached.value) {&#10;                    _restMinuteMilestoneReached.value = true&#10;                    println(&quot; REST MILESTONE: 1 minute of rest reached&quot;)&#10;                }&#10;&#10;                println(&quot;⏱️ REST TIMER: ${elapsedRestTime / 1000}s (Live) - _restTimer.value = ${_restTimer.value}&quot;)&#10;            }&#10;            println(&quot; REST DEBUG: Rest timer coroutine ended&quot;)&#10;        }&#10;&#10;        println(&quot; REST TIMER STARTED - Job created: ${restTimerJob != null}&quot;)&#10;    }&#10;&#10;    private fun stopRestTimer() {&#10;        println(&quot; REST DEBUG: stopRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        if (!_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer not active, nothing to stop&quot;)&#10;            return&#10;        }&#10;&#10;        //  CRITICAL FIX: Capture rest time before stopping&#10;        val completedRestTime = _restTimer.value&#10;        println(&quot; REST DEBUG: Capturing rest time: ${completedRestTime}ms (${completedRestTime / 1000}s)&quot;)&#10;&#10;        //  NEW: Add to total rest time accumulator&#10;        _totalRestTime.value += completedRestTime&#10;        println(&quot; REST DEBUG: Added ${completedRestTime}ms to total rest time&quot;)&#10;        println(&quot; REST DEBUG: Total accumulated rest time is now: ${_totalRestTime.value}ms (${_totalRestTime.value / 1000}s)&quot;)&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to false&quot;)&#10;        _isRestActive.value = false&#10;&#10;        println(&quot; REST DEBUG: Cancelling rest timer job&quot;)&#10;        restTimerJob?.cancel()&#10;        restTimerJob = null&#10;&#10;        // Reset rest timer value (but keep the accumulated total)&#10;        val previousValue = _restTimer.value&#10;        _restTimer.value = 0L&#10;        println(&quot; REST DEBUG: Reset _restTimer from ${previousValue}ms to ${_restTimer.value}ms&quot;)&#10;&#10;        //  NEW: Update total exercise time with new rest time&#10;        updateTotalExerciseTime()&#10;&#10;        println(&quot;⏹️ REST TIMER STOPPED - Rest time captured and added to total&quot;)&#10;    }&#10;}&#10;&#10;class ExerciseDetailViewModelFactory(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ExerciseDetailViewModel::class.java)) {&#10;            return ExerciseDetailViewModel(workoutEntry, repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_history.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_history.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M13,3c-4.97,0 -9,4.03 -9,9L1,12l3.89,3.89 0.07,0.14L9,12L6,12c0,-3.87 3.13,-7 7,-7s7,3.13 7,7 -3.13,7 -7,7c-1.93,0 -3.68,-0.79 -4.94,-2.06l-1.42,1.42C8.27,19.99 10.51,21 13,21c4.97,0 9,-4.03 9,-9s-4.03,-9 -9,-9zM12,8v5l4.28,2.54 0.72,-1.21 -3.5,-2.08L13.5,8L12,8z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_home.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_home.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M10,20v-6h4v6h5v-8h3L12,3 2,12h3v8z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_performance.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_performance.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M19,3L5,3c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2L21,5c0,-1.1 -0.9,-2 -2,-2zM9,17L7,17v-7h2v7zM13,17h-2L11,7h2v10zM17,17h-2v-4h2v4z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_settings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_settings.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;@android:color/black&quot;&#10;        android:pathData=&quot;M19.14,12.94c0.04,-0.3 0.06,-0.61 0.06,-0.94c0,-0.32 -0.02,-0.64 -0.07,-0.94l2.03,-1.58c0.18,-0.14 0.23,-0.41 0.12,-0.61l-1.92,-3.32c-0.12,-0.22 -0.37,-0.29 -0.59,-0.22l-2.39,0.96c-0.5,-0.38 -1.03,-0.7 -1.62,-0.94L14.4,2.81c-0.04,-0.24 -0.24,-0.41 -0.48,-0.41h-3.84c-0.24,0 -0.43,0.17 -0.47,0.41L9.25,5.35C8.66,5.59 8.12,5.92 7.63,6.29L5.24,5.33c-0.22,-0.08 -0.47,0 -0.59,0.22L2.74,8.87C2.62,9.08 2.66,9.34 2.86,9.48l2.03,1.58C4.84,11.36 4.8,11.69 4.8,12s0.02,0.64 0.07,0.94l-2.03,1.58c-0.18,0.14 -0.23,0.41 -0.12,0.61l1.92,3.32c0.12,0.22 0.37,0.29 0.59,0.22l2.39,-0.96c0.5,0.38 1.03,0.7 1.62,0.94l0.36,2.54c0.05,0.24 0.24,0.41 0.48,0.41h3.84c0.24,0 0.44,-0.17 0.47,-0.41l0.36,-2.54c0.59,-0.24 1.13,-0.56 1.62,-0.94l2.39,0.96c0.22,0.08 0.47,0 0.59,-0.22l1.92,-3.32c0.12,-0.22 0.07,-0.47 -0.12,-0.61L19.14,12.94zM12,15.6c-1.98,0 -3.6,-1.62 -3.6,-3.6s1.62,-3.6 3.6,-3.6s3.6,1.62 3.6,3.6S13.98,15.6 12,15.6z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gradle/libs.versions.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gradle/libs.versions.toml" />
              <option name="originalContent" value="[versions]&#10;agp = &quot;8.11.1&quot;&#10;kotlin = &quot;2.0.21&quot;&#10;coreKtx = &quot;1.10.1&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.1.5&quot;&#10;espressoCore = &quot;3.5.1&quot;&#10;lifecycleRuntimeKtx = &quot;2.6.1&quot;&#10;activityCompose = &quot;1.8.0&quot;&#10;composeBom = &quot;2024.09.00&quot;&#10;room = &quot;2.6.1&quot;&#10;hilt = &quot;2.48&quot;&#10;hiltNavigationCompose = &quot;1.1.0&quot;&#10;navigation = &quot;2.7.5&quot;&#10;ksp = &quot;2.0.21-1.0.25&quot;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-ui-tooling = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling&quot; }&#10;androidx-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-ui-test-manifest = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-manifest&quot; }&#10;androidx-ui-test-junit4 = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-junit4&quot; }&#10;androidx-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;androidx-room-runtime = { group = &quot;androidx.room&quot;, name = &quot;room-runtime&quot;, version.ref = &quot;room&quot; }&#10;androidx-room-compiler = { group = &quot;androidx.room&quot;, name = &quot;room-compiler&quot;, version.ref = &quot;room&quot; }&#10;androidx-room-ktx = { group = &quot;androidx.room&quot;, name = &quot;room-ktx&quot;, version.ref = &quot;room&quot; }&#10;androidx-room-testing = { group = &quot;androidx.room&quot;, name = &quot;room-testing&quot;, version.ref = &quot;room&quot; }&#10;hilt-android = { group = &quot;com.google.dagger&quot;, name = &quot;hilt-android&quot;, version.ref = &quot;hilt&quot; }&#10;hilt-compiler = { group = &quot;com.google.dagger&quot;, name = &quot;hilt-compiler&quot;, version.ref = &quot;hilt&quot; }&#10;androidx-hilt-navigation-compose = { group = &quot;androidx.hilt&quot;, name = &quot;hilt-navigation-compose&quot;, version.ref = &quot;hiltNavigationCompose&quot; }&#10;androidx-navigation-compose = { group = &quot;androidx.navigation&quot;, name = &quot;navigation-compose&quot;, version.ref = &quot;navigation&quot; }&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }&#10;kotlin-compose = { id = &quot;org.jetbrains.kotlin.plugin.compose&quot;, version.ref = &quot;kotlin&quot; }&#10;hilt = { id = &quot;com.google.dagger.hilt.android&quot;, version.ref = &quot;hilt&quot; }&#10;ksp = { id = &quot;com.google.devtools.ksp&quot;, version.ref = &quot;ksp&quot; }&#10;" />
              <option name="updatedContent" value="[versions]&#10;agp = &quot;8.11.1&quot;&#10;kotlin = &quot;2.0.21&quot;&#10;coreKtx = &quot;1.10.1&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.1.5&quot;&#10;espressoCore = &quot;3.5.1&quot;&#10;lifecycleRuntimeKtx = &quot;2.6.1&quot;&#10;activityCompose = &quot;1.8.0&quot;&#10;composeBom = &quot;2024.09.00&quot;&#10;room = &quot;2.6.1&quot;&#10;hilt = &quot;2.48&quot;&#10;hiltNavigationCompose = &quot;1.1.0&quot;&#10;navigation = &quot;2.7.5&quot;&#10;ksp = &quot;2.0.21-1.0.25&quot;&#10;materialIconsExtended = &quot;1.6.5&quot;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-ui-tooling = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling&quot; }&#10;androidx-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-ui-test-manifest = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-manifest&quot; }&#10;androidx-ui-test-junit4 = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-junit4&quot; }&#10;androidx-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;androidx-room-runtime = { group = &quot;androidx.room&quot;, name = &quot;room-runtime&quot;, version.ref = &quot;room&quot; }&#10;androidx-room-compiler = { group = &quot;androidx.room&quot;, name = &quot;room-compiler&quot;, version.ref = &quot;room&quot; }&#10;androidx-room-ktx = { group = &quot;androidx.room&quot;, name = &quot;room-ktx&quot;, version.ref = &quot;room&quot; }&#10;androidx-room-testing = { group = &quot;androidx.room&quot;, name = &quot;room-testing&quot;, version.ref = &quot;room&quot; }&#10;hilt-android = { group = &quot;com.google.dagger&quot;, name = &quot;hilt-android&quot;, version.ref = &quot;hilt&quot; }&#10;hilt-compiler = { group = &quot;com.google.dagger&quot;, name = &quot;hilt-compiler&quot;, version.ref = &quot;hilt&quot; }&#10;androidx-hilt-navigation-compose = { group = &quot;androidx.hilt&quot;, name = &quot;hilt-navigation-compose&quot;, version.ref = &quot;hiltNavigationCompose&quot; }&#10;androidx-navigation-compose = { group = &quot;androidx.navigation&quot;, name = &quot;navigation-compose&quot;, version.ref = &quot;navigation&quot; }&#10;androidx-material-icons-core = { group = &quot;androidx.compose.material&quot;, name = &quot;material-icons-core&quot;, version.ref = &quot;materialIconsExtended&quot; }&#10;androidx-material-icons-extended = { group = &quot;androidx.compose.material&quot;, name = &quot;material-icons-extended&quot;, version.ref = &quot;materialIconsExtended&quot; }&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }&#10;kotlin-compose = { id = &quot;org.jetbrains.kotlin.plugin.compose&quot;, version.ref = &quot;kotlin&quot; }&#10;hilt = { id = &quot;com.google.dagger.hilt.android&quot;, version.ref = &quot;hilt&quot; }&#10;ksp = { id = &quot;com.google.devtools.ksp&quot;, version.ref = &quot;ksp&quot; }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>