<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/MIGRATION_ROADMAP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MIGRATION_ROADMAP.md" />
              <option name="originalContent" value="# ️ PPL Workout App - Migration Roadmap&#10;&#10;## Overview&#10;This document outlines the migration path from the current simplified architecture to the advanced, production-ready architecture shown in the database and workflow diagrams.&#10;&#10;## Current State Analysis ✅&#10;&#10;### Database Schema (Working) - Version 7&#10;- [x] **exercises** table: Enhanced with rich metadata (primaryMuscle, secondaryMuscles, equipment, difficulty, instructions, tips, category) ✅&#10;- [x] **workout_days** table: Stores daily workout sessions ✅&#10;- [x] **workout_entries** table: Links exercises to workout days ✅&#10;- [x] **set_entries** table: Individual set tracking with timing ✅&#10;- [x] **workout_templates** table: Template definitions for reusable workouts ✅&#10;- [x] **template_exercises** table: Junction table linking templates to exercises ✅&#10;&#10;### Features Working ✅&#10;- [x] PPL workout creation based on day of week&#10;- [x] **Template-based workout creation system** ✅&#10;- [x] Exercise detail screens with set progression&#10;- [x] Individual set timing and completion tracking&#10;- [x] Cross-exercise contamination fixed (sets isolated per exercise)&#10;- [x] Database reset functionality for development&#10;- [x] Timer functionality with start/stop per set&#10;- [x] Enhanced exercise library with rich metadata (34+ exercises)&#10;- [x] Automatic template population on database creation&#10;- [x] Template selection and creation methods&#10;&#10;### Current Architecture Status&#10;- **Exercise Library**: Rich metadata with 34+ exercises in `ExerciseData.getPPLExercises()` ✅&#10;- **Template System**: Complete entities, DAOs, and repository methods ✅&#10;- **Workout Logic**: **Both day-based AND template-based systems working** ✅&#10;- **Database Version**: 7 (with complete template system migration)&#10;- **UI Layer**: Daily workout screens with template integration ✅&#10;&#10;---&#10;&#10;## Phase 1: Core Foundation ✅ **COMPLETED**&#10;&#10;### 1.1 Project Setup &amp; Database ✅&#10;- [x] 1.1.1 Android project with Kotlin &amp; Compose&#10;- [x] 1.1.2 Room database implementation&#10;- [x] 1.1.3 Entity models (WorkoutDay, Exercise, WorkoutEntry, SetEntry)&#10;- [x] 1.1.4 DAO implementations&#10;- [x] 1.1.5 Repository pattern&#10;&#10;### 1.2 Basic UI &amp; Navigation ✅&#10;- [x] 1.2.1 Material Design 3 theme&#10;- [x] 1.2.2 Navigation between screens&#10;- [x] 1.2.3 Daily workout view&#10;- [x] 1.2.4 Exercise list screen&#10;- [x] 1.2.5 Exercise detail screen&#10;&#10;### 1.3 Workout Logic ✅&#10;- [x] 1.3.1 PPL schedule implementation (6-day rotation)&#10;- [x] 1.3.2 Rest day handling with background image&#10;- [x] 1.3.3 Workout day creation and exercise population&#10;- [x] 1.3.4 Set tracking and completion logic&#10;- [x] 1.3.5 Exercise progress tracking&#10;&#10;### 1.4 Timer &amp; Time Tracking ✅ **COMPLETED**&#10;- [x] 1.4.1 Individual set timers (start/stop functionality)&#10;- [x] 1.4.2 Total exercise time calculation&#10;- [x] 1.4.3 Set completion tracking&#10;- [x] 1.4.4 Sequential set unlocking&#10;- [x] 1.4.5 Rest period timer implementation ✅ **FIXED**&#10;- [x] 1.4.6 Proper time formatting (HH:MM:SS) ✅ **FIXED**&#10;&#10;---&#10;&#10;##  **HOTFIX SECTION** ✅ **ALL COMPLETED**&#10;&#10;### Timer &amp; Time Display Issues ✅&#10;- [x] **HF-1**: Fix timer display format (was showing weird increments like 1,3,5,7...)&#10;  - ✅ FIXED: Timer now shows proper HH:MM:SS format&#10;  - ✅ FIXED: Standard stopwatch behavior (00:00:01, 00:00:02, etc.)&#10;&#10;- [x] **HF-2**: Fix total exercise time calculation&#10;  - ✅ FIXED: Total time shows accurate values&#10;  - ✅ FIXED: Consistent time calculations including rest periods&#10;  - ✅ FIXED: Rest time properly captured and added to total&#10;&#10;- [x] **HF-3**: Remove &quot;Mark as Done&quot; button confusion&#10;  - ✅ FIXED: Simplified to Start → Stop → Completed flow&#10;  - ✅ FIXED: Clean UX with single action buttons&#10;&#10;- [x] **HF-4**: Fix total time live updates&#10;  - ✅ FIXED: Total time only updates when set completes&#10;  - ✅ FIXED: No more live updates during active sets&#10;&#10;### UI/UX Improvements ✅&#10;- [x] **HF-5**: Color scheme improvements (black text, yellow accents)&#10;- [x] **HF-6**: Exercise completion state persistence&#10;- [x] **HF-7**: Set counter display accuracy&#10;- [x] **HF-8**: Database reset functionality&#10;&#10;### Rest Timer Implementation ✅ **NEW - COMPLETED**&#10;- [x] **HF-9**: Complete rest timer functionality&#10;  - ✅ FIXED: Rest timer starts automatically after set completion&#10;  - ✅ FIXED: Rest time captured and added to total exercise time&#10;  - ✅ FIXED: Rest timer stops when next set starts&#10;  - ✅ FIXED: Total time = completed set times + accumulated rest time&#10;  - ✅ TESTED: Manual testing confirms expected behavior&#10;&#10;---&#10;&#10;## Phase 2: Set Data Collection &amp; Management  **NEXT PRIORITY**&#10;&#10;### 2.1 Set Performance Data Entry ⭐ **NEW REQUIREMENT**&#10;- [ ] 2.1.1 Add database fields for set performance data&#10;  - Add `reps_performed` (INT) to set_entries table&#10;  - Add `weight_used` (DECIMAL/FLOAT) to set_entries table&#10;  - Create database migration for new fields&#10;  - Update SetEntry entity and DAO methods&#10;&#10;- [ ] 2.1.2 Set completion popup with data entry&#10;  - Create popup/dialog component for set data entry&#10;  - Two required text fields: &quot;Reps Performed&quot; and &quot;Weight Used&quot;&#10;  - Mandatory fields - no cancel button, only &quot;ADD&quot; button&#10;  - Popup appears when user completes a set (stops timer)&#10;  - Rest timer continues running in background during data entry&#10;&#10;- [ ] 2.1.3 Set data persistence and validation&#10;  - Save reps and weight data to database on popup submit&#10;  - Input validation (positive numbers, reasonable ranges)&#10;  - Update set completion flow to include data entry step&#10;  - Handle data persistence errors gracefully&#10;&#10;### 2.2 Set Data Editing &amp; Management  **NEW REQUIREMENT**&#10;- [ ] 2.2.1 Edit completed set data&#10;  - Allow users to edit reps/weight after set completion&#10;  - Add edit button/icon to completed set cards&#10;  - Reopen data entry popup with pre-filled values&#10;  - Update database with edited values&#10;&#10;- [ ] 2.2.2 Dynamic set management&#10;  - Add &quot;+&quot; button to add extra sets to exercise&#10;  - Add &quot;−&quot; button to remove sets from exercise (if not completed)&#10;  - Update exercise completion logic for dynamic set counts&#10;  - Maintain proper set numbering when adding/removing sets&#10;&#10;- [ ] 2.2.3 Enhanced set display&#10;  - Show reps and weight data on set cards&#10;  - Display format: &quot;Set 1: 12 reps @ 135 lbs&quot; (when completed)&#10;  - Show &quot;Set 1: — reps @ — lbs&quot; (when not completed)&#10;  - Visual distinction between completed and pending sets&#10;&#10;### 2.3 Data Validation &amp; UX Improvements  **NEW REQUIREMENT**&#10;- [ ] 2.3.1 Input validation and user guidance&#10;  - Numeric keyboard for reps and weight fields&#10;  - Input hints and placeholders (&quot;e.g., 12&quot;, &quot;e.g., 135.5&quot;)&#10;  - Validation messages for invalid inputs&#10;  - Auto-focus progression between fields&#10;&#10;- [ ] 2.3.2 Set performance analytics&#10;  - Calculate and display total volume per exercise (sets × reps × weight)&#10;  - Show previous set performance for reference&#10;  - Progressive overload indicators (vs last workout)&#10;  - Exercise completion status with performance summary&#10;&#10;- [ ] 2.3.3 Enhanced timer integration&#10;  - Rest timer continues during data entry popup&#10;  - Clear visual indication that rest timer is still running&#10;  - Seamless transition from set completion → data entry → rest period&#10;  - Timer state preservation across popup interactions&#10;&#10;**User Flow Enhancement**:&#10;1. User starts Set 1 → Completes set (stops timer) ✅&#10;2. **NEW**: Data entry popup appears → User enters reps &amp; weight → Clicks ADD&#10;3. Rest timer starts automatically (or continues if already running) ✅&#10;4. User can edit set data anytime by tapping completed set card&#10;5. User can add/remove sets as needed during workout&#10;6. Exercise shows total volume and performance summary&#10;&#10;**Benefits**:&#10;- Comprehensive workout tracking with actual performance data&#10;- Progressive overload tracking (essential for strength training)&#10;- Flexible set management for different workout intensities&#10;- Professional gym app experience with detailed analytics&#10;&#10;---&#10;&#10;## Phase 3: Enhanced Exercise Experience  **PLANNED**&#10;- [ ] 3.1.1 Exercise instruction screens&#10;- [ ] 3.1.2 Exercise tips and form cues&#10;- [ ] 3.1.3 Primary/secondary muscle groups display&#10;- [ ] 3.1.4 Equipment requirements display&#10;- [ ] 3.1.5 Exercise difficulty indicators&#10;&#10;### 3.2 Calendar &amp; History View  **PLANNED**&#10;- [ ] 3.2.1 Calendar navigation&#10;- [ ] 3.2.2 Historical workout data view&#10;- [ ] 3.2.3 Progress tracking over time&#10;- [ ] 3.2.4 Workout completion statistics&#10;&#10;---&#10;&#10;## Phase 4: Advanced Features  **PLANNED**&#10;&#10;### 4.1 Location Services&#10;- [ ] 4.1.1 Gym location detection&#10;- [ ] 4.1.2 Location-based notifications&#10;- [ ] 4.1.3 Gym check-in tracking&#10;&#10;### 4.2 Data Management&#10;- [ ] 4.2.1 Data export functionality&#10;- [ ] 4.2.2 Backup/restore system&#10;- [ ] 4.2.3 30-day data cleanup job&#10;- [ ] 4.2.4 Data migration handling&#10;&#10;### 4.3 Enhanced UX&#10;- [ ] 4.3.1 Dark mode support&#10;- [ ] 4.3.2 Accessibility improvements&#10;- [ ] 4.3.3 Animations and transitions&#10;- [ ] 4.3.4 Haptic feedback&#10;&#10;---&#10;&#10;## Development Status&#10;&#10;### Current Achievement: PHASE 1 COMPLETE! &#10;**Major Milestone**: All core functionality is now solid and reliable!&#10;&#10;✅ **Database &amp; Architecture** - Robust Room implementation&#10;✅ **Timer System** - Professional-grade stopwatch with rest periods&#10;✅ **Workout Flow** - Smooth set progression and completion tracking&#10;✅ **UI/UX Foundation** - Clean, consistent Material Design 3 interface&#10;✅ **Data Persistence** - Reliable workout state management&#10;&#10;### Next Priority: Phase 2.2 - Enhanced Exercise Experience&#10;**Focus**: Improve user guidance and exercise education&#10;&#10;**Benefits for Users**:&#10;- Better exercise form through detailed instructions&#10;- Understanding of muscle targeting&#10;- Equipment awareness&#10;- Difficulty progression guidance&#10;&#10;### Implementation Ready:&#10;The app now has a solid foundation with:&#10;- ✅ Accurate timer system (including rest periods)&#10;- ✅ Reliable data persistence&#10;- ✅ Clean user interface&#10;- ✅ Proper error handling&#10;- ✅ Comprehensive logging for debugging&#10;&#10;---&#10;&#10;## Testing Status&#10;&#10;### Core Functionality ✅ **ALL VERIFIED**&#10;- [x] App starts without crashes&#10;- [x] Workout creation for current day&#10;- [x] Exercise navigation&#10;- [x] Set completion tracking&#10;- [x] Database persistence&#10;- [x] Timer accuracy and formatting&#10;- [x] Rest timer functionality&#10;- [x] Total time calculations (including rest periods)&#10;&#10;### Ready for Next Phase ✅&#10;All Phase 1 requirements have been implemented and tested successfully.&#10;&#10;---&#10;&#10;*Last Updated: July 31, 2025*&#10;*Current Status: Phase 1 Complete ✅ | Ready for Phase 2.2 *&#10;" />
              <option name="updatedContent" value="# ️ PPL Workout App - Migration Roadmap&#10;&#10;## Overview&#10;This document outlines the migration path from the current simplified architecture to the advanced, production-ready architecture shown in the database and workflow diagrams.&#10;&#10;## Current State Analysis ✅&#10;&#10;### Database Schema (Working) - Version 7&#10;- [x] **exercises** table: Enhanced with rich metadata (primaryMuscle, secondaryMuscles, equipment, difficulty, instructions, tips, category) ✅&#10;- [x] **workout_days** table: Stores daily workout sessions ✅&#10;- [x] **workout_entries** table: Links exercises to workout days ✅&#10;- [x] **set_entries** table: Individual set tracking with timing ✅&#10;- [x] **workout_templates** table: Template definitions for reusable workouts ✅&#10;- [x] **template_exercises** table: Junction table linking templates to exercises ✅&#10;&#10;### Features Working ✅&#10;- [x] PPL workout creation based on day of week&#10;- [x] **Template-based workout creation system** ✅&#10;- [x] Exercise detail screens with set progression&#10;- [x] Individual set timing and completion tracking&#10;- [x] Cross-exercise contamination fixed (sets isolated per exercise)&#10;- [x] Database reset functionality for development&#10;- [x] Timer functionality with start/stop per set&#10;- [x] Enhanced exercise library with rich metadata (34+ exercises)&#10;- [x] Automatic template population on database creation&#10;- [x] Template selection and creation methods&#10;&#10;### Current Architecture Status&#10;- **Exercise Library**: Rich metadata with 34+ exercises in `ExerciseData.getPPLExercises()` ✅&#10;- **Template System**: Complete entities, DAOs, and repository methods ✅&#10;- **Workout Logic**: **Both day-based AND template-based systems working** ✅&#10;- **Database Version**: 7 (with complete template system migration)&#10;- **UI Layer**: Daily workout screens with template integration ✅&#10;&#10;---&#10;&#10;## Phase 1: Core Foundation ✅ **COMPLETED**&#10;&#10;### 1.1 Project Setup &amp; Database ✅&#10;- [x] 1.1.1 Android project with Kotlin &amp; Compose&#10;- [x] 1.1.2 Room database implementation&#10;- [x] 1.1.3 Entity models (WorkoutDay, Exercise, WorkoutEntry, SetEntry)&#10;- [x] 1.1.4 DAO implementations&#10;- [x] 1.1.5 Repository pattern&#10;&#10;### 1.2 Basic UI &amp; Navigation ✅&#10;- [x] 1.2.1 Material Design 3 theme&#10;- [x] 1.2.2 Navigation between screens&#10;- [x] 1.2.3 Daily workout view&#10;- [x] 1.2.4 Exercise list screen&#10;- [x] 1.2.5 Exercise detail screen&#10;&#10;### 1.3 Workout Logic ✅&#10;- [x] 1.3.1 PPL schedule implementation (6-day rotation)&#10;- [x] 1.3.2 Rest day handling with background image&#10;- [x] 1.3.3 Workout day creation and exercise population&#10;- [x] 1.3.4 Set tracking and completion logic&#10;- [x] 1.3.5 Exercise progress tracking&#10;&#10;### 1.4 Timer &amp; Time Tracking ✅ **COMPLETED**&#10;- [x] 1.4.1 Individual set timers (start/stop functionality)&#10;- [x] 1.4.2 Total exercise time calculation&#10;- [x] 1.4.3 Set completion tracking&#10;- [x] 1.4.4 Sequential set unlocking&#10;- [x] 1.4.5 Rest period timer implementation ✅ **FIXED**&#10;- [x] 1.4.6 Proper time formatting (HH:MM:SS) ✅ **FIXED**&#10;&#10;---&#10;&#10;##  **HOTFIX SECTION** ✅ **ALL COMPLETED**&#10;&#10;### Timer &amp; Time Display Issues ✅&#10;- [x] **HF-1**: Fix timer display format (was showing weird increments like 1,3,5,7...)&#10;  - ✅ FIXED: Timer now shows proper HH:MM:SS format&#10;  - ✅ FIXED: Standard stopwatch behavior (00:00:01, 00:00:02, etc.)&#10;&#10;- [x] **HF-2**: Fix total exercise time calculation&#10;  - ✅ FIXED: Total time shows accurate values&#10;  - ✅ FIXED: Consistent time calculations including rest periods&#10;  - ✅ FIXED: Rest time properly captured and added to total&#10;&#10;- [x] **HF-3**: Remove &quot;Mark as Done&quot; button confusion&#10;  - ✅ FIXED: Simplified to Start → Stop → Completed flow&#10;  - ✅ FIXED: Clean UX with single action buttons&#10;&#10;- [x] **HF-4**: Fix total time live updates&#10;  - ✅ FIXED: Total time only updates when set completes&#10;  - ✅ FIXED: No more live updates during active sets&#10;&#10;### UI/UX Improvements ✅&#10;- [x] **HF-5**: Color scheme improvements (black text, yellow accents)&#10;- [x] **HF-6**: Exercise completion state persistence&#10;- [x] **HF-7**: Set counter display accuracy&#10;- [x] **HF-8**: Database reset functionality&#10;&#10;### Rest Timer Implementation ✅ **NEW - COMPLETED**&#10;- [x] **HF-9**: Complete rest timer functionality&#10;  - ✅ FIXED: Rest timer starts automatically after set completion&#10;  - ✅ FIXED: Rest time captured and added to total exercise time&#10;  - ✅ FIXED: Rest timer stops when next set starts&#10;  - ✅ FIXED: Total time = completed set times + accumulated rest time&#10;  - ✅ TESTED: Manual testing confirms expected behavior&#10;&#10;---&#10;&#10;## Phase 2: Set Data Collection &amp; Management  **NEXT PRIORITY**&#10;&#10;### 2.1 Set Performance Data Entry ⭐ **NEW REQUIREMENT**&#10;- [ ] 2.1.1 Add database fields for set performance data&#10;  - Add `reps_performed` (INT) to set_entries table&#10;  - Add `weight_used` (DECIMAL/FLOAT) to set_entries table&#10;  - Create database migration for new fields&#10;  - Update SetEntry entity and DAO methods&#10;&#10;- [ ] 2.1.2 Set completion popup with data entry&#10;  - Create popup/dialog component for set data entry&#10;  - Two required text fields: &quot;Reps Performed&quot; and &quot;Weight Used&quot;&#10;  - Mandatory fields - no cancel button, only &quot;ADD&quot; button&#10;  - Popup appears when user completes a set (stops timer)&#10;  - Rest timer continues running in background during data entry&#10;&#10;- [ ] 2.1.3 Set data persistence and validation&#10;  - Save reps and weight data to database on popup submit&#10;  - Input validation (positive numbers, reasonable ranges)&#10;  - Update set completion flow to include data entry step&#10;  - Handle data persistence errors gracefully&#10;&#10;### 2.2 Set Data Editing &amp; Management  **NEW REQUIREMENT**&#10;- [ ] 2.2.1 Edit completed set data&#10;  - Allow users to edit reps/weight after set completion&#10;  - Add edit button/icon to completed set cards&#10;  - Reopen data entry popup with pre-filled values&#10;  - Update database with edited values&#10;&#10;- [ ] 2.2.2 Dynamic set management&#10;  - Add &quot;+&quot; button to add extra sets to exercise&#10;  - Add &quot;−&quot; button to remove sets from exercise (if not completed)&#10;  - Update exercise completion logic for dynamic set counts&#10;  - Maintain proper set numbering when adding/removing sets&#10;&#10;- [ ] 2.2.3 Enhanced set display&#10;  - Show reps and weight data on set cards&#10;  - Display format: &quot;Set 1: 12 reps @ 135 lbs&quot; (when completed)&#10;  - Show &quot;Set 1: — reps @ — lbs&quot; (when not completed)&#10;  - Visual distinction between completed and pending sets&#10;&#10;### 2.3 Data Validation &amp; UX Improvements  **NEW REQUIREMENT**&#10;- [ ] 2.3.1 Input validation and user guidance&#10;  - Numeric keyboard for reps and weight fields&#10;  - Input hints and placeholders (&quot;e.g., 12&quot;, &quot;e.g., 135.5&quot;)&#10;  - Validation messages for invalid inputs&#10;  - Auto-focus progression between fields&#10;&#10;- [ ] 2.3.2 Set performance analytics&#10;  - Calculate and display total volume per exercise (sets × reps × weight)&#10;  - Show previous set performance for reference&#10;  - Progressive overload indicators (vs last workout)&#10;  - Exercise completion status with performance summary&#10;&#10;- [ ] 2.3.3 Enhanced timer integration&#10;  - Rest timer continues during data entry popup&#10;  - Clear visual indication that rest timer is still running&#10;  - Seamless transition from set completion → data entry → rest period&#10;  - Timer state preservation across popup interactions&#10;&#10;**User Flow Enhancement**:&#10;1. User starts Set 1 → Completes set (stops timer) ✅&#10;2. **NEW**: Data entry popup appears → User enters reps &amp; weight → Clicks ADD&#10;3. Rest timer starts automatically (or continues if already running) ✅&#10;4. User can edit set data anytime by tapping completed set card&#10;5. User can add/remove sets as needed during workout&#10;6. Exercise shows total volume and performance summary&#10;&#10;**Benefits**:&#10;- Comprehensive workout tracking with actual performance data&#10;- Progressive overload tracking (essential for strength training)&#10;- Flexible set management for different workout intensities&#10;- Professional gym app experience with detailed analytics&#10;&#10;---&#10;&#10;## Phase 3: Enhanced Exercise Experience  **PLANNED**&#10;- [ ] 3.1.1 Exercise instruction screens&#10;- [ ] 3.1.2 Exercise tips and form cues&#10;- [ ] 3.1.3 Primary/secondary muscle groups display&#10;- [ ] 3.1.4 Equipment requirements display&#10;- [ ] 3.1.5 Exercise difficulty indicators&#10;&#10;### 3.2 Calendar &amp; History View  **PLANNED**&#10;- [ ] 3.2.1 Calendar navigation&#10;- [ ] 3.2.2 Historical workout data view&#10;- [ ] 3.2.3 Progress tracking over time&#10;- [ ] 3.2.4 Workout completion statistics&#10;&#10;---&#10;&#10;## Phase 4: Advanced Features  **PLANNED**&#10;&#10;### 4.1 Location Services&#10;- [ ] 4.1.1 Gym location detection&#10;- [ ] 4.1.2 Location-based notifications&#10;- [ ] 4.1.3 Gym check-in tracking&#10;&#10;### 4.2 Data Management&#10;- [ ] 4.2.1 Data export functionality&#10;- [ ] 4.2.2 Backup/restore system&#10;- [ ] 4.2.3 30-day data cleanup job&#10;- [ ] 4.2.4 Data migration handling&#10;&#10;### 4.3 Enhanced UX&#10;- [ ] 4.3.1 Dark mode support&#10;- [ ] 4.3.2 Accessibility improvements&#10;- [ ] 4.3.3 Animations and transitions&#10;- [ ] 4.3.4 Haptic feedback&#10;&#10;---&#10;&#10;## Development Status&#10;&#10;### Current Achievement: PHASE 1 COMPLETE! &#10;**Major Milestone**: All core functionality is now solid and reliable!&#10;&#10;✅ **Database &amp; Architecture** - Robust Room implementation&#10;✅ **Timer System** - Professional-grade stopwatch with rest periods&#10;✅ **Workout Flow** - Smooth set progression and completion tracking&#10;✅ **UI/UX Foundation** - Clean, consistent Material Design 3 interface&#10;✅ **Data Persistence** - Reliable workout state management&#10;&#10;### Next Priority: Phase 2.1 - Set Data Collection &amp; Management&#10;**Focus**: Comprehensive workout tracking with performance data&#10;&#10;**Benefits for Users**:&#10;- Track actual reps performed and weight used per set&#10;- Progressive overload monitoring for strength gains&#10;- Flexible set management (add/remove sets during workout)&#10;- Professional workout data collection and analytics&#10;&#10;### Implementation Ready:&#10;The app now has a solid foundation with:&#10;- ✅ Accurate timer system (including rest periods)&#10;- ✅ Reliable data persistence&#10;- ✅ Clean user interface&#10;- ✅ Proper error handling&#10;- ✅ Comprehensive logging for debugging&#10;&#10;**Ready to implement**:&#10;- Database schema updates for reps_performed and weight_used&#10;- Set completion popup with mandatory data entry&#10;- Dynamic set management (+/- buttons)&#10;- Enhanced set display with performance data&#10;&#10;---&#10;&#10;## Testing Status&#10;&#10;### Core Functionality ✅ **ALL VERIFIED**&#10;- [x] App starts without crashes&#10;- [x] Workout creation for current day&#10;- [x] Exercise navigation&#10;- [x] Set completion tracking&#10;- [x] Database persistence&#10;- [x] Timer accuracy and formatting&#10;- [x] Rest timer functionality&#10;- [x] Total time calculations (including rest periods)&#10;&#10;### Ready for Phase 2 Implementation ✅&#10;All Phase 1 requirements have been implemented and tested successfully.&#10;Database and architecture are ready for performance data collection features.&#10;&#10;---&#10;&#10;*Last Updated: July 31, 2025*&#10;*Current Status: Phase 1 Complete ✅ | Ready for Phase 2.1 *" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/dao/SetEntryDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/dao/SetEntryDao.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.data.dao&#10;&#10;import androidx.room.*&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface SetEntryDao {&#10;&#10;    @Query(&quot;SELECT * FROM set_entries WHERE workout_entry_id = :workoutEntryId ORDER BY setNumber&quot;)&#10;    fun getSetsForWorkoutEntry(workoutEntryId: Int): Flow&lt;List&lt;SetEntry&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM set_entries WHERE workout_entry_id = :workoutEntryId ORDER BY setNumber&quot;)&#10;    suspend fun getSetsForWorkoutEntrySync(workoutEntryId: Int): List&lt;SetEntry&gt;&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(sets: List&lt;SetEntry&gt;)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insert(setEntry: SetEntry)&#10;&#10;    @Update&#10;    suspend fun update(setEntry: SetEntry)&#10;&#10;    @Query(&quot;UPDATE set_entries SET isCompleted = :isCompleted, elapsedTimeSeconds = :elapsedTimeSeconds, completedAt = :completedAt WHERE id = :setId&quot;)&#10;    suspend fun updateSetProgress(setId: Int, isCompleted: Boolean, elapsedTimeSeconds: Int, completedAt: Long?)&#10;&#10;    @Query(&quot;DELETE FROM set_entries WHERE workout_entry_id = :workoutEntryId&quot;)&#10;    suspend fun deleteByWorkoutEntryId(workoutEntryId: Int)&#10;&#10;    @Query(&quot;DELETE FROM set_entries&quot;)&#10;    suspend fun deleteAll(): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM set_entries&quot;)&#10;    suspend fun getSetEntryCount(): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM set_entries WHERE workout_entry_id = :workoutEntryId AND isCompleted = 1&quot;)&#10;    suspend fun getCompletedSetsCount(workoutEntryId: Int): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM set_entries WHERE workout_entry_id = :workoutEntryId&quot;)&#10;    suspend fun getTotalSetsCount(workoutEntryId: Int): Int&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.dao&#10;&#10;import androidx.room.*&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface SetEntryDao {&#10;&#10;    @Query(&quot;SELECT * FROM set_entries WHERE workout_entry_id = :workoutEntryId ORDER BY setNumber&quot;)&#10;    fun getSetsForWorkoutEntry(workoutEntryId: Int): Flow&lt;List&lt;SetEntry&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM set_entries WHERE workout_entry_id = :workoutEntryId ORDER BY setNumber&quot;)&#10;    suspend fun getSetsForWorkoutEntrySync(workoutEntryId: Int): List&lt;SetEntry&gt;&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(sets: List&lt;SetEntry&gt;)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insert(setEntry: SetEntry)&#10;&#10;    @Update&#10;    suspend fun update(setEntry: SetEntry)&#10;&#10;    @Query(&quot;UPDATE set_entries SET isCompleted = :isCompleted, elapsedTimeSeconds = :elapsedTimeSeconds, completedAt = :completedAt WHERE id = :setId&quot;)&#10;    suspend fun updateSetProgress(setId: Int, isCompleted: Boolean, elapsedTimeSeconds: Int, completedAt: Long?)&#10;&#10;    //  NEW: Phase 2.1.1 - Methods for handling set performance data&#10;    @Query(&quot;UPDATE set_entries SET isCompleted = :isCompleted, elapsedTimeSeconds = :elapsedTimeSeconds, completedAt = :completedAt, reps_performed = :repsPerformed, weight_used = :weightUsed WHERE id = :setId&quot;)&#10;    suspend fun updateSetProgressWithPerformanceData(&#10;        setId: Int, &#10;        isCompleted: Boolean, &#10;        elapsedTimeSeconds: Int, &#10;        completedAt: Long?,&#10;        repsPerformed: Int?,&#10;        weightUsed: Float?&#10;    )&#10;&#10;    @Query(&quot;UPDATE set_entries SET reps_performed = :repsPerformed, weight_used = :weightUsed WHERE id = :setId&quot;)&#10;    suspend fun updateSetPerformanceData(setId: Int, repsPerformed: Int?, weightUsed: Float?)&#10;&#10;    @Query(&quot;SELECT * FROM set_entries WHERE id = :setId&quot;)&#10;    suspend fun getSetById(setId: Int): SetEntry?&#10;&#10;    @Query(&quot;DELETE FROM set_entries WHERE workout_entry_id = :workoutEntryId&quot;)&#10;    suspend fun deleteByWorkoutEntryId(workoutEntryId: Int)&#10;&#10;    @Query(&quot;DELETE FROM set_entries&quot;)&#10;    suspend fun deleteAll(): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM set_entries&quot;)&#10;    suspend fun getSetEntryCount(): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM set_entries WHERE workout_entry_id = :workoutEntryId AND isCompleted = 1&quot;)&#10;    suspend fun getCompletedSetsCount(workoutEntryId: Int): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM set_entries WHERE workout_entry_id = :workoutEntryId&quot;)&#10;    suspend fun getTotalSetsCount(workoutEntryId: Int): Int&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/dao/WorkoutTemplateDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/dao/WorkoutTemplateDao.kt" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.dao&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.Query&#10;import androidx.room.Update&#10;import androidx.room.Delete&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; * Data Access Object for WorkoutTemplate operations&#10; */&#10;@Dao&#10;interface WorkoutTemplateDao {&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE isActive = 1 ORDER BY category, name&quot;)&#10;    fun getAllActiveTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE category = :category AND isActive = 1 ORDER BY name&quot;)&#10;    fun getTemplatesByCategory(category: String): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE id = :templateId&quot;)&#10;    suspend fun getTemplateById(templateId: Int): WorkoutTemplate?&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE category = :category AND difficulty = :difficulty AND isActive = 1&quot;)&#10;    suspend fun getTemplatesByCategoryAndDifficulty(category: String, difficulty: String): List&lt;WorkoutTemplate&gt;&#10;&#10;    @Insert&#10;    suspend fun insertTemplate(template: WorkoutTemplate): Long&#10;&#10;    @Insert&#10;    suspend fun insertTemplates(templates: List&lt;WorkoutTemplate&gt;)&#10;&#10;    @Update&#10;    suspend fun updateTemplate(template: WorkoutTemplate)&#10;&#10;    @Delete&#10;    suspend fun deleteTemplate(template: WorkoutTemplate)&#10;&#10;    @Query(&quot;DELETE FROM workout_templates&quot;)&#10;    suspend fun deleteAll(): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM workout_templates&quot;)&#10;    suspend fun getTemplateCount(): Int&#10;&#10;    @Query(&quot;UPDATE workout_templates SET lastUsedDate = :date WHERE id = :templateId&quot;)&#10;    suspend fun updateLastUsedDate(templateId: Int, date: String)&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE isCustom = 1 AND isActive = 1 ORDER BY name&quot;)&#10;    fun getCustomTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM workout_templates WHERE isCustom = 0 AND isActive = 1 ORDER BY category, name&quot;)&#10;    fun getPredefinedTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/database/PPLWorkoutDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/database/PPLWorkoutDatabase.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.data.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import android.content.Context&#10;import com.example.offlinepplworkoutapp.data.dao.ExerciseDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutDayDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.SetEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutTemplateDao&#10;import com.example.offlinepplworkoutapp.data.dao.TemplateExerciseDao&#10;import com.example.offlinepplworkoutapp.data.entity.Exercise&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutDay&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import com.example.offlinepplworkoutapp.data.entity.TemplateExercise&#10;import com.example.offlinepplworkoutapp.data.ExerciseData&#10;import com.example.offlinepplworkoutapp.data.PPLTemplateData&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;&#10;@Database(&#10;    entities = [Exercise::class, WorkoutDay::class, WorkoutEntry::class, SetEntry::class, WorkoutTemplate::class, TemplateExercise::class],&#10;    version = 7,  // Updated from 6 to 7 for template system&#10;    exportSchema = false&#10;)&#10;abstract class PPLWorkoutDatabase : RoomDatabase() {&#10;&#10;    abstract fun exerciseDao(): ExerciseDao&#10;    abstract fun workoutDayDao(): WorkoutDayDao&#10;    abstract fun workoutEntryDao(): WorkoutEntryDao&#10;    abstract fun setEntryDao(): SetEntryDao&#10;    abstract fun workoutTemplateDao(): WorkoutTemplateDao&#10;    abstract fun templateExerciseDao(): TemplateExerciseDao&#10;&#10;    private class PPLWorkoutDatabaseCallback : RoomDatabase.Callback() {&#10;&#10;        override fun onCreate(db: SupportSQLiteDatabase) {&#10;            super.onCreate(db)&#10;            INSTANCE?.let { database -&gt;&#10;                CoroutineScope(Dispatchers.IO).launch {&#10;                    populateDatabase(database.exerciseDao())&#10;                    populateTemplates(database.workoutTemplateDao(), database.templateExerciseDao())&#10;                }&#10;            }&#10;        }&#10;&#10;        override fun onOpen(db: SupportSQLiteDatabase) {&#10;            super.onOpen(db)&#10;            // Ensure exercises and templates are populated even if database already exists&#10;            INSTANCE?.let { database -&gt;&#10;                CoroutineScope(Dispatchers.IO).launch {&#10;                    val exerciseCount = database.exerciseDao().getExerciseCount()&#10;                    if (exerciseCount == 0) {&#10;                        populateDatabase(database.exerciseDao())&#10;                    }&#10;&#10;                    val templateCount = database.workoutTemplateDao().getTemplateCount()&#10;                    if (templateCount == 0) {&#10;                        populateTemplates(database.workoutTemplateDao(), database.templateExerciseDao())&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        suspend fun populateDatabase(exerciseDao: ExerciseDao) {&#10;            // Clear existing data&#10;            exerciseDao.deleteAll()&#10;&#10;            // Insert PPL exercises&#10;            val exercises = getPPLExercises()&#10;            exerciseDao.insertAll(exercises)&#10;        }&#10;&#10;        suspend fun populateTemplates(templateDao: WorkoutTemplateDao, templateExerciseDao: TemplateExerciseDao) {&#10;            // Clear existing template data&#10;            templateExerciseDao.deleteAll()&#10;            templateDao.deleteAll()&#10;&#10;            // Insert PPL templates&#10;            val templates = PPLTemplateData.getPPLTemplates()&#10;            templateDao.insertTemplates(templates)&#10;&#10;            // Insert template exercises&#10;            val templateExercises = PPLTemplateData.getTemplateExercises()&#10;            templateExerciseDao.insertTemplateExercises(templateExercises)&#10;&#10;            println(&quot;️ DATABASE: Successfully populated ${templates.size} templates with ${templateExercises.size} template exercises&quot;)&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: PPLWorkoutDatabase? = null&#10;&#10;        // Migration from version 6 to 7 - Add WorkoutTemplate and TemplateExercise tables&#10;        val MIGRATION_6_7 = object : Migration(6, 7) {&#10;            override fun migrate(database: SupportSQLiteDatabase) {&#10;                println(&quot; MIGRATION: Starting migration from v6 to v7...&quot;)&#10;&#10;                // Create WorkoutTemplate table&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE IF NOT EXISTS `workout_templates` (&#10;                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,&#10;                        `name` TEXT NOT NULL,&#10;                        `description` TEXT NOT NULL,&#10;                        `estimatedDuration` INTEGER NOT NULL,&#10;                        `difficulty` TEXT NOT NULL,&#10;                        `category` TEXT NOT NULL,&#10;                        `isCustom` INTEGER NOT NULL DEFAULT 0,&#10;                        `isActive` INTEGER NOT NULL DEFAULT 1,&#10;                        `createdDate` TEXT NOT NULL DEFAULT '',&#10;                        `lastUsedDate` TEXT NOT NULL DEFAULT ''&#10;                    )&#10;                &quot;&quot;&quot;.trimIndent())&#10;&#10;                // Create TemplateExercise table&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE IF NOT EXISTS `template_exercises` (&#10;                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,&#10;                        `templateId` INTEGER NOT NULL,&#10;                        `exerciseId` INTEGER NOT NULL,&#10;                        `orderIndex` INTEGER NOT NULL,&#10;                        `sets` INTEGER NOT NULL,&#10;                        `reps` INTEGER NOT NULL,&#10;                        `restSeconds` INTEGER NOT NULL,&#10;                        `weight` REAL NOT NULL DEFAULT 0.0,&#10;                        `notes` TEXT NOT NULL DEFAULT '',&#10;                        `isSuperset` INTEGER NOT NULL DEFAULT 0,&#10;                        `supersetGroup` INTEGER NOT NULL DEFAULT 0,&#10;                        FOREIGN KEY(`templateId`) REFERENCES `workout_templates`(`id`) ON DELETE CASCADE,&#10;                        FOREIGN KEY(`exerciseId`) REFERENCES `exercises`(`id`) ON DELETE CASCADE&#10;                    )&#10;                &quot;&quot;&quot;.trimIndent())&#10;&#10;                println(&quot; MIGRATION: Successfully created WorkoutTemplate and TemplateExercise tables&quot;)&#10;            }&#10;        }&#10;&#10;        fun getDatabase(context: Context): PPLWorkoutDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    PPLWorkoutDatabase::class.java,&#10;                    &quot;ppl_workout_database&quot;&#10;                )&#10;                    .addCallback(PPLWorkoutDatabaseCallback())&#10;                    .addMigrations(MIGRATION_6_7)  // Fixed: use addMigrations instead of addMigration&#10;                    .fallbackToDestructiveMigration()&#10;                    // Force database recreation to ensure clean state&#10;                    .build()&#10;&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;&#10;        // Reset database method - clears workout progress while preserving exercise definitions&#10;        suspend fun resetDatabase() {&#10;            INSTANCE?.let { database -&gt;&#10;                // Clear all user workout data directly (we're already in a suspend function)&#10;                database.workoutDayDao().deleteAll()&#10;                database.workoutEntryDao().deleteAll()&#10;                database.setEntryDao().deleteAll()&#10;&#10;                // Force close and invalidate all active connections to clear cache&#10;                database.clearAllTables()&#10;                database.invalidationTracker.refreshVersionsAsync()&#10;&#10;                // Note: We're not deleting exercises since that would remove the exercise library&#10;            }&#10;        }&#10;&#10;        // Method to completely reset the database instance (more aggressive)&#10;        suspend fun forceResetDatabase(context: Context) {&#10;            println(&quot; RESET: Starting forceResetDatabase...&quot;)&#10;&#10;            INSTANCE?.let { database -&gt;&#10;                println(&quot; RESET: Clearing all data from existing database...&quot;)&#10;&#10;                try {&#10;                    // Run database operations on IO dispatcher to avoid main thread issues&#10;                    withContext(Dispatchers.IO) {&#10;                        // Clear all data and log the results&#10;                        val workoutDaysDeleted = database.workoutDayDao().deleteAll()&#10;                        val workoutEntriesDeleted = database.workoutEntryDao().deleteAll()&#10;                        val setEntriesDeleted = database.setEntryDao().deleteAll()&#10;&#10;                        println(&quot; RESET: Deleted $workoutDaysDeleted workout days&quot;)&#10;                        println(&quot; RESET: Deleted $workoutEntriesDeleted workout entries&quot;)&#10;                        println(&quot; RESET: Deleted $setEntriesDeleted set entries&quot;)&#10;&#10;                        // Use the public API for invalidation instead of restricted refreshVersionsSync&#10;                        database.invalidationTracker.refreshVersionsAsync()&#10;                        println(&quot; RESET: Invalidated all cached queries (async)&quot;)&#10;&#10;                        // Clear all tables to reset Room's internal state&#10;                        database.clearAllTables()&#10;                        println(&quot; RESET: Cleared all Room tables&quot;)&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    println(&quot; RESET ERROR: ${e.message}&quot;)&#10;&#10;                    // If we get errors, fall back to recreating the database&#10;                    try {&#10;                        database.close()&#10;                        println(&quot; RESET: Closed database due to errors&quot;)&#10;                    } catch (closeError: Exception) {&#10;                        println(&quot; RESET: Error closing database: ${closeError.message}&quot;)&#10;                    }&#10;&#10;                    // Clear the singleton instance to force recreation&#10;                    INSTANCE = null&#10;                    println(&quot; RESET: Database instance cleared for recreation&quot;)&#10;                }&#10;            }&#10;&#10;            if (INSTANCE == null) {&#10;                // Force garbage collection to clear any remaining references&#10;                System.gc()&#10;                println(&quot; RESET: Garbage collection forced&quot;)&#10;&#10;                // Recreate the database instance&#10;                getDatabase(context)&#10;                println(&quot; RESET: Database recreated&quot;)&#10;            }&#10;&#10;            println(&quot; RESET: Reset complete&quot;)&#10;        }&#10;&#10;        // Method to verify database is empty (for debugging)&#10;        suspend fun verifyDatabaseEmpty(): Triple&lt;Int, Int, Int&gt; {&#10;            return INSTANCE?.let { database -&gt;&#10;                val workoutDays = database.workoutDayDao().getWorkoutDayCount()&#10;                val workoutEntries = database.workoutEntryDao().getWorkoutEntryCount()&#10;                val setEntries = database.setEntryDao().getSetEntryCount()&#10;                println(&quot; VERIFY: WorkoutDays: $workoutDays, WorkoutEntries: $workoutEntries, SetEntries: $setEntries&quot;)&#10;                Triple(workoutDays, workoutEntries, setEntries)&#10;            } ?: Triple(0, 0, 0)&#10;        }&#10;&#10;        // Method to force populate exercises when they're missing&#10;        suspend fun forcePopulateExercises() {&#10;            INSTANCE?.let { database -&gt;&#10;                println(&quot;️ DATABASE: Force populating exercises...&quot;)&#10;                try {&#10;                    val exerciseDao = database.exerciseDao()&#10;                    val exercises = ExerciseData.getPPLExercises() // Use new rich exercise data&#10;&#10;                    // Clear any existing exercises and insert fresh ones&#10;                    exerciseDao.deleteAll()&#10;                    exerciseDao.insertAll(exercises)&#10;&#10;                    println(&quot;️ DATABASE: Successfully inserted ${exercises.size} exercises&quot;)&#10;                } catch (e: Exception) {&#10;                    println(&quot;️ DATABASE ERROR: Failed to populate exercises - ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        private fun getPPLExercises(): List&lt;Exercise&gt; {&#10;            // Delegate to the new ExerciseData class for better organization&#10;            return ExerciseData.getPPLExercises()&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import android.content.Context&#10;import com.example.offlinepplworkoutapp.data.dao.ExerciseDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutDayDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.SetEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutTemplateDao&#10;import com.example.offlinepplworkoutapp.data.dao.TemplateExerciseDao&#10;import com.example.offlinepplworkoutapp.data.entity.Exercise&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutDay&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import com.example.offlinepplworkoutapp.data.entity.TemplateExercise&#10;import com.example.offlinepplworkoutapp.data.ExerciseData&#10;import com.example.offlinepplworkoutapp.data.PPLTemplateData&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;&#10;@Database(&#10;    entities = [Exercise::class, WorkoutDay::class, WorkoutEntry::class, SetEntry::class, WorkoutTemplate::class, TemplateExercise::class],&#10;    version = 8,  //  NEW: Updated from 7 to 8 for set performance data fields&#10;    exportSchema = false&#10;)&#10;abstract class PPLWorkoutDatabase : RoomDatabase() {&#10;&#10;    abstract fun exerciseDao(): ExerciseDao&#10;    abstract fun workoutDayDao(): WorkoutDayDao&#10;    abstract fun workoutEntryDao(): WorkoutEntryDao&#10;    abstract fun setEntryDao(): SetEntryDao&#10;    abstract fun workoutTemplateDao(): WorkoutTemplateDao&#10;    abstract fun templateExerciseDao(): TemplateExerciseDao&#10;&#10;    private class PPLWorkoutDatabaseCallback : RoomDatabase.Callback() {&#10;&#10;        override fun onCreate(db: SupportSQLiteDatabase) {&#10;            super.onCreate(db)&#10;            INSTANCE?.let { database -&gt;&#10;                CoroutineScope(Dispatchers.IO).launch {&#10;                    populateDatabase(database.exerciseDao())&#10;                    populateTemplates(database.workoutTemplateDao(), database.templateExerciseDao())&#10;                }&#10;            }&#10;        }&#10;&#10;        override fun onOpen(db: SupportSQLiteDatabase) {&#10;            super.onOpen(db)&#10;            // Ensure exercises and templates are populated even if database already exists&#10;            INSTANCE?.let { database -&gt;&#10;                CoroutineScope(Dispatchers.IO).launch {&#10;                    val exerciseCount = database.exerciseDao().getExerciseCount()&#10;                    if (exerciseCount == 0) {&#10;                        populateDatabase(database.exerciseDao())&#10;                    }&#10;&#10;                    val templateCount = database.workoutTemplateDao().getTemplateCount()&#10;                    if (templateCount == 0) {&#10;                        populateTemplates(database.workoutTemplateDao(), database.templateExerciseDao())&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        suspend fun populateDatabase(exerciseDao: ExerciseDao) {&#10;            // Clear existing data&#10;            exerciseDao.deleteAll()&#10;&#10;            // Insert PPL exercises&#10;            val exercises = getPPLExercises()&#10;            exerciseDao.insertAll(exercises)&#10;        }&#10;&#10;        suspend fun populateTemplates(templateDao: WorkoutTemplateDao, templateExerciseDao: TemplateExerciseDao) {&#10;            // Clear existing template data&#10;            templateExerciseDao.deleteAll()&#10;            templateDao.deleteAll()&#10;&#10;            // Insert PPL templates&#10;            val templates = PPLTemplateData.getPPLTemplates()&#10;            templateDao.insertTemplates(templates)&#10;&#10;            // Insert template exercises&#10;            val templateExercises = PPLTemplateData.getTemplateExercises()&#10;            templateExerciseDao.insertTemplateExercises(templateExercises)&#10;&#10;            println(&quot;️ DATABASE: Successfully populated ${templates.size} templates with ${templateExercises.size} template exercises&quot;)&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: PPLWorkoutDatabase? = null&#10;&#10;        // Migration from version 6 to 7 - Add WorkoutTemplate and TemplateExercise tables&#10;        val MIGRATION_6_7 = object : Migration(6, 7) {&#10;            override fun migrate(database: SupportSQLiteDatabase) {&#10;                println(&quot; MIGRATION: Starting migration from v6 to v7...&quot;)&#10;&#10;                // Create WorkoutTemplate table&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE IF NOT EXISTS `workout_templates` (&#10;                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,&#10;                        `name` TEXT NOT NULL,&#10;                        `description` TEXT NOT NULL,&#10;                        `estimatedDuration` INTEGER NOT NULL,&#10;                        `difficulty` TEXT NOT NULL,&#10;                        `category` TEXT NOT NULL,&#10;                        `isCustom` INTEGER NOT NULL DEFAULT 0,&#10;                        `isActive` INTEGER NOT NULL DEFAULT 1,&#10;                        `createdDate` TEXT NOT NULL DEFAULT '',&#10;                        `lastUsedDate` TEXT NOT NULL DEFAULT ''&#10;                    )&#10;                &quot;&quot;&quot;.trimIndent())&#10;&#10;                // Create TemplateExercise table&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE IF NOT EXISTS `template_exercises` (&#10;                        `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,&#10;                        `templateId` INTEGER NOT NULL,&#10;                        `exerciseId` INTEGER NOT NULL,&#10;                        `orderIndex` INTEGER NOT NULL,&#10;                        `sets` INTEGER NOT NULL,&#10;                        `reps` INTEGER NOT NULL,&#10;                        `restSeconds` INTEGER NOT NULL,&#10;                        `weight` REAL NOT NULL DEFAULT 0.0,&#10;                        `notes` TEXT NOT NULL DEFAULT '',&#10;                        `isSuperset` INTEGER NOT NULL DEFAULT 0,&#10;                        `supersetGroup` INTEGER NOT NULL DEFAULT 0,&#10;                        FOREIGN KEY(`templateId`) REFERENCES `workout_templates`(`id`) ON DELETE CASCADE,&#10;                        FOREIGN KEY(`exerciseId`) REFERENCES `exercises`(`id`) ON DELETE CASCADE&#10;                    )&#10;                &quot;&quot;&quot;.trimIndent())&#10;&#10;                println(&quot; MIGRATION: Successfully created WorkoutTemplate and TemplateExercise tables&quot;)&#10;            }&#10;        }&#10;&#10;        //  NEW: Migration from version 7 to 8 - Add set performance data fields&#10;        val MIGRATION_7_8 = object : Migration(7, 8) {&#10;            override fun migrate(database: SupportSQLiteDatabase) {&#10;                println(&quot; MIGRATION: Starting migration from v7 to v8...&quot;)&#10;&#10;                // Add reps_performed column to set_entries table&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    ALTER TABLE set_entries ADD COLUMN reps_performed INTEGER&#10;                &quot;&quot;&quot;.trimIndent())&#10;&#10;                // Add weight_used column to set_entries table&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    ALTER TABLE set_entries ADD COLUMN weight_used REAL&#10;                &quot;&quot;&quot;.trimIndent())&#10;&#10;                println(&quot; MIGRATION: Successfully added reps_performed and weight_used columns to set_entries table&quot;)&#10;                println(&quot; MIGRATION v7→v8: Set performance data fields are now available!&quot;)&#10;            }&#10;        }&#10;&#10;        fun getDatabase(context: Context): PPLWorkoutDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    PPLWorkoutDatabase::class.java,&#10;                    &quot;ppl_workout_database&quot;&#10;                )&#10;                    .addCallback(PPLWorkoutDatabaseCallback())&#10;                    .addMigrations(MIGRATION_6_7, MIGRATION_7_8)  // Fixed: use addMigrations instead of addMigration&#10;                    .fallbackToDestructiveMigration()&#10;                    // Force database recreation to ensure clean state&#10;                    .build()&#10;&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;&#10;        // Reset database method - clears workout progress while preserving exercise definitions&#10;        suspend fun resetDatabase() {&#10;            INSTANCE?.let { database -&gt;&#10;                // Clear all user workout data directly (we're already in a suspend function)&#10;                database.workoutDayDao().deleteAll()&#10;                database.workoutEntryDao().deleteAll()&#10;                database.setEntryDao().deleteAll()&#10;&#10;                // Force close and invalidate all active connections to clear cache&#10;                database.clearAllTables()&#10;                database.invalidationTracker.refreshVersionsAsync()&#10;&#10;                // Note: We're not deleting exercises since that would remove the exercise library&#10;            }&#10;        }&#10;&#10;        // Method to completely reset the database instance (more aggressive)&#10;        suspend fun forceResetDatabase(context: Context) {&#10;            println(&quot; RESET: Starting forceResetDatabase...&quot;)&#10;&#10;            INSTANCE?.let { database -&gt;&#10;                println(&quot; RESET: Clearing all data from existing database...&quot;)&#10;&#10;                try {&#10;                    // Run database operations on IO dispatcher to avoid main thread issues&#10;                    withContext(Dispatchers.IO) {&#10;                        // Clear all data and log the results&#10;                        val workoutDaysDeleted = database.workoutDayDao().deleteAll()&#10;                        val workoutEntriesDeleted = database.workoutEntryDao().deleteAll()&#10;                        val setEntriesDeleted = database.setEntryDao().deleteAll()&#10;&#10;                        println(&quot; RESET: Deleted $workoutDaysDeleted workout days&quot;)&#10;                        println(&quot; RESET: Deleted $workoutEntriesDeleted workout entries&quot;)&#10;                        println(&quot; RESET: Deleted $setEntriesDeleted set entries&quot;)&#10;&#10;                        // Use the public API for invalidation instead of restricted refreshVersionsSync&#10;                        database.invalidationTracker.refreshVersionsAsync()&#10;                        println(&quot; RESET: Invalidated all cached queries (async)&quot;)&#10;&#10;                        // Clear all tables to reset Room's internal state&#10;                        database.clearAllTables()&#10;                        println(&quot; RESET: Cleared all Room tables&quot;)&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    println(&quot; RESET ERROR: ${e.message}&quot;)&#10;&#10;                    // If we get errors, fall back to recreating the database&#10;                    try {&#10;                        database.close()&#10;                        println(&quot; RESET: Closed database due to errors&quot;)&#10;                    } catch (closeError: Exception) {&#10;                        println(&quot; RESET: Error closing database: ${closeError.message}&quot;)&#10;                    }&#10;&#10;                    // Clear the singleton instance to force recreation&#10;                    INSTANCE = null&#10;                    println(&quot; RESET: Database instance cleared for recreation&quot;)&#10;                }&#10;            }&#10;&#10;            if (INSTANCE == null) {&#10;                // Force garbage collection to clear any remaining references&#10;                System.gc()&#10;                println(&quot; RESET: Garbage collection forced&quot;)&#10;&#10;                // Recreate the database instance&#10;                getDatabase(context)&#10;                println(&quot; RESET: Database recreated&quot;)&#10;            }&#10;&#10;            println(&quot; RESET: Reset complete&quot;)&#10;        }&#10;&#10;        // Method to verify database is empty (for debugging)&#10;        suspend fun verifyDatabaseEmpty(): Triple&lt;Int, Int, Int&gt; {&#10;            return INSTANCE?.let { database -&gt;&#10;                val workoutDays = database.workoutDayDao().getWorkoutDayCount()&#10;                val workoutEntries = database.workoutEntryDao().getWorkoutEntryCount()&#10;                val setEntries = database.setEntryDao().getSetEntryCount()&#10;                println(&quot; VERIFY: WorkoutDays: $workoutDays, WorkoutEntries: $workoutEntries, SetEntries: $setEntries&quot;)&#10;                Triple(workoutDays, workoutEntries, setEntries)&#10;            } ?: Triple(0, 0, 0)&#10;        }&#10;&#10;        // Method to force populate exercises when they're missing&#10;        suspend fun forcePopulateExercises() {&#10;            INSTANCE?.let { database -&gt;&#10;                println(&quot;️ DATABASE: Force populating exercises...&quot;)&#10;                try {&#10;                    val exerciseDao = database.exerciseDao()&#10;                    val exercises = ExerciseData.getPPLExercises() // Use new rich exercise data&#10;&#10;                    // Clear any existing exercises and insert fresh ones&#10;                    exerciseDao.deleteAll()&#10;                    exerciseDao.insertAll(exercises)&#10;&#10;                    println(&quot;️ DATABASE: Successfully inserted ${exercises.size} exercises&quot;)&#10;                } catch (e: Exception) {&#10;                    println(&quot;️ DATABASE ERROR: Failed to populate exercises - ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        private fun getPPLExercises(): List&lt;Exercise&gt; {&#10;            // Delegate to the new ExerciseData class for better organization&#10;            return ExerciseData.getPPLExercises()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/entity/SetEntry.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/entity/SetEntry.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.data.entity&#10;&#10;import androidx.room.ColumnInfo&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(&#10;    tableName = &quot;set_entries&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = WorkoutEntry::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;workout_entry_id&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        )&#10;    ],&#10;    indices = [&#10;        Index(value = [&quot;workout_entry_id&quot;])&#10;    ]&#10;)&#10;data class SetEntry(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    @ColumnInfo(name = &quot;workout_entry_id&quot;)&#10;    val workoutEntryId: Int,&#10;    val setNumber: Int, // 1, 2, 3, 4...&#10;    val isCompleted: Boolean = false,&#10;    val elapsedTimeSeconds: Int = 0, // Time spent on this specific set&#10;    val completedAt: Long? = null // Timestamp when set was completed&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.entity&#10;&#10;import androidx.room.ColumnInfo&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(&#10;    tableName = &quot;set_entries&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = WorkoutEntry::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;workout_entry_id&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        )&#10;    ],&#10;    indices = [&#10;        Index(value = [&quot;workout_entry_id&quot;])&#10;    ]&#10;)&#10;data class SetEntry(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    @ColumnInfo(name = &quot;workout_entry_id&quot;)&#10;    val workoutEntryId: Int,&#10;    val setNumber: Int, // 1, 2, 3, 4...&#10;    val isCompleted: Boolean = false,&#10;    val elapsedTimeSeconds: Int = 0, // Time spent on this specific set&#10;    val completedAt: Long? = null, // Timestamp when set was completed&#10;    //  NEW: Phase 2.1.1 - Set performance data fields&#10;    @ColumnInfo(name = &quot;reps_performed&quot;)&#10;    val repsPerformed: Int? = null, // Actual reps completed by user&#10;    @ColumnInfo(name = &quot;weight_used&quot;)&#10;    val weightUsed: Float? = null // Weight used for this set (in user's preferred unit)&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/repository/WorkoutRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/data/repository/WorkoutRepository.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.data.repository&#10;&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutDayDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.SetEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutTemplateDao&#10;import com.example.offlinepplworkoutapp.data.dao.TemplateExerciseDao&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutDay&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import com.example.offlinepplworkoutapp.data.PPLTemplateData&#10;import kotlinx.coroutines.flow.Flow&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class WorkoutRepository(&#10;    private val workoutDayDao: WorkoutDayDao,&#10;    private val workoutEntryDao: WorkoutEntryDao,&#10;    private val setEntryDao: SetEntryDao,&#10;    private val workoutTemplateDao: WorkoutTemplateDao,&#10;    private val templateExerciseDao: TemplateExerciseDao&#10;) {&#10;&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;&#10;    // ===========================================&#10;    // TEMPLATE-BASED WORKOUT CREATION (NEW)&#10;    // ===========================================&#10;&#10;    /**&#10;     * Create workout from template - Main template-based workout creation method&#10;     * This replaces the hardcoded day-based logic with flexible template system&#10;     */&#10;    suspend fun createWorkoutFromTemplate(templateId: Int, date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        println(&quot; REPO: Creating workout from template $templateId for date: $date&quot;)&#10;&#10;        // Get or create workout day&#10;        val workoutDay = getOrCreateWorkoutDayOnly(date)&#10;&#10;        // Check if this day already has exercises&#10;        val existingEntries = workoutEntryDao.getWorkoutEntriesForDaySync(workoutDay.id)&#10;        if (existingEntries.isNotEmpty()) {&#10;            println(&quot; REPO: Found existing workout day with ${existingEntries.size} exercises&quot;)&#10;            return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        }&#10;&#10;        // Get template exercises&#10;        val templateExercises = templateExerciseDao.getExercisesForTemplate(templateId)&#10;        println(&quot; REPO: Got ${templateExercises.size} exercises for template $templateId&quot;)&#10;&#10;        if (templateExercises.isNotEmpty()) {&#10;            // Create workout entries from template&#10;            val entries = templateExercises.map { templateExercise -&gt;&#10;                WorkoutEntry(&#10;                    dayId = workoutDay.id,&#10;                    exerciseId = templateExercise.exerciseId,&#10;                    sets = templateExercise.sets,&#10;                    reps = templateExercise.reps&#10;                )&#10;            }&#10;&#10;            workoutEntryDao.insertAll(entries)&#10;            println(&quot; REPO: Inserted ${entries.size} workout entries from template&quot;)&#10;&#10;            // Create sets for each workout entry&#10;            val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(workoutDay.id)&#10;            createSetsForEntries(insertedEntries)&#10;&#10;            // Update template last used date&#10;            workoutTemplateDao.updateLastUsedDate(templateId, date)&#10;        }&#10;&#10;        return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;    }&#10;&#10;    /**&#10;     * Create today's workout using template-based system&#10;     * Automatically determines which template to use based on day of week&#10;     */&#10;    suspend fun createTodaysWorkoutFromTemplate(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        val templateId = getTemplateIdForDate(today)&#10;&#10;        return if (templateId &gt; 0) {&#10;            createWorkoutFromTemplate(templateId, today)&#10;        } else {&#10;            // Rest day - return empty workout&#10;            println(&quot; REPO: Rest day - no template needed&quot;)&#10;            workoutEntryDao.getWorkoutEntriesForDay(0) // Returns empty flow&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get template ID for a given date based on day of week&#10;     * This maintains compatibility with current PPL schedule&#10;     */&#10;    private fun getTemplateIdForDate(date: String): Int {&#10;        val calendar = Calendar.getInstance()&#10;        calendar.time = dateFormat.parse(date) ?: Date()&#10;        val dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK)&#10;&#10;        return PPLTemplateData.getTemplateIdForDayOfWeek(dayOfWeek)&#10;    }&#10;&#10;    /**&#10;     * Get available templates for user selection&#10;     */&#10;    fun getAvailableTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt; {&#10;        return workoutTemplateDao.getAllActiveTemplates()&#10;    }&#10;&#10;    /**&#10;     * Get templates by category (Push/Pull/Legs)&#10;     */&#10;    fun getTemplatesByCategory(category: String): Flow&lt;List&lt;WorkoutTemplate&gt;&gt; {&#10;        return workoutTemplateDao.getTemplatesByCategory(category)&#10;    }&#10;&#10;    // ===========================================&#10;    // LEGACY DAY-BASED METHODS (PRESERVED)&#10;    // ===========================================&#10;&#10;    suspend fun getTodaysWorkout(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        val workoutDay = getOrCreateWorkoutDay(today)&#10;        return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;    }&#10;&#10;    suspend fun getWorkoutForDate(date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val workoutDay = getOrCreateWorkoutDay(date)&#10;        return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;    }&#10;&#10;    private suspend fun getOrCreateWorkoutDay(date: String): WorkoutDay {&#10;        return workoutDayDao.getWorkoutDayByDate(date)&#10;            ?: createWorkoutDayWithExercises(date)&#10;    }&#10;&#10;    private suspend fun createWorkoutDayWithExercises(date: String): WorkoutDay {&#10;        // Create workout day&#10;        val workoutDay = WorkoutDay(date = date)&#10;        val dayId = workoutDayDao.insert(workoutDay).toInt()&#10;        val createdDay = workoutDay.copy(id = dayId)&#10;&#10;        // Determine workout type based on date&#10;        val workoutType = getWorkoutTypeForDate(date)&#10;        val exercises = getExercisesForWorkoutType(workoutType)&#10;&#10;        // Debug logging to see what's happening&#10;        println(&quot;DEBUG: Creating workout for date: $date, type: $workoutType, exercises count: ${exercises.size}&quot;)&#10;&#10;        // Only create entries if we have exercises for this workout type&#10;        if (exercises.isNotEmpty()) {&#10;            // Create workout entries&#10;            val entries = exercises.map { (exerciseId, sets, reps) -&gt;&#10;                WorkoutEntry(&#10;                    dayId = dayId,&#10;                    exerciseId = exerciseId,&#10;                    sets = sets,&#10;                    reps = reps&#10;                )&#10;            }&#10;&#10;            workoutEntryDao.insertAll(entries)&#10;            println(&quot;DEBUG: Inserted ${entries.size} workout entries for day $date&quot;)&#10;&#10;            //  FIX: Create sets for each workout entry immediately&#10;            // Since we just inserted the entries, we can use the entries we created&#10;            // and get their IDs after insertion&#10;            val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(dayId)&#10;            println(&quot; REPO: Retrieved ${insertedEntries.size} inserted entries to create sets&quot;)&#10;&#10;            for (entry in insertedEntries) {&#10;                println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;                // Create individual sets for each exercise&#10;                createSetsForWorkoutEntry(entry.id, entry.sets)&#10;                println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;                // Verify sets were created&#10;                val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;                println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;                createdSets.forEach { set -&gt;&#10;                    println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;                }&#10;            }&#10;&#10;            println(&quot; REPO: All sets created for ${insertedEntries.size} exercises&quot;)&#10;        } else {&#10;            println(&quot;DEBUG: No exercises found for workout type: $workoutType on date: $date&quot;)&#10;        }&#10;&#10;        return createdDay&#10;    }&#10;&#10;    private fun getWorkoutTypeForDate(date: String): WorkoutType {&#10;        val calendar = Calendar.getInstance()&#10;        calendar.time = dateFormat.parse(date) ?: Date()&#10;        val dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) // Sunday = 1, Saturday = 7&#10;&#10;        return when (dayOfWeek) {&#10;            Calendar.MONDAY -&gt; WorkoutType.PUSH_1&#10;            Calendar.TUESDAY -&gt; WorkoutType.PULL_1&#10;            Calendar.WEDNESDAY -&gt; WorkoutType.LEGS_1&#10;            Calendar.THURSDAY -&gt; WorkoutType.PUSH_2&#10;            Calendar.FRIDAY -&gt; WorkoutType.PULL_2&#10;            Calendar.SATURDAY -&gt; WorkoutType.LEGS_2&#10;            Calendar.SUNDAY -&gt; WorkoutType.REST&#10;            else -&gt; WorkoutType.REST&#10;        }&#10;    }&#10;&#10;    private fun getExercisesForWorkoutType(workoutType: WorkoutType): List&lt;Triple&lt;Int, Int, Int&gt;&gt; {&#10;        return when (workoutType) {&#10;            WorkoutType.PUSH_1 -&gt; listOf(&#10;                Triple(1, 4, 8),   // Barbell Bench Press - 4x6-8 reps&#10;                Triple(2, 3, 10),  // Standing Overhead Press - 3x8-10 reps&#10;                Triple(3, 3, 12),  // Incline Dumbbell Press - 3x8-12 reps&#10;                Triple(4, 3, 15),  // Dumbbell Lateral Raise - 3x12-15 reps&#10;                Triple(5, 3, 12)   // Cable Triceps Pushdown - 3x10-12 reps&#10;            )&#10;            WorkoutType.PULL_1 -&gt; listOf(&#10;                Triple(6, 3, 8),   // Deadlift - 3x5-8 reps&#10;                Triple(7, 3, 10),  // Pull-Ups or Lat Pulldowns - 3x8-10 reps&#10;                Triple(8, 3, 12),  // Bent-Over Barbell Row - 3x8-12 reps&#10;                Triple(9, 3, 15),  // Face Pull - 3x12-15 reps&#10;                Triple(10, 3, 12), // Barbell Biceps Curl - 3x8-12 reps&#10;                Triple(11, 2, 12)  // Hammer Curl - 2x10-12 reps&#10;            )&#10;            WorkoutType.LEGS_1 -&gt; listOf(&#10;                Triple(12, 4, 8),  // Back Squat - 4x6-8 reps&#10;                Triple(13, 3, 12), // Romanian Deadlift - 3x8-12 reps&#10;                Triple(14, 3, 12), // Leg Press - 3x10-12 reps&#10;                Triple(15, 3, 12), // Lying Leg Curl - 3x10-12 reps&#10;                Triple(16, 4, 15)  // Seated Calf Raise - 4x12-15 reps&#10;            )&#10;            WorkoutType.PUSH_2 -&gt; listOf(&#10;                Triple(17, 4, 8),  // Standing Overhead Press - 4x6-8 reps&#10;                Triple(18, 3, 12), // Incline Barbell Press - 3x8-12 reps&#10;                Triple(19, 3, 10), // Weighted Dips - 3x8-10 reps&#10;                Triple(20, 3, 15), // Cable Lateral Raise - 3x12-15 reps&#10;                Triple(21, 3, 15), // Pec Deck or Dumbbell Fly - 3x12-15 reps&#10;                Triple(22, 3, 12)  // Overhead Cable Triceps Extension - 3x10-12 reps&#10;            )&#10;            WorkoutType.PULL_2 -&gt; listOf(&#10;                Triple(23, 4, 10), // Pendlay or Bent-Over Row - 4x6-10 reps&#10;                Triple(24, 3, 12), // Weighted Pull-Ups or Wide-Grip Lat Pulldown - 3x8-12 reps&#10;                Triple(25, 3, 12), // Dumbbell Shrug - 3x10-12 reps&#10;                Triple(26, 3, 15), // Face Pull - 3x12-15 reps&#10;                Triple(27, 3, 12), // EZ-Bar Biceps Curl - 3x8-12 reps&#10;                Triple(28, 2, 12)  // Reverse Grip or Preacher Curl - 2x10-12 reps&#10;            )&#10;            WorkoutType.LEGS_2 -&gt; listOf(&#10;                Triple(29, 4, 8),  // Front Squat - 4x6-8 reps&#10;                Triple(30, 3, 10), // Bulgarian Split Squat - 3x8-10 reps (each leg)&#10;                Triple(31, 3, 12), // Barbell Hip Thrust - 3x10-12 reps&#10;                Triple(32, 3, 15), // Leg Extension - 3x12-15 reps&#10;                Triple(33, 3, 15), // Seated or Lying Leg Curl - 3x12-15 reps&#10;                Triple(34, 4, 15)  // Standing Calf Raise - 4x12-15 reps&#10;            )&#10;            WorkoutType.REST -&gt; emptyList()&#10;        }&#10;    }&#10;&#10;    suspend fun updateWorkoutEntry(entry: WorkoutEntry) {&#10;        workoutEntryDao.update(entry)&#10;    }&#10;&#10;    suspend fun toggleExerciseCompletion(entryId: Int) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            val updatedEntry = it.copy(isCompleted = !it.isCompleted)&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun markExerciseComplete(entryId: Int, isCompleted: Boolean) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            val updatedEntry = it.copy(isCompleted = isCompleted)&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun updateExerciseDetails(entryId: Int, sets: Int, reps: Int, isCompleted: Boolean) {&#10;        println(&quot;️ REPO: Updating exercise details - entryId: $entryId, sets: $sets, reps: $reps, isCompleted: $isCompleted&quot;)&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            println(&quot;️ REPO: Found entry - id: ${it.id}, exerciseId: ${it.exerciseId}, current isCompleted: ${it.isCompleted}&quot;)&#10;            val updatedEntry = it.copy(sets = sets, reps = reps, isCompleted = isCompleted)&#10;            workoutEntryDao.update(updatedEntry)&#10;            println(&quot;️ REPO: Updated entry - id: ${updatedEntry.id}, new isCompleted: ${updatedEntry.isCompleted}&quot;)&#10;        } ?: run {&#10;            println(&quot;️ REPO ERROR: No entry found for entryId: $entryId&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun updateExerciseTime(entryId: Int, totalSecondsSpent: Int) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            val updatedEntry = it.copy(totalSecondsSpent = totalSecondsSpent)&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun startExerciseTimer(entryId: Int): Boolean {&#10;        // Mark exercise as started but not completed&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        return entry != null&#10;    }&#10;&#10;    // New methods for set-based operations&#10;    suspend fun getSetsForWorkoutEntry(workoutEntryId: Int): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.entity.SetEntry&gt;&gt; {&#10;        return setEntryDao.getSetsForWorkoutEntry(workoutEntryId)&#10;    }&#10;&#10;    suspend fun getSetsForWorkoutEntrySync(workoutEntryId: Int): List&lt;com.example.offlinepplworkoutapp.data.entity.SetEntry&gt; {&#10;        return setEntryDao.getSetsForWorkoutEntrySync(workoutEntryId)&#10;    }&#10;&#10;    suspend fun getCompletedSetsCount(workoutEntryId: Int): Int {&#10;        return setEntryDao.getCompletedSetsCount(workoutEntryId)&#10;    }&#10;&#10;    suspend fun updateSetProgress(setId: Int, isCompleted: Boolean, elapsedTimeSeconds: Int) {&#10;        val completedAt = if (isCompleted) System.currentTimeMillis() else null&#10;        setEntryDao.updateSetProgress(setId, isCompleted, elapsedTimeSeconds, completedAt)&#10;    }&#10;&#10;    suspend fun createSetsForWorkoutEntry(workoutEntryId: Int, totalSets: Int) {&#10;        val sets = (1..totalSets).map { setNumber -&gt;&#10;            com.example.offlinepplworkoutapp.data.entity.SetEntry(&#10;                workoutEntryId = workoutEntryId,&#10;                setNumber = setNumber&#10;            )&#10;        }&#10;        setEntryDao.insertAll(sets)&#10;    }&#10;&#10;    // Update exercise completion based on set completion&#10;    suspend fun updateExerciseCompletionFromSets(workoutEntryId: Int) {&#10;        val completedSets = setEntryDao.getCompletedSetsCount(workoutEntryId)&#10;        val totalSets = setEntryDao.getTotalSetsCount(workoutEntryId)&#10;&#10;        if (completedSets == totalSets &amp;&amp; totalSets &gt; 0) {&#10;            // Mark exercise as completed&#10;            val workoutEntry = workoutEntryDao.getWorkoutEntryById(workoutEntryId)&#10;            workoutEntry?.let {&#10;                workoutEntryDao.update(it.copy(isCompleted = true))&#10;            }&#10;        }&#10;    }&#10;&#10;    // New method that doesn't auto-create workout data&#10;    suspend fun getTodaysWorkoutWithoutCreating(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        val workoutDay = workoutDayDao.getWorkoutDayByDate(today)&#10;        return if (workoutDay != null) {&#10;            workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        } else {&#10;            kotlinx.coroutines.flow.flowOf(emptyList()) // Return empty list if no workout day exists&#10;        }&#10;    }&#10;&#10;    suspend fun getWorkoutForDateWithoutCreating(date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val workoutDay = workoutDayDao.getWorkoutDayByDate(date)&#10;        return if (workoutDay != null) {&#10;            workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        } else {&#10;            kotlinx.coroutines.flow.flowOf(emptyList()) // Return empty list if no workout day exists&#10;        }&#10;    }&#10;&#10;    // Method to manually create today's workout (called when user wants to start workout)&#10;    suspend fun createTodaysWorkout(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        println(&quot; REPO: Creating today's workout for date: $today&quot;)&#10;&#10;        // First, ensure exercises exist in the database&#10;        val exerciseCount = workoutEntryDao.getWorkoutEntryCount() // This will check if ANY entries exist&#10;        println(&quot; REPO: Checking if exercises are populated in database...&quot;)&#10;&#10;        // Check if we have the basic exercise data&#10;        val hasExercises = try {&#10;            val exerciseDao = (workoutEntryDao as? Any) // We need to get exerciseDao reference&#10;            // For now, let's try to insert the workout and catch the foreign key error&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;&#10;        // Check if workout day already exists&#10;        val existingWorkoutDay = workoutDayDao.getWorkoutDayByDate(today)&#10;&#10;        if (existingWorkoutDay != null) {&#10;            println(&quot; REPO: Found existing workout day with ID: ${existingWorkoutDay.id}&quot;)&#10;&#10;            // Check if it has exercises using count method&#10;            val existingEntriesCount = workoutEntryDao.getWorkoutEntryCountForDay(existingWorkoutDay.id)&#10;            println(&quot; REPO: Existing day has $existingEntriesCount exercises&quot;)&#10;&#10;            if (existingEntriesCount == 0) {&#10;                println(&quot; REPO: No exercises found, creating them now...&quot;)&#10;                // Day exists but has no exercises, create them&#10;                val workoutType = getWorkoutTypeForDate(today)&#10;                val exercises = getExercisesForWorkoutType(workoutType)&#10;                println(&quot; REPO: Got ${exercises.size} exercises for workout type: $workoutType&quot;)&#10;&#10;                if (exercises.isNotEmpty()) {&#10;                    try {&#10;                        val entries = exercises.map { (exerciseId, sets, reps) -&gt;&#10;                            WorkoutEntry(&#10;                                dayId = existingWorkoutDay.id,&#10;                                exerciseId = exerciseId,&#10;                                sets = sets,&#10;                                reps = reps&#10;                            )&#10;                        }&#10;                        workoutEntryDao.insertAll(entries)&#10;                        println(&quot; REPO: Inserted ${entries.size} workout entries&quot;)&#10;&#10;                        //  FIX: Create sets for each workout entry immediately&#10;                        val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(existingWorkoutDay.id)&#10;                        println(&quot; REPO: Retrieved ${insertedEntries.size} inserted entries to create sets&quot;)&#10;&#10;                        for (entry in insertedEntries) {&#10;                            println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;                            // Create individual sets for each exercise&#10;                            createSetsForWorkoutEntry(entry.id, entry.sets)&#10;                            println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;                            // Verify sets were created&#10;                            val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;                            println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;                            createdSets.forEach { set -&gt;&#10;                                println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;                            }&#10;                        }&#10;&#10;                        println(&quot; REPO: All sets created for ${insertedEntries.size} exercises&quot;)&#10;                      } catch (e: Exception) {&#10;                        println(&quot; REPO ERROR: Failed to insert workout entries - ${e.message}&quot;)&#10;                        // If foreign key constraint fails, we need to populate exercises first&#10;                        if (e.message?.contains(&quot;FOREIGN KEY constraint failed&quot;) == true) {&#10;                            println(&quot; REPO: Exercise data missing, need to populate exercises first&quot;)&#10;                            throw e // Re-throw to be caught by ViewModel&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            println(&quot; REPO: No existing workout day, creating new one...&quot;)&#10;            // Force create the workout day and exercises&#10;            val workoutDay = createWorkoutDayWithExercises(today)&#10;            println(&quot; REPO: Created new workout day with ID: ${workoutDay.id}&quot;)&#10;        }&#10;&#10;        // Get the final workout day (either existing or newly created)&#10;        val finalWorkoutDay = workoutDayDao.getWorkoutDayByDate(today)!!&#10;        println(&quot; REPO: Final workout day ID: ${finalWorkoutDay.id}&quot;)&#10;&#10;        // Return the flow of workout entries&#10;        return workoutEntryDao.getWorkoutEntriesForDay(finalWorkoutDay.id)&#10;    }&#10;&#10;    // ===========================================&#10;    // HELPER METHODS&#10;    // ===========================================&#10;&#10;    /**&#10;     * Create workout day only (without exercises) - used by template system&#10;     */&#10;    private suspend fun getOrCreateWorkoutDayOnly(date: String): WorkoutDay {&#10;        return workoutDayDao.getWorkoutDayByDate(date) ?: run {&#10;            val workoutDay = WorkoutDay(date = date)&#10;            val dayId = workoutDayDao.insert(workoutDay).toInt()&#10;            workoutDay.copy(id = dayId)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create sets for multiple workout entries - used by template system&#10;     */&#10;    private suspend fun createSetsForEntries(entries: List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;) {&#10;        for (entry in entries) {&#10;            println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;            createSetsForWorkoutEntry(entry.id, entry.sets)&#10;            println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;            // Verify sets were created&#10;            val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;            println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;            createdSets.forEach { set -&gt;&#10;                println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;            }&#10;        }&#10;        println(&quot; REPO: All sets created for ${entries.size} exercises&quot;)&#10;    }&#10;}&#10;&#10;enum class WorkoutType {&#10;    PUSH_1, PULL_1, LEGS_1, PUSH_2, PULL_2, LEGS_2, REST&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.data.repository&#10;&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutDayDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.SetEntryDao&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutTemplateDao&#10;import com.example.offlinepplworkoutapp.data.dao.TemplateExerciseDao&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutDay&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutEntry&#10;import com.example.offlinepplworkoutapp.data.entity.SetEntry&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import com.example.offlinepplworkoutapp.data.PPLTemplateData&#10;import kotlinx.coroutines.flow.Flow&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class WorkoutRepository(&#10;    private val workoutDayDao: WorkoutDayDao,&#10;    private val workoutEntryDao: WorkoutEntryDao,&#10;    private val setEntryDao: SetEntryDao,&#10;    private val workoutTemplateDao: WorkoutTemplateDao,&#10;    private val templateExerciseDao: TemplateExerciseDao&#10;) {&#10;&#10;    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;&#10;    // ===========================================&#10;    // TEMPLATE-BASED WORKOUT CREATION (NEW)&#10;    // ===========================================&#10;&#10;    /**&#10;     * Create workout from template - Main template-based workout creation method&#10;     * This replaces the hardcoded day-based logic with flexible template system&#10;     */&#10;    suspend fun createWorkoutFromTemplate(templateId: Int, date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        println(&quot; REPO: Creating workout from template $templateId for date: $date&quot;)&#10;&#10;        // Get or create workout day&#10;        val workoutDay = getOrCreateWorkoutDayOnly(date)&#10;&#10;        // Check if this day already has exercises&#10;        val existingEntries = workoutEntryDao.getWorkoutEntriesForDaySync(workoutDay.id)&#10;        if (existingEntries.isNotEmpty()) {&#10;            println(&quot; REPO: Found existing workout day with ${existingEntries.size} exercises&quot;)&#10;            return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        }&#10;&#10;        // Get template exercises&#10;        val templateExercises = templateExerciseDao.getExercisesForTemplate(templateId)&#10;        println(&quot; REPO: Got ${templateExercises.size} exercises for template $templateId&quot;)&#10;&#10;        if (templateExercises.isNotEmpty()) {&#10;            // Create workout entries from template&#10;            val entries = templateExercises.map { templateExercise -&gt;&#10;                WorkoutEntry(&#10;                    dayId = workoutDay.id,&#10;                    exerciseId = templateExercise.exerciseId,&#10;                    sets = templateExercise.sets,&#10;                    reps = templateExercise.reps&#10;                )&#10;            }&#10;&#10;            workoutEntryDao.insertAll(entries)&#10;            println(&quot; REPO: Inserted ${entries.size} workout entries from template&quot;)&#10;&#10;            // Create sets for each workout entry&#10;            val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(workoutDay.id)&#10;            createSetsForEntries(insertedEntries)&#10;&#10;            // Update template last used date&#10;            workoutTemplateDao.updateLastUsedDate(templateId, date)&#10;        }&#10;&#10;        return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;    }&#10;&#10;    /**&#10;     * Create today's workout using template-based system&#10;     * Automatically determines which template to use based on day of week&#10;     */&#10;    suspend fun createTodaysWorkoutFromTemplate(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        val templateId = getTemplateIdForDate(today)&#10;&#10;        return if (templateId &gt; 0) {&#10;            createWorkoutFromTemplate(templateId, today)&#10;        } else {&#10;            // Rest day - return empty workout&#10;            println(&quot; REPO: Rest day - no template needed&quot;)&#10;            workoutEntryDao.getWorkoutEntriesForDay(0) // Returns empty flow&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get template ID for a given date based on day of week&#10;     * This maintains compatibility with current PPL schedule&#10;     */&#10;    private fun getTemplateIdForDate(date: String): Int {&#10;        val calendar = Calendar.getInstance()&#10;        calendar.time = dateFormat.parse(date) ?: Date()&#10;        val dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK)&#10;&#10;        return PPLTemplateData.getTemplateIdForDayOfWeek(dayOfWeek)&#10;    }&#10;&#10;    /**&#10;     * Get available templates for user selection&#10;     */&#10;    fun getAvailableTemplates(): Flow&lt;List&lt;WorkoutTemplate&gt;&gt; {&#10;        return workoutTemplateDao.getAllActiveTemplates()&#10;    }&#10;&#10;    /**&#10;     * Get templates by category (Push/Pull/Legs)&#10;     */&#10;    fun getTemplatesByCategory(category: String): Flow&lt;List&lt;WorkoutTemplate&gt;&gt; {&#10;        return workoutTemplateDao.getTemplatesByCategory(category)&#10;    }&#10;&#10;    // ===========================================&#10;    // LEGACY DAY-BASED METHODS (PRESERVED)&#10;    // ===========================================&#10;&#10;    suspend fun getTodaysWorkout(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        val workoutDay = getOrCreateWorkoutDay(today)&#10;        return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;    }&#10;&#10;    suspend fun getWorkoutForDate(date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val workoutDay = getOrCreateWorkoutDay(date)&#10;        return workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;    }&#10;&#10;    private suspend fun getOrCreateWorkoutDay(date: String): WorkoutDay {&#10;        return workoutDayDao.getWorkoutDayByDate(date)&#10;            ?: createWorkoutDayWithExercises(date)&#10;    }&#10;&#10;    private suspend fun createWorkoutDayWithExercises(date: String): WorkoutDay {&#10;        // Create workout day&#10;        val workoutDay = WorkoutDay(date = date)&#10;        val dayId = workoutDayDao.insert(workoutDay).toInt()&#10;        val createdDay = workoutDay.copy(id = dayId)&#10;&#10;        // Determine workout type based on date&#10;        val workoutType = getWorkoutTypeForDate(date)&#10;        val exercises = getExercisesForWorkoutType(workoutType)&#10;&#10;        // Debug logging to see what's happening&#10;        println(&quot;DEBUG: Creating workout for date: $date, type: $workoutType, exercises count: ${exercises.size}&quot;)&#10;&#10;        // Only create entries if we have exercises for this workout type&#10;        if (exercises.isNotEmpty()) {&#10;            // Create workout entries&#10;            val entries = exercises.map { (exerciseId, sets, reps) -&gt;&#10;                WorkoutEntry(&#10;                    dayId = dayId,&#10;                    exerciseId = exerciseId,&#10;                    sets = sets,&#10;                    reps = reps&#10;                )&#10;            }&#10;&#10;            workoutEntryDao.insertAll(entries)&#10;            println(&quot;DEBUG: Inserted ${entries.size} workout entries for day $date&quot;)&#10;&#10;            //  FIX: Create sets for each workout entry immediately&#10;            // Since we just inserted the entries, we can use the entries we created&#10;            // and get their IDs after insertion&#10;            val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(dayId)&#10;            println(&quot; REPO: Retrieved ${insertedEntries.size} inserted entries to create sets&quot;)&#10;&#10;            for (entry in insertedEntries) {&#10;                println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;                // Create individual sets for each exercise&#10;                createSetsForWorkoutEntry(entry.id, entry.sets)&#10;                println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;                // Verify sets were created&#10;                val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;                println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;                createdSets.forEach { set -&gt;&#10;                    println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;                }&#10;            }&#10;&#10;            println(&quot; REPO: All sets created for ${insertedEntries.size} exercises&quot;)&#10;        } else {&#10;            println(&quot;DEBUG: No exercises found for workout type: $workoutType on date: $date&quot;)&#10;        }&#10;&#10;        return createdDay&#10;    }&#10;&#10;    private fun getWorkoutTypeForDate(date: String): WorkoutType {&#10;        val calendar = Calendar.getInstance()&#10;        calendar.time = dateFormat.parse(date) ?: Date()&#10;        val dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) // Sunday = 1, Saturday = 7&#10;&#10;        return when (dayOfWeek) {&#10;            Calendar.MONDAY -&gt; WorkoutType.PUSH_1&#10;            Calendar.TUESDAY -&gt; WorkoutType.PULL_1&#10;            Calendar.WEDNESDAY -&gt; WorkoutType.LEGS_1&#10;            Calendar.THURSDAY -&gt; WorkoutType.PUSH_2&#10;            Calendar.FRIDAY -&gt; WorkoutType.PULL_2&#10;            Calendar.SATURDAY -&gt; WorkoutType.LEGS_2&#10;            Calendar.SUNDAY -&gt; WorkoutType.REST&#10;            else -&gt; WorkoutType.REST&#10;        }&#10;    }&#10;&#10;    private fun getExercisesForWorkoutType(workoutType: WorkoutType): List&lt;Triple&lt;Int, Int, Int&gt;&gt; {&#10;        return when (workoutType) {&#10;            WorkoutType.PUSH_1 -&gt; listOf(&#10;                Triple(1, 4, 8),   // Barbell Bench Press - 4x6-8 reps&#10;                Triple(2, 3, 10),  // Standing Overhead Press - 3x8-10 reps&#10;                Triple(3, 3, 12),  // Incline Dumbbell Press - 3x8-12 reps&#10;                Triple(4, 3, 15),  // Dumbbell Lateral Raise - 3x12-15 reps&#10;                Triple(5, 3, 12)   // Cable Triceps Pushdown - 3x10-12 reps&#10;            )&#10;            WorkoutType.PULL_1 -&gt; listOf(&#10;                Triple(6, 3, 8),   // Deadlift - 3x5-8 reps&#10;                Triple(7, 3, 10),  // Pull-Ups or Lat Pulldowns - 3x8-10 reps&#10;                Triple(8, 3, 12),  // Bent-Over Barbell Row - 3x8-12 reps&#10;                Triple(9, 3, 15),  // Face Pull - 3x12-15 reps&#10;                Triple(10, 3, 12), // Barbell Biceps Curl - 3x8-12 reps&#10;                Triple(11, 2, 12)  // Hammer Curl - 2x10-12 reps&#10;            )&#10;            WorkoutType.LEGS_1 -&gt; listOf(&#10;                Triple(12, 4, 8),  // Back Squat - 4x6-8 reps&#10;                Triple(13, 3, 12), // Romanian Deadlift - 3x8-12 reps&#10;                Triple(14, 3, 12), // Leg Press - 3x10-12 reps&#10;                Triple(15, 3, 12), // Lying Leg Curl - 3x10-12 reps&#10;                Triple(16, 4, 15)  // Seated Calf Raise - 4x12-15 reps&#10;            )&#10;            WorkoutType.PUSH_2 -&gt; listOf(&#10;                Triple(17, 4, 8),  // Standing Overhead Press - 4x6-8 reps&#10;                Triple(18, 3, 12), // Incline Barbell Press - 3x8-12 reps&#10;                Triple(19, 3, 10), // Weighted Dips - 3x8-10 reps&#10;                Triple(20, 3, 15), // Cable Lateral Raise - 3x12-15 reps&#10;                Triple(21, 3, 15), // Pec Deck or Dumbbell Fly - 3x12-15 reps&#10;                Triple(22, 3, 12)  // Overhead Cable Triceps Extension - 3x10-12 reps&#10;            )&#10;            WorkoutType.PULL_2 -&gt; listOf(&#10;                Triple(23, 4, 10), // Pendlay or Bent-Over Row - 4x6-10 reps&#10;                Triple(24, 3, 12), // Weighted Pull-Ups or Wide-Grip Lat Pulldown - 3x8-12 reps&#10;                Triple(25, 3, 12), // Dumbbell Shrug - 3x10-12 reps&#10;                Triple(26, 3, 15), // Face Pull - 3x12-15 reps&#10;                Triple(27, 3, 12), // EZ-Bar Biceps Curl - 3x8-12 reps&#10;                Triple(28, 2, 12)  // Reverse Grip or Preacher Curl - 2x10-12 reps&#10;            )&#10;            WorkoutType.LEGS_2 -&gt; listOf(&#10;                Triple(29, 4, 8),  // Front Squat - 4x6-8 reps&#10;                Triple(30, 3, 10), // Bulgarian Split Squat - 3x8-10 reps (each leg)&#10;                Triple(31, 3, 12), // Barbell Hip Thrust - 3x10-12 reps&#10;                Triple(32, 3, 15), // Leg Extension - 3x12-15 reps&#10;                Triple(33, 3, 15), // Seated or Lying Leg Curl - 3x12-15 reps&#10;                Triple(34, 4, 15)  // Standing Calf Raise - 4x12-15 reps&#10;            )&#10;            WorkoutType.REST -&gt; emptyList()&#10;        }&#10;    }&#10;&#10;    suspend fun updateWorkoutEntry(entry: WorkoutEntry) {&#10;        workoutEntryDao.update(entry)&#10;    }&#10;&#10;    suspend fun toggleExerciseCompletion(entryId: Int) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            val updatedEntry = it.copy(isCompleted = !it.isCompleted)&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun markExerciseComplete(entryId: Int, isCompleted: Boolean) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            val updatedEntry = it.copy(isCompleted = isCompleted)&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun updateExerciseDetails(entryId: Int, sets: Int, reps: Int, isCompleted: Boolean) {&#10;        println(&quot;️ REPO: Updating exercise details - entryId: $entryId, sets: $sets, reps: $reps, isCompleted: $isCompleted&quot;)&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            println(&quot;️ REPO: Found entry - id: ${it.id}, exerciseId: ${it.exerciseId}, current isCompleted: ${it.isCompleted}&quot;)&#10;            val updatedEntry = it.copy(sets = sets, reps = reps, isCompleted = isCompleted)&#10;            workoutEntryDao.update(updatedEntry)&#10;            println(&quot;️ REPO: Updated entry - id: ${updatedEntry.id}, new isCompleted: ${updatedEntry.isCompleted}&quot;)&#10;        } ?: run {&#10;            println(&quot;️ REPO ERROR: No entry found for entryId: $entryId&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun updateExerciseTime(entryId: Int, totalSecondsSpent: Int) {&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        entry?.let {&#10;            val updatedEntry = it.copy(totalSecondsSpent = totalSecondsSpent)&#10;            workoutEntryDao.update(updatedEntry)&#10;        }&#10;    }&#10;&#10;    suspend fun startExerciseTimer(entryId: Int): Boolean {&#10;        // Mark exercise as started but not completed&#10;        val entry = workoutEntryDao.getWorkoutEntryById(entryId)&#10;        return entry != null&#10;    }&#10;&#10;    // New methods for set-based operations&#10;    suspend fun getSetsForWorkoutEntry(workoutEntryId: Int): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.entity.SetEntry&gt;&gt; {&#10;        return setEntryDao.getSetsForWorkoutEntry(workoutEntryId)&#10;    }&#10;&#10;    suspend fun getSetsForWorkoutEntrySync(workoutEntryId: Int): List&lt;com.example.offlinepplworkoutapp.data.entity.SetEntry&gt; {&#10;        return setEntryDao.getSetsForWorkoutEntrySync(workoutEntryId)&#10;    }&#10;&#10;    suspend fun getCompletedSetsCount(workoutEntryId: Int): Int {&#10;        return setEntryDao.getCompletedSetsCount(workoutEntryId)&#10;    }&#10;&#10;    suspend fun updateSetProgress(setId: Int, isCompleted: Boolean, elapsedTimeSeconds: Int) {&#10;        val completedAt = if (isCompleted) System.currentTimeMillis() else null&#10;        setEntryDao.updateSetProgress(setId, isCompleted, elapsedTimeSeconds, completedAt)&#10;    }&#10;&#10;    //  NEW: Phase 2.1.1 - Methods for handling set performance data&#10;    suspend fun updateSetProgressWithPerformanceData(&#10;        setId: Int,&#10;        isCompleted: Boolean,&#10;        elapsedTimeSeconds: Int,&#10;        repsPerformed: Int?,&#10;        weightUsed: Float?&#10;    ) {&#10;        val completedAt = if (isCompleted) System.currentTimeMillis() else null&#10;        setEntryDao.updateSetProgressWithPerformanceData(&#10;            setId = setId,&#10;            isCompleted = isCompleted,&#10;            elapsedTimeSeconds = elapsedTimeSeconds,&#10;            completedAt = completedAt,&#10;            repsPerformed = repsPerformed,&#10;            weightUsed = weightUsed&#10;        )&#10;        println(&quot;️ REPO: Updated set $setId with performance data - reps: $repsPerformed, weight: $weightUsed&quot;)&#10;    }&#10;&#10;    suspend fun updateSetPerformanceDataOnly(setId: Int, repsPerformed: Int?, weightUsed: Float?) {&#10;        setEntryDao.updateSetPerformanceData(setId, repsPerformed, weightUsed)&#10;        println(&quot;️ REPO: Updated performance data for set $setId - reps: $repsPerformed, weight: $weightUsed&quot;)&#10;    }&#10;&#10;    suspend fun getSetById(setId: Int): SetEntry? {&#10;        return setEntryDao.getSetById(setId)&#10;    }&#10;&#10;    suspend fun createSetsForWorkoutEntry(workoutEntryId: Int, totalSets: Int) {&#10;        val sets = (1..totalSets).map { setNumber -&gt;&#10;            SetEntry(&#10;                workoutEntryId = workoutEntryId,&#10;                setNumber = setNumber&#10;            )&#10;        }&#10;        setEntryDao.insertAll(sets)&#10;    }&#10;&#10;    // Update exercise completion based on set completion&#10;    suspend fun updateExerciseCompletionFromSets(workoutEntryId: Int) {&#10;        val completedSets = setEntryDao.getCompletedSetsCount(workoutEntryId)&#10;        val totalSets = setEntryDao.getTotalSetsCount(workoutEntryId)&#10;&#10;        if (completedSets == totalSets &amp;&amp; totalSets &gt; 0) {&#10;            // Mark exercise as completed&#10;            val workoutEntry = workoutEntryDao.getWorkoutEntryById(workoutEntryId)&#10;            workoutEntry?.let {&#10;                workoutEntryDao.update(it.copy(isCompleted = true))&#10;            }&#10;        }&#10;    }&#10;&#10;    // New method that doesn't auto-create workout data&#10;    suspend fun getTodaysWorkoutWithoutCreating(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        val workoutDay = workoutDayDao.getWorkoutDayByDate(today)&#10;        return if (workoutDay != null) {&#10;            workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        } else {&#10;            kotlinx.coroutines.flow.flowOf(emptyList()) // Return empty list if no workout day exists&#10;        }&#10;    }&#10;&#10;    suspend fun getWorkoutForDateWithoutCreating(date: String): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val workoutDay = workoutDayDao.getWorkoutDayByDate(date)&#10;        return if (workoutDay != null) {&#10;            workoutEntryDao.getWorkoutEntriesForDay(workoutDay.id)&#10;        } else {&#10;            kotlinx.coroutines.flow.flowOf(emptyList()) // Return empty list if no workout day exists&#10;        }&#10;    }&#10;&#10;    // Method to manually create today's workout (called when user wants to start workout)&#10;    suspend fun createTodaysWorkout(): Flow&lt;List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;&gt; {&#10;        val today = dateFormat.format(Date())&#10;        println(&quot; REPO: Creating today's workout for date: $today&quot;)&#10;&#10;        // First, ensure exercises exist in the database&#10;        val exerciseCount = workoutEntryDao.getWorkoutEntryCount() // This will check if ANY entries exist&#10;        println(&quot; REPO: Checking if exercises are populated in database...&quot;)&#10;&#10;        // Check if we have the basic exercise data&#10;        val hasExercises = try {&#10;            val exerciseDao = (workoutEntryDao as? Any) // We need to get exerciseDao reference&#10;            // For now, let's try to insert the workout and catch the foreign key error&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;&#10;        // Check if workout day already exists&#10;        val existingWorkoutDay = workoutDayDao.getWorkoutDayByDate(today)&#10;&#10;        if (existingWorkoutDay != null) {&#10;            println(&quot; REPO: Found existing workout day with ID: ${existingWorkoutDay.id}&quot;)&#10;&#10;            // Check if it has exercises using count method&#10;            val existingEntriesCount = workoutEntryDao.getWorkoutEntryCountForDay(existingWorkoutDay.id)&#10;            println(&quot; REPO: Existing day has $existingEntriesCount exercises&quot;)&#10;&#10;            if (existingEntriesCount == 0) {&#10;                println(&quot; REPO: No exercises found, creating them now...&quot;)&#10;                // Day exists but has no exercises, create them&#10;                val workoutType = getWorkoutTypeForDate(today)&#10;                val exercises = getExercisesForWorkoutType(workoutType)&#10;                println(&quot; REPO: Got ${exercises.size} exercises for workout type: $workoutType&quot;)&#10;&#10;                if (exercises.isNotEmpty()) {&#10;                    try {&#10;                        val entries = exercises.map { (exerciseId, sets, reps) -&gt;&#10;                            WorkoutEntry(&#10;                                dayId = existingWorkoutDay.id,&#10;                                exerciseId = exerciseId,&#10;                                sets = sets,&#10;                                reps = reps&#10;                            )&#10;                        }&#10;                        workoutEntryDao.insertAll(entries)&#10;                        println(&quot; REPO: Inserted ${entries.size} workout entries&quot;)&#10;&#10;                        //  FIX: Create sets for each workout entry immediately&#10;                        val insertedEntries = workoutEntryDao.getWorkoutEntriesForDaySync(existingWorkoutDay.id)&#10;                        println(&quot; REPO: Retrieved ${insertedEntries.size} inserted entries to create sets&quot;)&#10;&#10;                        for (entry in insertedEntries) {&#10;                            println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;                            // Create individual sets for each exercise&#10;                            createSetsForWorkoutEntry(entry.id, entry.sets)&#10;                            println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;                            // Verify sets were created&#10;                            val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;                            println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;                            createdSets.forEach { set -&gt;&#10;                                println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;                            }&#10;                        }&#10;&#10;                        println(&quot; REPO: All sets created for ${insertedEntries.size} exercises&quot;)&#10;                      } catch (e: Exception) {&#10;                        println(&quot; REPO ERROR: Failed to insert workout entries - ${e.message}&quot;)&#10;                        // If foreign key constraint fails, we need to populate exercises first&#10;                        if (e.message?.contains(&quot;FOREIGN KEY constraint failed&quot;) == true) {&#10;                            println(&quot; REPO: Exercise data missing, need to populate exercises first&quot;)&#10;                            throw e // Re-throw to be caught by ViewModel&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            println(&quot; REPO: No existing workout day, creating new one...&quot;)&#10;            // Force create the workout day and exercises&#10;            val workoutDay = createWorkoutDayWithExercises(today)&#10;            println(&quot; REPO: Created new workout day with ID: ${workoutDay.id}&quot;)&#10;        }&#10;&#10;        // Get the final workout day (either existing or newly created)&#10;        val finalWorkoutDay = workoutDayDao.getWorkoutDayByDate(today)!!&#10;        println(&quot; REPO: Final workout day ID: ${finalWorkoutDay.id}&quot;)&#10;&#10;        // Return the flow of workout entries&#10;        return workoutEntryDao.getWorkoutEntriesForDay(finalWorkoutDay.id)&#10;    }&#10;&#10;    // ===========================================&#10;    // HELPER METHODS&#10;    // ===========================================&#10;&#10;    /**&#10;     * Create workout day only (without exercises) - used by template system&#10;     */&#10;    private suspend fun getOrCreateWorkoutDayOnly(date: String): WorkoutDay {&#10;        return workoutDayDao.getWorkoutDayByDate(date) ?: run {&#10;            val workoutDay = WorkoutDay(date = date)&#10;            val dayId = workoutDayDao.insert(workoutDay).toInt()&#10;            workoutDay.copy(id = dayId)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create sets for multiple workout entries - used by template system&#10;     */&#10;    private suspend fun createSetsForEntries(entries: List&lt;com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&gt;) {&#10;        for (entry in entries) {&#10;            println(&quot; REPO: Creating sets for WorkoutEntry ID=${entry.id}, Exercise='${entry.exerciseName}', Sets=${entry.sets}&quot;)&#10;            createSetsForWorkoutEntry(entry.id, entry.sets)&#10;            println(&quot; REPO: Created ${entry.sets} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;&#10;            // Verify sets were created&#10;            val createdSets = setEntryDao.getSetsForWorkoutEntrySync(entry.id)&#10;            println(&quot; REPO: Verification - Found ${createdSets.size} sets for WorkoutEntry ID=${entry.id}&quot;)&#10;            createdSets.forEach { set -&gt;&#10;                println(&quot; REPO: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}&quot;)&#10;            }&#10;        }&#10;        println(&quot; REPO: All sets created for ${entries.size} exercises&quot;)&#10;    }&#10;}&#10;&#10;enum class WorkoutType {&#10;    PUSH_1, PULL_1, LEGS_1, PUSH_2, PULL_2, LEGS_2, REST&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/SetDataEntryDialog.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/components/SetDataEntryDialog.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.offlinepplworkoutapp.ui.theme.*&#10;&#10;data class SetPerformanceData(&#10;    val repsPerformed: Int,&#10;    val weightUsed: Float&#10;)&#10;&#10;@Composable&#10;fun SetDataEntryDialog(&#10;    setNumber: Int,&#10;    exerciseName: String,&#10;    onDataEntered: (SetPerformanceData) -&gt; Unit,&#10;    isRestTimerRunning: Boolean = false,&#10;    restTimeFormatted: String = &quot;00:00&quot;&#10;) {&#10;    var repsText by remember { mutableStateOf(&quot;&quot;) }&#10;    var weightText by remember { mutableStateOf(&quot;&quot;) }&#10;    var repsError by remember { mutableStateOf(false) }&#10;    var weightError by remember { mutableStateOf(false) }&#10;&#10;    println(&quot; DIALOG: SetDataEntryDialog opened for set $setNumber of $exerciseName&quot;)&#10;&#10;    Dialog(&#10;        onDismissRequest = {&#10;            // No dismiss on outside click - user must enter data&#10;            println(&quot; DIALOG: Dismiss request blocked - data entry required&quot;)&#10;        },&#10;        properties = DialogProperties(&#10;            dismissOnBackPress = false,&#10;            dismissOnClickOutside = false&#10;        )&#10;    ) {&#10;        Surface(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            shape = MaterialTheme.shapes.large,&#10;            color = MaterialTheme.colorScheme.surface,&#10;            shadowElevation = 8.dp&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                // Header with rest timer indicator&#10;                if (isRestTimerRunning) {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = CardDefaults.cardColors(&#10;                            containerColor = Color(0xFFFFE0B2) // Light orange background&#10;                        )&#10;                    ) {&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(12.dp),&#10;                            horizontalArrangement = Arrangement.Center,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Rest Timer: $restTimeFormatted&quot;,&#10;                                fontSize = 14.sp,&#10;                                fontWeight = FontWeight.Medium,&#10;                                color = Color(0xFFE65100) // Orange text&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Title&#10;                Text(&#10;                    text = &quot;Set $setNumber Complete!&quot;,&#10;                    fontSize = 20.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.Black,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                // Exercise name&#10;                Text(&#10;                    text = exerciseName,&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = Color.Black.copy(alpha = 0.7f),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                // Input fields&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    // Reps performed field&#10;                    OutlinedTextField(&#10;                        value = repsText,&#10;                        onValueChange = {&#10;                            repsText = it&#10;                            repsError = false&#10;                        },&#10;                        label = { Text(&quot;Reps Performed *&quot;) },&#10;                        placeholder = { Text(&quot;e.g., 12&quot;) },&#10;                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                        isError = repsError,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = OutlinedTextFieldDefaults.colors(&#10;                            focusedBorderColor = PrimaryCoral,&#10;                            cursorColor = PrimaryCoral&#10;                        ),&#10;                        supportingText = if (repsError) {&#10;                            { Text(&quot;Please enter a valid number of reps&quot;, color = MaterialTheme.colorScheme.error) }&#10;                        } else null&#10;                    )&#10;&#10;                    // Weight used field&#10;                    OutlinedTextField(&#10;                        value = weightText,&#10;                        onValueChange = {&#10;                            weightText = it&#10;                            weightError = false&#10;                        },&#10;                        label = { Text(&quot;Weight Used (lbs) *&quot;) },&#10;                        placeholder = { Text(&quot;e.g., 135.5&quot;) },&#10;                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),&#10;                        isError = weightError,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = OutlinedTextFieldDefaults.colors(&#10;                            focusedBorderColor = PrimaryCoral,&#10;                            cursorColor = PrimaryCoral&#10;                        ),&#10;                        supportingText = if (weightError) {&#10;                            { Text(&quot;Please enter a valid weight&quot;, color = MaterialTheme.colorScheme.error) }&#10;                        } else null&#10;                    )&#10;                }&#10;&#10;                // Required fields note&#10;                Text(&#10;                    text = &quot;* Required fields&quot;,&#10;                    fontSize = 12.sp,&#10;                    color = Color.Black.copy(alpha = 0.6f),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;&#10;                // ADD button (no cancel button as per requirements)&#10;                Button(&#10;                    onClick = {&#10;                        println(&quot; DIALOG: ADD button clicked - reps: '$repsText', weight: '$weightText'&quot;)&#10;&#10;                        // Validate inputs&#10;                        val reps = repsText.toIntOrNull()&#10;                        val weight = weightText.toFloatOrNull()&#10;&#10;                        when {&#10;                            reps == null || reps &lt;= 0 -&gt; {&#10;                                repsError = true&#10;                                println(&quot; DIALOG: Reps validation failed&quot;)&#10;                            }&#10;                            weight == null || weight &lt; 0 -&gt; {&#10;                                weightError = true&#10;                                println(&quot; DIALOG: Weight validation failed&quot;)&#10;                            }&#10;                            else -&gt; {&#10;                                println(&quot; DIALOG: Validation passed - submitting data&quot;)&#10;                                val data = SetPerformanceData(&#10;                                    repsPerformed = reps,&#10;                                    weightUsed = weight&#10;                                )&#10;                                onDataEntered(data)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(48.dp),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = PrimaryCoral&#10;                    )&#10;                ) {&#10;                    Text(&#10;                        text = &quot;ADD&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/ExerciseDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/ExerciseDetailScreen.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.animation.*&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.delay&#10;import com.example.offlinepplworkoutapp.ui.theme.*&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModelFactory&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ExerciseDetailScreen(&#10;    workoutEntry: WorkoutEntryWithExercise,&#10;    repository: WorkoutRepository,&#10;    onBackClick: () -&gt; Unit,&#10;    onSaveChanges: (sets: Int, reps: Int, isCompleted: Boolean) -&gt; Unit&#10;) {&#10;    //  FIX: Add unique key to force new ViewModel creation for each exercise&#10;    val viewModel: ExerciseDetailViewModel = viewModel(&#10;        key = &quot;exercise_${workoutEntry.id}&quot;, // Unique key for each exercise&#10;        factory = ExerciseDetailViewModelFactory(workoutEntry, repository)&#10;    )&#10;&#10;    println(&quot; UI: Created ExerciseDetailViewModel for ${workoutEntry.exerciseName} (ID: ${workoutEntry.id})&quot;)&#10;&#10;    val setTimers by viewModel.setTimers.collectAsState()&#10;    val currentRunningSet by viewModel.currentRunningSet.collectAsState()&#10;    val totalExerciseTime by viewModel.totalExerciseTime.collectAsState()&#10;    val completedSets by viewModel.completedSets.collectAsState()&#10;    val isExerciseCompleted by viewModel.isExerciseCompleted.collectAsState()&#10;&#10;    //  NEW: Rest timer state&#10;    val restTimer by viewModel.restTimer.collectAsState()&#10;    val isRestActive by viewModel.isRestActive.collectAsState()&#10;&#10;    val originalCompletionStatus = remember { workoutEntry.isCompleted }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = workoutEntry.exerciseName,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontSize = 22.sp,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = PrimaryCoral&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Sets: $completedSets/${workoutEntry.sets} • Total: ${formatTime(totalExerciseTime / 1000)}&quot;.also {&#10;                                println(&quot; UI DEBUG: Displaying total time - Raw: ${totalExerciseTime}ms, Converted: ${totalExerciseTime / 1000}s, Formatted: ${formatTime(totalExerciseTime / 1000)}&quot;)&#10;                            },&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontSize = 14.sp,&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = {&#10;                        val shouldMarkCompleted = isExerciseCompleted &amp;&amp; completedSets == workoutEntry.sets&#10;                        if (shouldMarkCompleted != originalCompletionStatus) {&#10;                            onSaveChanges(workoutEntry.sets, workoutEntry.reps, shouldMarkCompleted)&#10;                        }&#10;                        onBackClick()&#10;                    }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = PrimaryCoral&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = CardBackground&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(BackgroundLight)&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            //  NEW: Rest timer display at top of screen&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isRestActive,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    RestTimerCard(&#10;                        restTime = restTimer / 1000, // Convert milliseconds to seconds&#10;                        isActive = isRestActive&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Exercise completion status with animation&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isExerciseCompleted,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    CompletionCard()&#10;                }&#10;            }&#10;&#10;            // Set cards with improved design&#10;            itemsIndexed(setTimers) { index, setTimer -&gt;&#10;                val activeSetIndex by viewModel.activeSetIndex.collectAsState()&#10;                ModernSetTimerCard(&#10;                    setNumber = index + 1,&#10;                    totalSets = workoutEntry.sets,&#10;                    targetReps = workoutEntry.reps,&#10;                    setTimer = setTimer.elapsedTime / 1000, //  FIXED: Convert milliseconds to seconds&#10;                    isCurrentSet = currentRunningSet == index,&#10;                    isCompleted = setTimer.isCompleted,&#10;                    isActive = index == activeSetIndex,&#10;                    isLocked = index &gt; activeSetIndex &amp;&amp; !setTimer.isCompleted,&#10;                    onStartTimer = { viewModel.startSetTimer(index) },&#10;                    onStopTimer = { viewModel.stopSetTimer(index) },&#10;                    onCompleteSet = { viewModel.completeSet(index) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CompletionCard() {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(8.dp, RoundedCornerShape(20.dp))&#10;            .clip(RoundedCornerShape(20.dp))&#10;            .background(&#10;                brush = Brush.horizontalGradient(&#10;                    colors = listOf(SuccessGreen, TealSecondary)&#10;                )&#10;            ),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Check,&#10;                contentDescription = &quot;Completed&quot;,&#10;                tint = TextOnPrimary,&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Text(&#10;                text = &quot;Exercise Completed! &quot;,&#10;                style = MaterialTheme.typography.titleLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextOnPrimary&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ModernSetTimerCard(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    targetReps: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean = false,&#10;    isActive: Boolean = false,&#10;    isLocked: Boolean = false,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onCompleteSet: () -&gt; Unit&#10;) {&#10;    // Animation for card state changes&#10;    val animatedElevation by animateDpAsState(&#10;        targetValue = when {&#10;            isCurrentSet -&gt; 12.dp&#10;            isActive -&gt; 6.dp&#10;            else -&gt; 2.dp&#10;        },&#10;        animationSpec = tween(300)&#10;    )&#10;&#10;    // Card colors based on state&#10;    val cardColors = when {&#10;        isCompleted -&gt; CardDefaults.cardColors(&#10;            containerColor = SuccessGreen.copy(alpha = 0.1f)&#10;        )&#10;        isCurrentSet -&gt; CardDefaults.cardColors(&#10;            containerColor = Color.Transparent&#10;        )&#10;        isActive -&gt; CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        )&#10;        isLocked -&gt; CardDefaults.cardColors(&#10;            containerColor = TextSecondary.copy(alpha = 0.05f)&#10;        )&#10;        else -&gt; CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(animatedElevation, RoundedCornerShape(16.dp))&#10;            .then(&#10;                if (isCurrentSet) {&#10;                    Modifier&#10;                        .border(&#10;                            width = 3.dp,&#10;                            brush = Brush.horizontalGradient(&#10;                                colors = listOf(ProgressStart, ProgressEnd)&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                        .background(&#10;                            brush = Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    ProgressStart.copy(alpha = 0.1f),&#10;                                    ProgressEnd.copy(alpha = 0.05f)&#10;                                )&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                } else {&#10;                    Modifier&#10;                }&#10;            ),&#10;        colors = cardColors,&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            // Set Header with improved typography&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Set status icon&#10;                    when {&#10;                        isCompleted -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isCurrentSet -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Active&quot;,&#10;                                tint = PrimaryCoral,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isLocked -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Lock,&#10;                                contentDescription = &quot;Locked&quot;,&#10;                                tint = TextSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        else -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.DateRange,&#10;                                contentDescription = &quot;Ready&quot;,&#10;                                tint = TealSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Set $setNumber of $totalSets&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontSize = 16.sp,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = when {&#10;                                isLocked -&gt; TextSecondary.copy(alpha = 0.6f)&#10;                                else -&gt; TextPrimary&#10;                            }&#10;                        )&#10;                    )&#10;                }&#10;&#10;                // Timer display with improved styling&#10;                TimerDisplay(&#10;                    time = setTimer,&#10;                    isActive = isCurrentSet,&#10;                    isCompleted = isCompleted&#10;                )&#10;            }&#10;&#10;            // Target reps info&#10;            Text(&#10;                text = &quot;Target: $targetReps reps&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    color = TextSecondary,&#10;                    fontSize = 14.sp&#10;                )&#10;            )&#10;&#10;            // Action buttons with modern design&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                when {&#10;                    isCompleted -&gt; {&#10;                        // Completed state - show success message&#10;                        Row(&#10;                            modifier = Modifier.weight(1f),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&#10;                                text = &quot;Set Completed&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    color = SuccessGreen,&#10;                                    fontWeight = FontWeight.Medium&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    isLocked -&gt; {&#10;                        // Locked state&#10;                        Text(&#10;                            text = &quot;Complete previous sets first&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                color = TextSecondary,&#10;                                fontStyle = androidx.compose.ui.text.font.FontStyle.Italic&#10;                            ),&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    }&#10;                    isCurrentSet -&gt; {&#10;                        //  FIXED: Simplified workflow - only Stop button that auto-completes the set&#10;                        Button(&#10;                            onClick = {&#10;                                onStopTimer() // Stop timer and auto-complete the set&#10;                                onCompleteSet() // Automatically mark as completed&#10;                            },&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = SuccessGreen&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Stop and Complete&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Complete Set&quot;)&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // Ready to start&#10;                        Button(&#10;                            onClick = onStartTimer,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = PrimaryCoral&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp),&#10;                            enabled = !isLocked&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Start&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Start Set&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimerDisplay(&#10;    time: Long,&#10;    isActive: Boolean,&#10;    isCompleted: Boolean&#10;) {&#10;    val textColor = when {&#10;        isCompleted -&gt; SuccessGreen&#10;        isActive -&gt; PrimaryCoral&#10;        else -&gt; TextSecondary&#10;    }&#10;&#10;    //  PROPER STOPWATCH: Start from stored time and count up properly&#10;    var displayTime by remember(time) { mutableStateOf(time) }&#10;&#10;    // Track when timer starts to calculate elapsed time properly&#10;    val startTimeRef = remember { mutableStateOf(0L) }&#10;&#10;    LaunchedEffect(isActive) {&#10;        if (isActive) {&#10;            // Record the actual start time when timer becomes active&#10;            startTimeRef.value = System.currentTimeMillis()&#10;&#10;            while (isActive) {&#10;                // Calculate elapsed seconds since timer started&#10;                val elapsedMs = System.currentTimeMillis() - startTimeRef.value&#10;                val elapsedSeconds = elapsedMs / 1000&#10;&#10;                // Display = stored time + elapsed time&#10;                displayTime = time + elapsedSeconds&#10;&#10;                delay(1000) // Update every second&#10;            }&#10;        } else {&#10;            // When not active, show the stored time from database&#10;            displayTime = time&#10;        }&#10;    }&#10;&#10;    Text(&#10;        text = formatTime(displayTime),&#10;        style = MaterialTheme.typography.titleLarge.copy(&#10;            fontSize = if (isActive) 20.sp else 18.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = textColor&#10;        )&#10;    )&#10;}&#10;&#10;private fun formatTime(timeInSeconds: Long): String {&#10;    val hours = timeInSeconds / 3600&#10;    val minutes = (timeInSeconds % 3600) / 60&#10;    val seconds = timeInSeconds % 60&#10;&#10;    return if (hours &gt; 0) {&#10;        String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds)&#10;    } else {&#10;        String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;}&#10;&#10;//  NEW: Rest Timer Card Component&#10;@Composable&#10;fun RestTimerCard(&#10;    restTime: Long,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(6.dp, RoundedCornerShape(16.dp)),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                // Rest icon - using a pause/timer-like icon&#10;                Icon(&#10;                    imageVector = Icons.Default.PlayArrow, // We'll use this as a rest indicator&#10;                    contentDescription = &quot;Rest&quot;,&#10;                    tint = AmberAccent,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                Text(&#10;                    text = &quot;Rest Timer&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = TextPrimary&#10;                    )&#10;                )&#10;            }&#10;&#10;            // Rest time display with prominent styling&#10;            Text(&#10;                text = formatTime(restTime),&#10;                style = MaterialTheme.typography.headlineMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = AmberAccent,&#10;                    fontSize = 24.sp&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.animation.*&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.delay&#10;import com.example.offlinepplworkoutapp.ui.theme.*&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.ExerciseDetailViewModelFactory&#10;import com.example.offlinepplworkoutapp.ui.components.SetDataEntryDialog&#10;import com.example.offlinepplworkoutapp.ui.components.SetPerformanceData&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ExerciseDetailScreen(&#10;    workoutEntry: WorkoutEntryWithExercise,&#10;    repository: WorkoutRepository,&#10;    onBackClick: () -&gt; Unit,&#10;    onSaveChanges: (sets: Int, reps: Int, isCompleted: Boolean) -&gt; Unit&#10;) {&#10;    //  FIX: Add unique key to force new ViewModel creation for each exercise&#10;    val viewModel: ExerciseDetailViewModel = viewModel(&#10;        key = &quot;exercise_${workoutEntry.id}&quot;, // Unique key for each exercise&#10;        factory = ExerciseDetailViewModelFactory(workoutEntry, repository)&#10;    )&#10;&#10;    println(&quot; UI: Created ExerciseDetailViewModel for ${workoutEntry.exerciseName} (ID: ${workoutEntry.id})&quot;)&#10;&#10;    val setTimers by viewModel.setTimers.collectAsState()&#10;    val currentRunningSet by viewModel.currentRunningSet.collectAsState()&#10;    val totalExerciseTime by viewModel.totalExerciseTime.collectAsState()&#10;    val completedSets by viewModel.completedSets.collectAsState()&#10;    val isExerciseCompleted by viewModel.isExerciseCompleted.collectAsState()&#10;&#10;    //  NEW: Rest timer state&#10;    val restTimer by viewModel.restTimer.collectAsState()&#10;    val isRestActive by viewModel.isRestActive.collectAsState()&#10;&#10;    //  NEW: Phase 2.1.2 - Set data entry dialog state&#10;    val showSetDataDialog by viewModel.showSetDataDialog.collectAsState()&#10;    val pendingSetData by viewModel.pendingSetData.collectAsState()&#10;&#10;    val originalCompletionStatus = remember { workoutEntry.isCompleted }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = workoutEntry.exerciseName,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontSize = 22.sp,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = PrimaryCoral&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Sets: $completedSets/${workoutEntry.sets} • Total: ${formatTime(totalExerciseTime / 1000)}&quot;.also {&#10;                                println(&quot; UI DEBUG: Displaying total time - Raw: ${totalExerciseTime}ms, Converted: ${totalExerciseTime / 1000}s, Formatted: ${formatTime(totalExerciseTime / 1000)}&quot;)&#10;                            },&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontSize = 14.sp,&#10;                                color = TextSecondary&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = {&#10;                        val shouldMarkCompleted = isExerciseCompleted &amp;&amp; completedSets == workoutEntry.sets&#10;                        if (shouldMarkCompleted != originalCompletionStatus) {&#10;                            onSaveChanges(workoutEntry.sets, workoutEntry.reps, shouldMarkCompleted)&#10;                        }&#10;                        onBackClick()&#10;                    }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = PrimaryCoral&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = CardBackground&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(BackgroundLight)&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            //  NEW: Rest timer display at top of screen&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isRestActive,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    RestTimerCard(&#10;                        restTime = restTimer / 1000, // Convert milliseconds to seconds&#10;                        isActive = isRestActive&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Exercise completion status with animation&#10;            item {&#10;                AnimatedVisibility(&#10;                    visible = isExerciseCompleted,&#10;                    enter = slideInVertically() + fadeIn(),&#10;                    exit = slideOutVertically() + fadeOut()&#10;                ) {&#10;                    CompletionCard()&#10;                }&#10;            }&#10;&#10;            // Set cards with improved design&#10;            itemsIndexed(setTimers) { index, setTimer -&gt;&#10;                val activeSetIndex by viewModel.activeSetIndex.collectAsState()&#10;                ModernSetTimerCard(&#10;                    setNumber = index + 1,&#10;                    totalSets = workoutEntry.sets,&#10;                    targetReps = workoutEntry.reps,&#10;                    setTimer = setTimer.elapsedTime / 1000, //  FIXED: Convert milliseconds to seconds&#10;                    isCurrentSet = currentRunningSet == index,&#10;                    isCompleted = setTimer.isCompleted,&#10;                    isActive = index == activeSetIndex,&#10;                    isLocked = index &gt; activeSetIndex &amp;&amp; !setTimer.isCompleted,&#10;                    onStartTimer = { viewModel.startSetTimer(index) },&#10;                    onStopTimer = { viewModel.stopSetTimer(index) },&#10;                    onCompleteSet = { viewModel.completeSet(index) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Set Data Entry Dialog&#10;    if (showSetDataDialog) {&#10;        pendingSetData?.let { (setIndex, _) -&gt;&#10;            SetDataEntryDialog(&#10;                setNumber = setIndex + 1,&#10;                exerciseName = workoutEntry.exerciseName,&#10;                onDataEntered = { performanceData -&gt;&#10;                    viewModel.submitSetPerformanceData(&#10;                        repsPerformed = performanceData.repsPerformed,&#10;                        weightUsed = performanceData.weightUsed&#10;                    )&#10;                },&#10;                isRestTimerRunning = isRestActive,&#10;                restTimeFormatted = formatTime(restTimer / 1000)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CompletionCard() {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(8.dp, RoundedCornerShape(20.dp))&#10;            .clip(RoundedCornerShape(20.dp))&#10;            .background(&#10;                brush = Brush.horizontalGradient(&#10;                    colors = listOf(SuccessGreen, TealSecondary)&#10;                )&#10;            ),&#10;        colors = CardDefaults.cardColors(containerColor = Color.Transparent)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Check,&#10;                contentDescription = &quot;Completed&quot;,&#10;                tint = TextOnPrimary,&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Text(&#10;                text = &quot;Exercise Completed! &quot;,&#10;                style = MaterialTheme.typography.titleLarge.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = TextOnPrimary&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ModernSetTimerCard(&#10;    setNumber: Int,&#10;    totalSets: Int,&#10;    targetReps: Int,&#10;    setTimer: Long,&#10;    isCurrentSet: Boolean,&#10;    isCompleted: Boolean = false,&#10;    isActive: Boolean = false,&#10;    isLocked: Boolean = false,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onCompleteSet: () -&gt; Unit&#10;) {&#10;    // Animation for card state changes&#10;    val animatedElevation by animateDpAsState(&#10;        targetValue = when {&#10;            isCurrentSet -&gt; 12.dp&#10;            isActive -&gt; 6.dp&#10;            else -&gt; 2.dp&#10;        },&#10;        animationSpec = tween(300)&#10;    )&#10;&#10;    // Card colors based on state&#10;    val cardColors = when {&#10;        isCompleted -&gt; CardDefaults.cardColors(&#10;            containerColor = SuccessGreen.copy(alpha = 0.1f)&#10;        )&#10;        isCurrentSet -&gt; CardDefaults.cardColors(&#10;            containerColor = Color.Transparent&#10;        )&#10;        isActive -&gt; CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        )&#10;        isLocked -&gt; CardDefaults.cardColors(&#10;            containerColor = TextSecondary.copy(alpha = 0.05f)&#10;        )&#10;        else -&gt; CardDefaults.cardColors(&#10;            containerColor = CardBackground&#10;        )&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(animatedElevation, RoundedCornerShape(16.dp))&#10;            .then(&#10;                if (isCurrentSet) {&#10;                    Modifier&#10;                        .border(&#10;                            width = 3.dp,&#10;                            brush = Brush.horizontalGradient(&#10;                                colors = listOf(ProgressStart, ProgressEnd)&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                        .background(&#10;                            brush = Brush.verticalGradient(&#10;                                colors = listOf(&#10;                                    ProgressStart.copy(alpha = 0.1f),&#10;                                    ProgressEnd.copy(alpha = 0.05f)&#10;                                )&#10;                            ),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                } else {&#10;                    Modifier&#10;                }&#10;            ),&#10;        colors = cardColors,&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp),&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            // Set Header with improved typography&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Set status icon&#10;                    when {&#10;                        isCompleted -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isCurrentSet -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Active&quot;,&#10;                                tint = PrimaryCoral,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        isLocked -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Lock,&#10;                                contentDescription = &quot;Locked&quot;,&#10;                                tint = TextSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        else -&gt; {&#10;                            Icon(&#10;                                imageVector = Icons.Default.DateRange,&#10;                                contentDescription = &quot;Ready&quot;,&#10;                                tint = TealSecondary,&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Set $setNumber of $totalSets&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontSize = 16.sp,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = when {&#10;                                isLocked -&gt; TextSecondary.copy(alpha = 0.6f)&#10;                                else -&gt; TextPrimary&#10;                            }&#10;                        )&#10;                    )&#10;                }&#10;&#10;                // Timer display with improved styling&#10;                TimerDisplay(&#10;                    time = setTimer,&#10;                    isActive = isCurrentSet,&#10;                    isCompleted = isCompleted&#10;                )&#10;            }&#10;&#10;            // Target reps info&#10;            Text(&#10;                text = &quot;Target: $targetReps reps&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    color = TextSecondary,&#10;                    fontSize = 14.sp&#10;                )&#10;            )&#10;&#10;            // Action buttons with modern design&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                when {&#10;                    isCompleted -&gt; {&#10;                        // Completed state - show success message&#10;                        Row(&#10;                            modifier = Modifier.weight(1f),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Completed&quot;,&#10;                                tint = SuccessGreen,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&#10;                                text = &quot;Set Completed&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    color = SuccessGreen,&#10;                                    fontWeight = FontWeight.Medium&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    isLocked -&gt; {&#10;                        // Locked state&#10;                        Text(&#10;                            text = &quot;Complete previous sets first&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                color = TextSecondary,&#10;                                fontStyle = androidx.compose.ui.text.font.FontStyle.Italic&#10;                            ),&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                    }&#10;                    isCurrentSet -&gt; {&#10;                        //  NEW: Phase 2.1.2 - Just stop timer, dialog will handle completion&#10;                        Button(&#10;                            onClick = {&#10;                                onStopTimer() // This will show the data entry dialog&#10;                            },&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = SuccessGreen&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp)&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Check,&#10;                                contentDescription = &quot;Complete Set&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Complete Set&quot;)&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // Ready to start&#10;                        Button(&#10;                            onClick = onStartTimer,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = PrimaryCoral&#10;                            ),&#10;                            shape = RoundedCornerShape(12.dp),&#10;                            enabled = !isLocked&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.PlayArrow,&#10;                                contentDescription = &quot;Start&quot;,&#10;                                modifier = Modifier.size(16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&quot;Start Set&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimerDisplay(&#10;    time: Long,&#10;    isActive: Boolean,&#10;    isCompleted: Boolean&#10;) {&#10;    val textColor = when {&#10;        isCompleted -&gt; SuccessGreen&#10;        isActive -&gt; PrimaryCoral&#10;        else -&gt; TextSecondary&#10;    }&#10;&#10;    //  PROPER STOPWATCH: Start from stored time and count up properly&#10;    var displayTime by remember(time) { mutableStateOf(time) }&#10;&#10;    // Track when timer starts to calculate elapsed time properly&#10;    val startTimeRef = remember { mutableStateOf(0L) }&#10;&#10;    LaunchedEffect(isActive) {&#10;        if (isActive) {&#10;            // Record the actual start time when timer becomes active&#10;            startTimeRef.value = System.currentTimeMillis()&#10;&#10;            while (isActive) {&#10;                // Calculate elapsed seconds since timer started&#10;                val elapsedMs = System.currentTimeMillis() - startTimeRef.value&#10;                val elapsedSeconds = elapsedMs / 1000&#10;&#10;                // Display = stored time + elapsed time&#10;                displayTime = time + elapsedSeconds&#10;&#10;                delay(1000) // Update every second&#10;            }&#10;        } else {&#10;            // When not active, show the stored time from database&#10;            displayTime = time&#10;        }&#10;    }&#10;&#10;    Text(&#10;        text = formatTime(displayTime),&#10;        style = MaterialTheme.typography.titleLarge.copy(&#10;            fontSize = if (isActive) 20.sp else 18.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = textColor&#10;        )&#10;    )&#10;}&#10;&#10;private fun formatTime(timeInSeconds: Long): String {&#10;    val hours = timeInSeconds / 3600&#10;    val minutes = (timeInSeconds % 3600) / 60&#10;    val seconds = timeInSeconds % 60&#10;&#10;    return if (hours &gt; 0) {&#10;        String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds)&#10;    } else {&#10;        String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;    }&#10;}&#10;&#10;//  NEW: Rest Timer Card Component&#10;@Composable&#10;fun RestTimerCard(&#10;    restTime: Long,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .shadow(6.dp, RoundedCornerShape(16.dp)),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = AmberAccent.copy(alpha = 0.1f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                // Rest icon - using a pause/timer-like icon&#10;                Icon(&#10;                    imageVector = Icons.Default.PlayArrow, // We'll use this as a rest indicator&#10;                    contentDescription = &quot;Rest&quot;,&#10;                    tint = AmberAccent,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                Text(&#10;                    text = &quot;Rest Timer&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = TextPrimary&#10;                    )&#10;                )&#10;            }&#10;&#10;            // Rest time display with prominent styling&#10;            Text(&#10;                text = formatTime(restTime),&#10;                style = MaterialTheme.typography.headlineMedium.copy(&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = AmberAccent,&#10;                    fontSize = 24.sp&#10;                )&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/TemplateSelectionScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/screens/TemplateSelectionScreen.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.screens&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.offlinepplworkoutapp.data.entity.WorkoutTemplate&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModel&#10;import com.example.offlinepplworkoutapp.ui.viewmodel.DailyWorkoutViewModelFactory&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TemplateSelectionScreen(&#10;    repository: WorkoutRepository,&#10;    selectedDate: String,&#10;    onTemplateSelected: (WorkoutTemplate) -&gt; Unit,&#10;    onBackClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val viewModel: DailyWorkoutViewModel = viewModel(&#10;        factory = DailyWorkoutViewModelFactory(repository)&#10;    )&#10;&#10;    val availableTemplates by viewModel.availableTemplates.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;&#10;    // Load templates when screen opens&#10;    LaunchedEffect(Unit) {&#10;        // Load templates using the public method - since loadAvailableTemplates() is private,&#10;        // the templates should already be loaded in the ViewModel init&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Choose Your Workout&quot;,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface,&#10;                    titleContentColor = MaterialTheme.colorScheme.onSurface&#10;                )&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Date display&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = &quot;Workout for $selectedDate&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp)&#10;                )&#10;            }&#10;&#10;            if (isLoading) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            } else if (availableTemplates.isEmpty()) {&#10;                EmptyTemplateState()&#10;            } else {&#10;                LazyColumn(&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    item {&#10;                        Text(&#10;                            text = &quot;Available Workout Templates&quot;,&#10;                            style = MaterialTheme.typography.titleLarge,&#10;                            fontWeight = FontWeight.Bold,&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;&#10;                    items(availableTemplates) { template -&gt;&#10;                        TemplateCard(&#10;                            template = template,&#10;                            onClick = { onTemplateSelected(template) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TemplateCard(&#10;    template: WorkoutTemplate,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() },&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Template header&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = template.name,&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;&#10;                    Text(&#10;                        text = template.category,&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        color = getCategoryColor(template.category),&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;&#10;                // Difficulty indicator&#10;                DifficultyChip(difficulty = template.difficulty)&#10;            }&#10;&#10;            // Template description&#10;            if (template.description.isNotBlank()) {&#10;                Text(&#10;                    text = template.description,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;&#10;            // Template metadata&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(top = 12.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                // Estimated duration (using a default value since estimatedDurationMinutes doesn't exist)&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.PlayArrow,&#10;                        contentDescription = &quot;Duration&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;45-60 min&quot;, // Default estimated duration&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(start = 4.dp)&#10;                    )&#10;                }&#10;&#10;                // Exercise count&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Star,&#10;                        contentDescription = &quot;Exercises&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;6 exercises&quot;, // Default exercise count&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(start = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Last used info&#10;            if (template.lastUsedDate != null) {&#10;                Text(&#10;                    text = &quot;Last used: ${template.lastUsedDate}&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DifficultyChip(&#10;    difficulty: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val (color, text) = when (difficulty.lowercase()) {&#10;        &quot;beginner&quot; -&gt; Pair(Color(0xFF4CAF50), &quot;Beginner&quot;)&#10;        &quot;intermediate&quot; -&gt; Pair(Color(0xFFFF9800), &quot;Intermediate&quot;)&#10;        &quot;advanced&quot; -&gt; Pair(Color(0xFFF44336), &quot;Advanced&quot;)&#10;        else -&gt; Pair(MaterialTheme.colorScheme.primary, difficulty)&#10;    }&#10;&#10;    Surface(&#10;        modifier = modifier,&#10;        color = color.copy(alpha = 0.1f),&#10;        shape = MaterialTheme.shapes.small&#10;    ) {&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Star,&#10;                contentDescription = &quot;Difficulty&quot;,&#10;                tint = color,&#10;                modifier = Modifier.size(12.dp)&#10;            )&#10;            Text(&#10;                text = text,&#10;                style = MaterialTheme.typography.labelSmall,&#10;                color = color,&#10;                fontWeight = FontWeight.Medium,&#10;                modifier = Modifier.padding(start = 4.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmptyTemplateState() {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Star,&#10;            contentDescription = &quot;No Templates&quot;,&#10;            tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.size(64.dp)&#10;        )&#10;&#10;        Text(&#10;            text = &quot;No Templates Available&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.padding(top = 16.dp)&#10;        )&#10;&#10;        Text(&#10;            text = &quot;Templates are being loaded. Please wait...&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.padding(vertical = 8.dp, horizontal = 32.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun getCategoryColor(category: String): Color {&#10;    return when (category.lowercase()) {&#10;        &quot;push&quot; -&gt; Color(0xFFE57373) // Light red&#10;        &quot;pull&quot; -&gt; Color(0xFF64B5F6) // Light blue&#10;        &quot;legs&quot; -&gt; Color(0xFF81C784) // Light green&#10;        else -&gt; MaterialTheme.colorScheme.primary&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/viewmodel/ExerciseDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/offlinepplworkoutapp/ui/viewmodel/ExerciseDetailViewModel.kt" />
              <option name="originalContent" value="package com.example.offlinepplworkoutapp.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class SetTimer(&#10;    val setNumber: Int,&#10;    val elapsedTime: Long = 0L,&#10;    val isRunning: Boolean = false,&#10;    val isCompleted: Boolean = false,&#10;    val startTime: Long = 0L&#10;)&#10;&#10;class ExerciseDetailViewModel(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModel() {&#10;&#10;    // Load actual sets from database instead of creating in memory&#10;    private val _setTimers = MutableStateFlow&lt;List&lt;SetTimer&gt;&gt;(emptyList())&#10;    val setTimers: StateFlow&lt;List&lt;SetTimer&gt;&gt; = _setTimers.asStateFlow()&#10;&#10;    private val _currentRunningSet = MutableStateFlow&lt;Int?&gt;(null)&#10;    val currentRunningSet: StateFlow&lt;Int?&gt; = _currentRunningSet.asStateFlow()&#10;&#10;    private val _activeSetIndex = MutableStateFlow&lt;Int&gt;(0)&#10;    val activeSetIndex: StateFlow&lt;Int&gt; = _activeSetIndex.asStateFlow()&#10;&#10;    private val _totalExerciseTime = MutableStateFlow(0L)&#10;    val totalExerciseTime: StateFlow&lt;Long&gt; = _totalExerciseTime.asStateFlow()&#10;&#10;    private val _completedSets = MutableStateFlow(0)&#10;    val completedSets: StateFlow&lt;Int&gt; = _completedSets.asStateFlow()&#10;&#10;    private val _isExerciseCompleted = MutableStateFlow(false)&#10;    val isExerciseCompleted: StateFlow&lt;Boolean&gt; = _isExerciseCompleted.asStateFlow()&#10;&#10;    //  FIXED: Enhanced rest timer functionality with proper time tracking&#10;    private val _restTimer = MutableStateFlow(0L)&#10;    val restTimer: StateFlow&lt;Long&gt; = _restTimer.asStateFlow()&#10;&#10;    private val _isRestActive = MutableStateFlow(false)&#10;    val isRestActive: StateFlow&lt;Boolean&gt; = _isRestActive.asStateFlow()&#10;&#10;    //  NEW: Track accumulated rest time for total exercise time calculation&#10;    private val _totalRestTime = MutableStateFlow(0L)&#10;    val totalRestTime: StateFlow&lt;Long&gt; = _totalRestTime.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var restTimerJob: Job? = null&#10;    private var currentSetId: Int? = null&#10;    //  NEW: Track current rest session start time&#10;    private var restStartTime: Long = 0L&#10;&#10;    init {&#10;        loadSetsFromDatabase()&#10;    }&#10;&#10;    private fun loadSetsFromDatabase() {&#10;        viewModelScope.launch {&#10;            println(&quot; DETAIL VM: Loading sets for workout entry ID: ${workoutEntry.id}&quot;)&#10;            println(&quot; DETAIL VM: Exercise: '${workoutEntry.exerciseName}' (Exercise ID: ${workoutEntry.exerciseId})&quot;)&#10;&#10;            // First, ensure sets exist in database&#10;            val existingSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            println(&quot; DETAIL VM: Found ${existingSets.size} existing sets in database&quot;)&#10;&#10;            if (existingSets.isEmpty()) {&#10;                println(&quot; DETAIL VM: No sets found, creating ${workoutEntry.sets} sets&quot;)&#10;                // Create sets in database if they don't exist&#10;                repository.createSetsForWorkoutEntry(workoutEntry.id, workoutEntry.sets)&#10;                println(&quot; DETAIL VM: Sets created, reloading...&quot;)&#10;            } else {&#10;                println(&quot; DETAIL VM: Sets already exist:&quot;)&#10;                existingSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;            }&#10;&#10;            // Now load sets from database and observe changes&#10;            repository.getSetsForWorkoutEntry(workoutEntry.id).collect { dbSets -&gt;&#10;                println(&quot; DETAIL VM: Received ${dbSets.size} sets from Flow for WorkoutEntry ID: ${workoutEntry.id}&quot;)&#10;                dbSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Flow Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;&#10;                val setTimers = dbSets.map { setEntry -&gt;&#10;                    SetTimer(&#10;                        setNumber = setEntry.setNumber,&#10;                        elapsedTime = (setEntry.elapsedTimeSeconds * 1000).toLong(),&#10;                        isRunning = false, // Never restore running state from DB&#10;                        isCompleted = setEntry.isCompleted,&#10;                        startTime = 0L&#10;                    )&#10;                }&#10;&#10;                println(&quot; DETAIL VM: Created ${setTimers.size} SetTimer objects for '${workoutEntry.exerciseName}'&quot;)&#10;                _setTimers.value = setTimers&#10;                _completedSets.value = dbSets.count { it.isCompleted }&#10;                _isExerciseCompleted.value = dbSets.all { it.isCompleted } &amp;&amp; dbSets.isNotEmpty()&#10;&#10;                //  FIX: Set the active set index to the first incomplete set&#10;                val firstIncompleteSetIndex = setTimers.indexOfFirst { !it.isCompleted }&#10;                _activeSetIndex.value = if (firstIncompleteSetIndex != -1) firstIncompleteSetIndex else 0&#10;                println(&quot; DETAIL VM: Set active set index to: ${_activeSetIndex.value}&quot;)&#10;&#10;                updateTotalExerciseTime()&#10;&#10;                println(&quot; DETAIL VM: State updated for '${workoutEntry.exerciseName}' - completedSets: ${_completedSets.value}, isCompleted: ${_isExerciseCompleted.value}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startSetTimer(setIndex: Int) {&#10;        println(&quot; REST DEBUG: startSetTimer called for set ${setIndex + 1}&quot;)&#10;&#10;        // Stop any currently running timer&#10;        stopAllTimers()&#10;&#10;        //  NEW: Stop rest timer when starting a new set&#10;        println(&quot; REST DEBUG: Stopping rest timer before starting new set&quot;)&#10;        stopRestTimer()&#10;&#10;        // Start timer for this set&#10;        val currentTime = System.currentTimeMillis()&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        updatedTimers[setIndex] = updatedTimers[setIndex].copy(&#10;            isRunning = true,&#10;            startTime = currentTime&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = setIndex&#10;&#10;        println(&quot; REST DEBUG: Set ${setIndex + 1} timer started at $currentTime&quot;)&#10;&#10;        // Store the database set ID for persistence&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            currentSetId = dbSets.getOrNull(setIndex)?.id&#10;        }&#10;&#10;        // Start the timer coroutine&#10;        timerJob = viewModelScope.launch {&#10;            while (_setTimers.value.getOrNull(setIndex)?.isRunning == true) {&#10;                delay(1000) // Update every second&#10;                updateTimerForSet(setIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopSetTimer(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        if (timer.isRunning) {&#10;            //  FIXED: Use current elapsed time directly, don't double-count&#10;            val finalElapsedTime = System.currentTimeMillis() - timer.startTime&#10;&#10;            println(&quot; STOP TIMER DEBUG: Set ${setIndex + 1}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: timer.elapsedTime = ${timer.elapsedTime}ms&quot;)&#10;            println(&quot; STOP TIMER DEBUG: startTime = ${timer.startTime}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: currentTime = ${System.currentTimeMillis()}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: calculated elapsed = ${finalElapsedTime}ms (${finalElapsedTime / 1000}s)&quot;)&#10;&#10;            updatedTimers[setIndex] = timer.copy(&#10;                isRunning = false,&#10;                elapsedTime = finalElapsedTime,&#10;                isCompleted = true  // Mark as completed when stopping&#10;            )&#10;            _setTimers.value = updatedTimers&#10;            _currentRunningSet.value = null&#10;            timerJob?.cancel()&#10;&#10;            //  NEW: Start rest timer when set is completed&#10;            startRestTimer()&#10;&#10;            // Persist timer to database&#10;            currentSetId?.let { setId -&gt;&#10;                viewModelScope.launch {&#10;                    repository.updateSetProgress(&#10;                        setId = setId,&#10;                        isCompleted = true,  // Mark as completed in the database&#10;                        elapsedTimeSeconds = (finalElapsedTime / 1000).toInt()&#10;                    )&#10;&#10;                    // Update exercise completion status&#10;                    repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;&#10;                    // Update local completed sets count&#10;                    val completedCount = _setTimers.value.count { it.isCompleted }&#10;                    _completedSets.value = completedCount&#10;&#10;                    // Check if all sets are completed&#10;                    if (completedCount == workoutEntry.sets) {&#10;                        _isExerciseCompleted.value = true&#10;                        // Stop rest timer if all sets are completed&#10;                        stopRestTimer()&#10;                    } else {&#10;                        // Advance to next set - find the first incomplete set&#10;                        val nextIncompleteSetIndex = _setTimers.value.indexOfFirst { !it.isCompleted }&#10;                        if (nextIncompleteSetIndex != -1) {&#10;                            _activeSetIndex.value = nextIncompleteSetIndex&#10;                            println(&quot; DETAIL VM: Advanced to next set index: $nextIncompleteSetIndex&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            updateTotalExerciseTime()&#10;        }&#10;    }&#10;&#10;    fun completeSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        updatedTimers[setIndex] = timer.copy(&#10;            isCompleted = true,&#10;            isRunning = false&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;        timerJob?.cancel()&#10;&#10;        // Persist completion to database&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            val setEntry = dbSets.getOrNull(setIndex)&#10;&#10;            setEntry?.let {&#10;                repository.updateSetProgress(&#10;                    setId = it.id,&#10;                    isCompleted = true,&#10;                    elapsedTimeSeconds = (timer.elapsedTime / 1000).toInt()&#10;                )&#10;&#10;                // Check if all sets are completed and update exercise&#10;                repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;            }&#10;        }&#10;&#10;        // Update local state&#10;        val completedCount = updatedTimers.count { it.isCompleted }&#10;        _completedSets.value = completedCount&#10;&#10;        // Check if all sets are completed&#10;        if (completedCount == workoutEntry.sets) {&#10;            _isExerciseCompleted.value = true&#10;        }&#10;&#10;        updateTotalExerciseTime()&#10;    }&#10;&#10;    //  NEW: Rest timer functionality&#10;    private fun startRestTimer() {&#10;        println(&quot; REST DEBUG: startRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        // Don't start a new rest timer if one is already active&#10;        if (_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer already active, skipping start&quot;)&#10;            return&#10;        }&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to true&quot;)&#10;        _isRestActive.value = true&#10;        val restStartTime = System.currentTimeMillis()&#10;        println(&quot; REST DEBUG: Rest timer start time: $restStartTime&quot;)&#10;&#10;        // Start the rest timer job&#10;        restTimerJob = viewModelScope.launch {&#10;            var elapsedRestTime = 0L&#10;            println(&quot; REST DEBUG: Rest timer coroutine started&quot;)&#10;&#10;            while (_isRestActive.value) {&#10;                delay(1000) // Update every second&#10;                elapsedRestTime += 1000&#10;                _restTimer.value = elapsedRestTime&#10;&#10;                println(&quot;⏱️ REST TIMER: ${elapsedRestTime / 1000}s (Live) - _restTimer.value = ${_restTimer.value}&quot;)&#10;            }&#10;            println(&quot; REST DEBUG: Rest timer coroutine ended&quot;)&#10;        }&#10;&#10;        println(&quot; REST TIMER STARTED - Job created: ${restTimerJob != null}&quot;)&#10;    }&#10;&#10;    private fun stopRestTimer() {&#10;        println(&quot; REST DEBUG: stopRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        if (!_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer not active, nothing to stop&quot;)&#10;            return&#10;        }&#10;&#10;        //  CRITICAL FIX: Capture rest time before stopping&#10;        val completedRestTime = _restTimer.value&#10;        println(&quot; REST DEBUG: Capturing rest time: ${completedRestTime}ms (${completedRestTime / 1000}s)&quot;)&#10;&#10;        //  NEW: Add to total rest time accumulator&#10;        _totalRestTime.value += completedRestTime&#10;        println(&quot; REST DEBUG: Added ${completedRestTime}ms to total rest time&quot;)&#10;        println(&quot; REST DEBUG: Total accumulated rest time is now: ${_totalRestTime.value}ms (${_totalRestTime.value / 1000}s)&quot;)&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to false&quot;)&#10;        _isRestActive.value = false&#10;&#10;        println(&quot; REST DEBUG: Cancelling rest timer job&quot;)&#10;        restTimerJob?.cancel()&#10;        restTimerJob = null&#10;&#10;        // Reset rest timer value (but keep the accumulated total)&#10;        val previousValue = _restTimer.value&#10;        _restTimer.value = 0L&#10;        println(&quot; REST DEBUG: Reset _restTimer from ${previousValue}ms to ${_restTimer.value}ms&quot;)&#10;&#10;        //  NEW: Update total exercise time with new rest time&#10;        updateTotalExerciseTime()&#10;&#10;        println(&quot;⏹️ REST TIMER STOPPED - Rest time captured and added to total&quot;)&#10;    }&#10;&#10;    private fun stopAllTimers() {&#10;        timerJob?.cancel()&#10;        val updatedTimers = _setTimers.value.map { timer -&gt;&#10;            timer.copy(isRunning = false)&#10;        }&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;    }&#10;&#10;    private fun updateTimerForSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers[setIndex]&#10;&#10;        if (timer.isRunning) {&#10;            val currentTime = System.currentTimeMillis()&#10;            //  FIXED: Don't add previous elapsedTime - just calculate from start&#10;            val elapsed = currentTime - timer.startTime&#10;            updatedTimers[setIndex] = timer.copy(elapsedTime = elapsed)&#10;            _setTimers.value = updatedTimers&#10;&#10;            //  REMOVED: Don't update total time during live timer updates&#10;            // updateTotalExerciseTime() // This was causing live updates in top bar&#10;&#10;            //  ADDED: Force UI recomposition for live stopwatch display&#10;            println(&quot;⏱️ TIMER: Set ${setIndex + 1} - ${elapsed / 1000}s (Live)&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateTotalExerciseTime() {&#10;        //  FIXED: Only count completed sets for total time, not running timers&#10;        val completedSets = _setTimers.value.filter { it.isCompleted }&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Calculating total exercise time...&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Found ${completedSets.size} completed sets:&quot;)&#10;&#10;        completedSets.forEachIndexed { index, set -&gt;&#10;            println(&quot; TOTAL TIME DEBUG: Set ${index + 1}: ${set.elapsedTime}ms (${set.elapsedTime / 1000}s)&quot;)&#10;        }&#10;&#10;        val setTime = completedSets.sumOf { it.elapsedTime }&#10;&#10;        //  NEW: Include accumulated rest time in total&#10;        val restTime = _totalRestTime.value&#10;        val totalTime = setTime + restTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Sum of all completed sets: ${setTime}ms (${setTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Total accumulated rest time: ${restTime}ms (${restTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Combined total time: ${totalTime}ms (${totalTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Setting _totalExerciseTime to: ${totalTime}&quot;)&#10;&#10;        _totalExerciseTime.value = totalTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: _totalExerciseTime.value is now: ${_totalExerciseTime.value}&quot;)&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        restTimerJob?.cancel() //  NEW: Clean up rest timer job&#10;    }&#10;}&#10;&#10;class ExerciseDetailViewModelFactory(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ExerciseDetailViewModel::class.java)) {&#10;            return ExerciseDetailViewModel(workoutEntry, repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.offlinepplworkoutapp.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.offlinepplworkoutapp.data.dao.WorkoutEntryWithExercise&#10;import com.example.offlinepplworkoutapp.data.repository.WorkoutRepository&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class SetTimer(&#10;    val setNumber: Int,&#10;    val elapsedTime: Long = 0L,&#10;    val isRunning: Boolean = false,&#10;    val isCompleted: Boolean = false,&#10;    val startTime: Long = 0L&#10;)&#10;&#10;class ExerciseDetailViewModel(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModel() {&#10;&#10;    // Load actual sets from database instead of creating in memory&#10;    private val _setTimers = MutableStateFlow&lt;List&lt;SetTimer&gt;&gt;(emptyList())&#10;    val setTimers: StateFlow&lt;List&lt;SetTimer&gt;&gt; = _setTimers.asStateFlow()&#10;&#10;    private val _currentRunningSet = MutableStateFlow&lt;Int?&gt;(null)&#10;    val currentRunningSet: StateFlow&lt;Int?&gt; = _currentRunningSet.asStateFlow()&#10;&#10;    private val _activeSetIndex = MutableStateFlow&lt;Int&gt;(0)&#10;    val activeSetIndex: StateFlow&lt;Int&gt; = _activeSetIndex.asStateFlow()&#10;&#10;    private val _totalExerciseTime = MutableStateFlow(0L)&#10;    val totalExerciseTime: StateFlow&lt;Long&gt; = _totalExerciseTime.asStateFlow()&#10;&#10;    private val _completedSets = MutableStateFlow(0)&#10;    val completedSets: StateFlow&lt;Int&gt; = _completedSets.asStateFlow()&#10;&#10;    private val _isExerciseCompleted = MutableStateFlow(false)&#10;    val isExerciseCompleted: StateFlow&lt;Boolean&gt; = _isExerciseCompleted.asStateFlow()&#10;&#10;    //  FIXED: Enhanced rest timer functionality with proper time tracking&#10;    private val _restTimer = MutableStateFlow(0L)&#10;    val restTimer: StateFlow&lt;Long&gt; = _restTimer.asStateFlow()&#10;&#10;    private val _isRestActive = MutableStateFlow(false)&#10;    val isRestActive: StateFlow&lt;Boolean&gt; = _isRestActive.asStateFlow()&#10;&#10;    //  NEW: Track accumulated rest time for total exercise time calculation&#10;    private val _totalRestTime = MutableStateFlow(0L)&#10;    val totalRestTime: StateFlow&lt;Long&gt; = _totalRestTime.asStateFlow()&#10;&#10;    //  NEW: Phase 2.1.2 - Set data entry dialog state&#10;    private val _showSetDataDialog = MutableStateFlow(false)&#10;    val showSetDataDialog: StateFlow&lt;Boolean&gt; = _showSetDataDialog.asStateFlow()&#10;&#10;    private val _pendingSetData = MutableStateFlow&lt;Pair&lt;Int, Int&gt;?&gt;(null) // (setIndex, setId)&#10;    val pendingSetData: StateFlow&lt;Pair&lt;Int, Int&gt;?&gt; = _pendingSetData.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var restTimerJob: Job? = null&#10;    private var currentSetId: Int? = null&#10;    //  NEW: Track current rest session start time&#10;    private var restStartTime: Long = 0L&#10;&#10;    init {&#10;        loadSetsFromDatabase()&#10;    }&#10;&#10;    private fun loadSetsFromDatabase() {&#10;        viewModelScope.launch {&#10;            println(&quot; DETAIL VM: Loading sets for workout entry ID: ${workoutEntry.id}&quot;)&#10;            println(&quot; DETAIL VM: Exercise: '${workoutEntry.exerciseName}' (Exercise ID: ${workoutEntry.exerciseId})&quot;)&#10;&#10;            // First, ensure sets exist in database&#10;            val existingSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            println(&quot; DETAIL VM: Found ${existingSets.size} existing sets in database&quot;)&#10;&#10;            if (existingSets.isEmpty()) {&#10;                println(&quot; DETAIL VM: No sets found, creating ${workoutEntry.sets} sets&quot;)&#10;                // Create sets in database if they don't exist&#10;                repository.createSetsForWorkoutEntry(workoutEntry.id, workoutEntry.sets)&#10;                println(&quot; DETAIL VM: Sets created, reloading...&quot;)&#10;            } else {&#10;                println(&quot; DETAIL VM: Sets already exist:&quot;)&#10;                existingSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;            }&#10;&#10;            // Now load sets from database and observe changes&#10;            repository.getSetsForWorkoutEntry(workoutEntry.id).collect { dbSets -&gt;&#10;                println(&quot; DETAIL VM: Received ${dbSets.size} sets from Flow for WorkoutEntry ID: ${workoutEntry.id}&quot;)&#10;                dbSets.forEach { set -&gt;&#10;                    println(&quot; DETAIL VM: Flow Set ID=${set.id}, SetNumber=${set.setNumber}, WorkoutEntryId=${set.workoutEntryId}, completed=${set.isCompleted}, time=${set.elapsedTimeSeconds}s&quot;)&#10;                }&#10;&#10;                val setTimers = dbSets.map { setEntry -&gt;&#10;                    SetTimer(&#10;                        setNumber = setEntry.setNumber,&#10;                        elapsedTime = (setEntry.elapsedTimeSeconds * 1000).toLong(),&#10;                        isRunning = false, // Never restore running state from DB&#10;                        isCompleted = setEntry.isCompleted,&#10;                        startTime = 0L&#10;                    )&#10;                }&#10;&#10;                println(&quot; DETAIL VM: Created ${setTimers.size} SetTimer objects for '${workoutEntry.exerciseName}'&quot;)&#10;                _setTimers.value = setTimers&#10;                _completedSets.value = dbSets.count { it.isCompleted }&#10;                _isExerciseCompleted.value = dbSets.all { it.isCompleted } &amp;&amp; dbSets.isNotEmpty()&#10;&#10;                //  FIX: Set the active set index to the first incomplete set&#10;                val firstIncompleteSetIndex = setTimers.indexOfFirst { !it.isCompleted }&#10;                _activeSetIndex.value = if (firstIncompleteSetIndex != -1) firstIncompleteSetIndex else 0&#10;                println(&quot; DETAIL VM: Set active set index to: ${_activeSetIndex.value}&quot;)&#10;&#10;                updateTotalExerciseTime()&#10;&#10;                println(&quot; DETAIL VM: State updated for '${workoutEntry.exerciseName}' - completedSets: ${_completedSets.value}, isCompleted: ${_isExerciseCompleted.value}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startSetTimer(setIndex: Int) {&#10;        println(&quot; REST DEBUG: startSetTimer called for set ${setIndex + 1}&quot;)&#10;&#10;        // Stop any currently running timer&#10;        stopAllTimers()&#10;&#10;        //  NEW: Stop rest timer when starting a new set&#10;        println(&quot; REST DEBUG: Stopping rest timer before starting new set&quot;)&#10;        stopRestTimer()&#10;&#10;        // Start timer for this set&#10;        val currentTime = System.currentTimeMillis()&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        updatedTimers[setIndex] = updatedTimers[setIndex].copy(&#10;            isRunning = true,&#10;            startTime = currentTime&#10;        )&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = setIndex&#10;&#10;        println(&quot; REST DEBUG: Set ${setIndex + 1} timer started at $currentTime&quot;)&#10;&#10;        // Store the database set ID for persistence&#10;        viewModelScope.launch {&#10;            val dbSets = repository.getSetsForWorkoutEntrySync(workoutEntry.id)&#10;            currentSetId = dbSets.getOrNull(setIndex)?.id&#10;        }&#10;&#10;        // Start the timer coroutine&#10;        timerJob = viewModelScope.launch {&#10;            while (_setTimers.value.getOrNull(setIndex)?.isRunning == true) {&#10;                delay(1000) // Update every second&#10;                updateTimerForSet(setIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopSetTimer(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers.getOrNull(setIndex) ?: return&#10;&#10;        if (timer.isRunning) {&#10;            //  FIXED: Use current elapsed time directly, don't double-count&#10;            val finalElapsedTime = System.currentTimeMillis() - timer.startTime&#10;&#10;            println(&quot; STOP TIMER DEBUG: Set ${setIndex + 1}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: timer.elapsedTime = ${timer.elapsedTime}ms&quot;)&#10;            println(&quot; STOP TIMER DEBUG: startTime = ${timer.startTime}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: currentTime = ${System.currentTimeMillis()}&quot;)&#10;            println(&quot; STOP TIMER DEBUG: calculated elapsed = ${finalElapsedTime}ms (${finalElapsedTime / 1000}s)&quot;)&#10;&#10;            updatedTimers[setIndex] = timer.copy(&#10;                isRunning = false,&#10;                elapsedTime = finalElapsedTime&#10;                //  CHANGED: Don't mark as completed here - wait for user data entry&#10;            )&#10;            _setTimers.value = updatedTimers&#10;            _currentRunningSet.value = null&#10;            timerJob?.cancel()&#10;&#10;            //  NEW: Phase 2.1.2 - Show data entry dialog instead of immediate completion&#10;            currentSetId?.let { setId -&gt;&#10;                println(&quot; DIALOG: Showing set data entry dialog for set ${setIndex + 1}&quot;)&#10;                _pendingSetData.value = Pair(setIndex, setId)&#10;                _showSetDataDialog.value = true&#10;                &#10;                //  IMPORTANT: Start rest timer while user enters data&#10;                startRestTimer()&#10;            }&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Handle set performance data submission&#10;    fun submitSetPerformanceData(repsPerformed: Int, weightUsed: Float) {&#10;        val pendingData = _pendingSetData.value ?: return&#10;        val (setIndex, setId) = pendingData&#10;&#10;        println(&quot; DIALOG: Submitting performance data - Set ${setIndex + 1}, Reps: $repsPerformed, Weight: $weightUsed&quot;)&#10;&#10;        viewModelScope.launch {&#10;            // Get the timer data for this set&#10;            val timer = _setTimers.value.getOrNull(setIndex)&#10;            val elapsedTimeSeconds = ((timer?.elapsedTime ?: 0L) / 1000).toInt()&#10;&#10;            // Update database with completion and performance data&#10;            repository.updateSetProgressWithPerformanceData(&#10;                setId = setId,&#10;                isCompleted = true,&#10;                elapsedTimeSeconds = elapsedTimeSeconds,&#10;                repsPerformed = repsPerformed,&#10;                weightUsed = weightUsed&#10;            )&#10;&#10;            // Update local state to mark set as completed&#10;            val updatedTimers = _setTimers.value.toMutableList()&#10;            updatedTimers[setIndex] = updatedTimers[setIndex].copy(isCompleted = true)&#10;            _setTimers.value = updatedTimers&#10;&#10;            // Update exercise completion status&#10;            repository.updateExerciseCompletionFromSets(workoutEntry.id)&#10;&#10;            // Update local completed sets count&#10;            val completedCount = _setTimers.value.count { it.isCompleted }&#10;            _completedSets.value = completedCount&#10;&#10;            // Check if all sets are completed&#10;            if (completedCount == workoutEntry.sets) {&#10;                _isExerciseCompleted.value = true&#10;                // Stop rest timer if all sets are completed&#10;                stopRestTimer()&#10;            } else {&#10;                // Advance to next set - find the first incomplete set&#10;                val nextIncompleteSetIndex = _setTimers.value.indexOfFirst { !it.isCompleted }&#10;                if (nextIncompleteSetIndex != -1) {&#10;                    _activeSetIndex.value = nextIncompleteSetIndex&#10;                    println(&quot; DETAIL VM: Advanced to next set index: $nextIncompleteSetIndex&quot;)&#10;                }&#10;            }&#10;&#10;            // Update total time calculation&#10;            updateTotalExerciseTime()&#10;&#10;            // Hide dialog and clear pending data&#10;            _showSetDataDialog.value = false&#10;            _pendingSetData.value = null&#10;            &#10;            println(&quot; DIALOG: Set performance data saved successfully&quot;)&#10;        }&#10;    }&#10;&#10;    //  NEW: Phase 2.1.2 - Cancel dialog (if needed for future enhancements)&#10;    fun dismissSetDataDialog() {&#10;        // Note: As per requirements, there should be no cancel option&#10;        // This method is for potential future use or error handling&#10;        println(&quot; DIALOG: Dialog dismissed (should not happen in normal flow)&quot;)&#10;        _showSetDataDialog.value = false&#10;        _pendingSetData.value = null&#10;    }&#10;&#10;    //  NEW: Rest timer functionality&#10;    private fun startRestTimer() {&#10;        println(&quot; REST DEBUG: startRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        // Don't start a new rest timer if one is already active&#10;        if (_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer already active, skipping start&quot;)&#10;            return&#10;        }&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to true&quot;)&#10;        _isRestActive.value = true&#10;        val restStartTime = System.currentTimeMillis()&#10;        println(&quot; REST DEBUG: Rest timer start time: $restStartTime&quot;)&#10;&#10;        // Start the rest timer job&#10;        restTimerJob = viewModelScope.launch {&#10;            var elapsedRestTime = 0L&#10;            println(&quot; REST DEBUG: Rest timer coroutine started&quot;)&#10;&#10;            while (_isRestActive.value) {&#10;                delay(1000) // Update every second&#10;                elapsedRestTime += 1000&#10;                _restTimer.value = elapsedRestTime&#10;&#10;                println(&quot;⏱️ REST TIMER: ${elapsedRestTime / 1000}s (Live) - _restTimer.value = ${_restTimer.value}&quot;)&#10;            }&#10;            println(&quot; REST DEBUG: Rest timer coroutine ended&quot;)&#10;        }&#10;&#10;        println(&quot; REST TIMER STARTED - Job created: ${restTimerJob != null}&quot;)&#10;    }&#10;&#10;    private fun stopRestTimer() {&#10;        println(&quot; REST DEBUG: stopRestTimer() called&quot;)&#10;        println(&quot; REST DEBUG: Current _isRestActive state: ${_isRestActive.value}&quot;)&#10;&#10;        if (!_isRestActive.value) {&#10;            println(&quot; REST DEBUG: Rest timer not active, nothing to stop&quot;)&#10;            return&#10;        }&#10;&#10;        //  CRITICAL FIX: Capture rest time before stopping&#10;        val completedRestTime = _restTimer.value&#10;        println(&quot; REST DEBUG: Capturing rest time: ${completedRestTime}ms (${completedRestTime / 1000}s)&quot;)&#10;&#10;        //  NEW: Add to total rest time accumulator&#10;        _totalRestTime.value += completedRestTime&#10;        println(&quot; REST DEBUG: Added ${completedRestTime}ms to total rest time&quot;)&#10;        println(&quot; REST DEBUG: Total accumulated rest time is now: ${_totalRestTime.value}ms (${_totalRestTime.value / 1000}s)&quot;)&#10;&#10;        println(&quot; REST DEBUG: Setting _isRestActive to false&quot;)&#10;        _isRestActive.value = false&#10;&#10;        println(&quot; REST DEBUG: Cancelling rest timer job&quot;)&#10;        restTimerJob?.cancel()&#10;        restTimerJob = null&#10;&#10;        // Reset rest timer value (but keep the accumulated total)&#10;        val previousValue = _restTimer.value&#10;        _restTimer.value = 0L&#10;        println(&quot; REST DEBUG: Reset _restTimer from ${previousValue}ms to ${_restTimer.value}ms&quot;)&#10;&#10;        //  NEW: Update total exercise time with new rest time&#10;        updateTotalExerciseTime()&#10;&#10;        println(&quot;⏹️ REST TIMER STOPPED - Rest time captured and added to total&quot;)&#10;    }&#10;&#10;    private fun stopAllTimers() {&#10;        timerJob?.cancel()&#10;        val updatedTimers = _setTimers.value.map { timer -&gt;&#10;            timer.copy(isRunning = false)&#10;        }&#10;        _setTimers.value = updatedTimers&#10;        _currentRunningSet.value = null&#10;    }&#10;&#10;    private fun updateTimerForSet(setIndex: Int) {&#10;        val updatedTimers = _setTimers.value.toMutableList()&#10;        val timer = updatedTimers[setIndex]&#10;&#10;        if (timer.isRunning) {&#10;            val currentTime = System.currentTimeMillis()&#10;            //  FIXED: Don't add previous elapsedTime - just calculate from start&#10;            val elapsed = currentTime - timer.startTime&#10;            updatedTimers[setIndex] = timer.copy(elapsedTime = elapsed)&#10;            _setTimers.value = updatedTimers&#10;&#10;            //  REMOVED: Don't update total time during live timer updates&#10;            // updateTotalExerciseTime() // This was causing live updates in top bar&#10;&#10;            //  ADDED: Force UI recomposition for live stopwatch display&#10;            println(&quot;⏱️ TIMER: Set ${setIndex + 1} - ${elapsed / 1000}s (Live)&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateTotalExerciseTime() {&#10;        //  FIXED: Only count completed sets for total time, not running timers&#10;        val completedSets = _setTimers.value.filter { it.isCompleted }&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Calculating total exercise time...&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Found ${completedSets.size} completed sets:&quot;)&#10;&#10;        completedSets.forEachIndexed { index, set -&gt;&#10;            println(&quot; TOTAL TIME DEBUG: Set ${index + 1}: ${set.elapsedTime}ms (${set.elapsedTime / 1000}s)&quot;)&#10;        }&#10;&#10;        val setTime = completedSets.sumOf { it.elapsedTime }&#10;&#10;        //  NEW: Include accumulated rest time in total&#10;        val restTime = _totalRestTime.value&#10;        val totalTime = setTime + restTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: Sum of all completed sets: ${setTime}ms (${setTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Total accumulated rest time: ${restTime}ms (${restTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Combined total time: ${totalTime}ms (${totalTime / 1000}s)&quot;)&#10;        println(&quot; TOTAL TIME DEBUG: Setting _totalExerciseTime to: ${totalTime}&quot;)&#10;&#10;        _totalExerciseTime.value = totalTime&#10;&#10;        println(&quot; TOTAL TIME DEBUG: _totalExerciseTime.value is now: ${_totalExerciseTime.value}&quot;)&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        restTimerJob?.cancel() //  NEW: Clean up rest timer job&#10;    }&#10;}&#10;&#10;class ExerciseDetailViewModelFactory(&#10;    private val workoutEntry: WorkoutEntryWithExercise,&#10;    private val repository: WorkoutRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ExerciseDetailViewModel::class.java)) {&#10;            return ExerciseDetailViewModel(workoutEntry, repository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>